
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Verification
 * 
 */
export type Verification = $Result.DefaultSelection<Prisma.$VerificationPayload>
/**
 * Model Folder
 * A user-created folder that groups that user's lectures.
 * Requirement: "The user must create a Folder to save it's related Lectures"
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model Lecture
 * A lecture belongs to exactly one folder and one owner.
 * It aggregates many uploaded sources and many generated artifacts.
 */
export type Lecture = $Result.DefaultSelection<Prisma.$LecturePayload>
/**
 * Model LectureSource
 * A single upload/input for a lecture. Supports multiple kinds.
 * Requirement: "Each Lecture can has a multiple uploaded sources"
 */
export type LectureSource = $Result.DefaultSelection<Prisma.$LectureSourcePayload>
/**
 * Model ContentArtifact
 * A unified "generated artifact" record per lecture output.
 * Requirement: podcasts{many}, videos{many}, Q&A{many}, flash cards{many}
 */
export type ContentArtifact = $Result.DefaultSelection<Prisma.$ContentArtifactPayload>
/**
 * Model ArtifactSource
 * Join table so a generated artifact can point back to the specific lecture sources it used.
 */
export type ArtifactSource = $Result.DefaultSelection<Prisma.$ArtifactSourcePayload>
/**
 * Model QAPair
 * Individual question/answer entries for a QA_SET artifact.
 */
export type QAPair = $Result.DefaultSelection<Prisma.$QAPairPayload>
/**
 * Model Flashcard
 * Individual flashcards belonging to a FLASHCARD_SET artifact.
 */
export type Flashcard = $Result.DefaultSelection<Prisma.$FlashcardPayload>
/**
 * Model LectureAssistant
 * One assistant "thread" per lecture.
 * Requirement: "Each Lecture has a chatbot assistant 'Aref/Arifah'"
 */
export type LectureAssistant = $Result.DefaultSelection<Prisma.$LectureAssistantPayload>
/**
 * Model ChatMessage
 * Messages within the lecture assistant thread.
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>
/**
 * Model Bookmark
 * Requirement: "The user can Bookmark a Lecture to be in the Bookmarks Folder"
 * Represented as a join; you can render this as a 'virtual Bookmarks folder' in UI.
 */
export type Bookmark = $Result.DefaultSelection<Prisma.$BookmarkPayload>
/**
 * Model Room
 * Requirement: "The user can create a Room"
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomMembership
 * Requirement: "The user who create the Room is the Owner ... invite another users ... Members"
 */
export type RoomMembership = $Result.DefaultSelection<Prisma.$RoomMembershipPayload>
/**
 * Model RoomShare
 * Requirement: "Owner and Members can share their Multi‑format output content
 * generation ... in this Room"
 */
export type RoomShare = $Result.DefaultSelection<Prisma.$RoomSharePayload>
/**
 * Model RoomNote
 * Requirement: "The Owner and Members can provide a note to the shared
 * Multi‑format output content generation"
 */
export type RoomNote = $Result.DefaultSelection<Prisma.$RoomNotePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SourceType: {
  PDF: 'PDF',
  MARKDOWN: 'MARKDOWN',
  TEXT: 'TEXT',
  AUDIO: 'AUDIO',
  YOUTUBE: 'YOUTUBE'
};

export type SourceType = (typeof SourceType)[keyof typeof SourceType]


export const ArtifactType: {
  PODCAST: 'PODCAST',
  VIDEO: 'VIDEO',
  QA_SET: 'QA_SET',
  FLASHCARD_SET: 'FLASHCARD_SET'
};

export type ArtifactType = (typeof ArtifactType)[keyof typeof ArtifactType]


export const ProcessingStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  FAILED: 'FAILED'
};

export type ProcessingStatus = (typeof ProcessingStatus)[keyof typeof ProcessingStatus]


export const ChatRole: {
  USER: 'USER',
  ASSISTANT: 'ASSISTANT',
  SYSTEM: 'SYSTEM',
  TOOL: 'TOOL'
};

export type ChatRole = (typeof ChatRole)[keyof typeof ChatRole]


export const MemberRole: {
  OWNER: 'OWNER',
  MEMBER: 'MEMBER'
};

export type MemberRole = (typeof MemberRole)[keyof typeof MemberRole]


export const MemberStatus: {
  INVITED: 'INVITED',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  REMOVED: 'REMOVED'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]

}

export type SourceType = $Enums.SourceType

export const SourceType: typeof $Enums.SourceType

export type ArtifactType = $Enums.ArtifactType

export const ArtifactType: typeof $Enums.ArtifactType

export type ProcessingStatus = $Enums.ProcessingStatus

export const ProcessingStatus: typeof $Enums.ProcessingStatus

export type ChatRole = $Enums.ChatRole

export const ChatRole: typeof $Enums.ChatRole

export type MemberRole = $Enums.MemberRole

export const MemberRole: typeof $Enums.MemberRole

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verification`: Exposes CRUD operations for the **Verification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Verifications
    * const verifications = await prisma.verification.findMany()
    * ```
    */
  get verification(): Prisma.VerificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lecture`: Exposes CRUD operations for the **Lecture** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lectures
    * const lectures = await prisma.lecture.findMany()
    * ```
    */
  get lecture(): Prisma.LectureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lectureSource`: Exposes CRUD operations for the **LectureSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LectureSources
    * const lectureSources = await prisma.lectureSource.findMany()
    * ```
    */
  get lectureSource(): Prisma.LectureSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentArtifact`: Exposes CRUD operations for the **ContentArtifact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentArtifacts
    * const contentArtifacts = await prisma.contentArtifact.findMany()
    * ```
    */
  get contentArtifact(): Prisma.ContentArtifactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.artifactSource`: Exposes CRUD operations for the **ArtifactSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArtifactSources
    * const artifactSources = await prisma.artifactSource.findMany()
    * ```
    */
  get artifactSource(): Prisma.ArtifactSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.qAPair`: Exposes CRUD operations for the **QAPair** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QAPairs
    * const qAPairs = await prisma.qAPair.findMany()
    * ```
    */
  get qAPair(): Prisma.QAPairDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flashcard`: Exposes CRUD operations for the **Flashcard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flashcards
    * const flashcards = await prisma.flashcard.findMany()
    * ```
    */
  get flashcard(): Prisma.FlashcardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lectureAssistant`: Exposes CRUD operations for the **LectureAssistant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LectureAssistants
    * const lectureAssistants = await prisma.lectureAssistant.findMany()
    * ```
    */
  get lectureAssistant(): Prisma.LectureAssistantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bookmark`: Exposes CRUD operations for the **Bookmark** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookmarks
    * const bookmarks = await prisma.bookmark.findMany()
    * ```
    */
  get bookmark(): Prisma.BookmarkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomMembership`: Exposes CRUD operations for the **RoomMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomMemberships
    * const roomMemberships = await prisma.roomMembership.findMany()
    * ```
    */
  get roomMembership(): Prisma.RoomMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomShare`: Exposes CRUD operations for the **RoomShare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomShares
    * const roomShares = await prisma.roomShare.findMany()
    * ```
    */
  get roomShare(): Prisma.RoomShareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomNote`: Exposes CRUD operations for the **RoomNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomNotes
    * const roomNotes = await prisma.roomNote.findMany()
    * ```
    */
  get roomNote(): Prisma.RoomNoteDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.1
   * Query Engine version: f09f2815f091dbba658cdcd2264306d88bb5bda6
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Account: 'Account',
    Verification: 'Verification',
    Folder: 'Folder',
    Lecture: 'Lecture',
    LectureSource: 'LectureSource',
    ContentArtifact: 'ContentArtifact',
    ArtifactSource: 'ArtifactSource',
    QAPair: 'QAPair',
    Flashcard: 'Flashcard',
    LectureAssistant: 'LectureAssistant',
    ChatMessage: 'ChatMessage',
    Bookmark: 'Bookmark',
    Room: 'Room',
    RoomMembership: 'RoomMembership',
    RoomShare: 'RoomShare',
    RoomNote: 'RoomNote'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "session" | "account" | "verification" | "folder" | "lecture" | "lectureSource" | "contentArtifact" | "artifactSource" | "qAPair" | "flashcard" | "lectureAssistant" | "chatMessage" | "bookmark" | "room" | "roomMembership" | "roomShare" | "roomNote"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Verification: {
        payload: Prisma.$VerificationPayload<ExtArgs>
        fields: Prisma.VerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findFirst: {
            args: Prisma.VerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          findMany: {
            args: Prisma.VerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          create: {
            args: Prisma.VerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          createMany: {
            args: Prisma.VerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          delete: {
            args: Prisma.VerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          update: {
            args: Prisma.VerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          deleteMany: {
            args: Prisma.VerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>[]
          }
          upsert: {
            args: Prisma.VerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationPayload>
          }
          aggregate: {
            args: Prisma.VerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerification>
          }
          groupBy: {
            args: Prisma.VerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      Lecture: {
        payload: Prisma.$LecturePayload<ExtArgs>
        fields: Prisma.LectureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LectureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LectureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          findFirst: {
            args: Prisma.LectureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LectureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          findMany: {
            args: Prisma.LectureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[]
          }
          create: {
            args: Prisma.LectureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          createMany: {
            args: Prisma.LectureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LectureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[]
          }
          delete: {
            args: Prisma.LectureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          update: {
            args: Prisma.LectureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          deleteMany: {
            args: Prisma.LectureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LectureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LectureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>[]
          }
          upsert: {
            args: Prisma.LectureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LecturePayload>
          }
          aggregate: {
            args: Prisma.LectureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLecture>
          }
          groupBy: {
            args: Prisma.LectureGroupByArgs<ExtArgs>
            result: $Utils.Optional<LectureGroupByOutputType>[]
          }
          count: {
            args: Prisma.LectureCountArgs<ExtArgs>
            result: $Utils.Optional<LectureCountAggregateOutputType> | number
          }
        }
      }
      LectureSource: {
        payload: Prisma.$LectureSourcePayload<ExtArgs>
        fields: Prisma.LectureSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LectureSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LectureSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          findFirst: {
            args: Prisma.LectureSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LectureSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          findMany: {
            args: Prisma.LectureSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>[]
          }
          create: {
            args: Prisma.LectureSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          createMany: {
            args: Prisma.LectureSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LectureSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>[]
          }
          delete: {
            args: Prisma.LectureSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          update: {
            args: Prisma.LectureSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          deleteMany: {
            args: Prisma.LectureSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LectureSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LectureSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>[]
          }
          upsert: {
            args: Prisma.LectureSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureSourcePayload>
          }
          aggregate: {
            args: Prisma.LectureSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLectureSource>
          }
          groupBy: {
            args: Prisma.LectureSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LectureSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LectureSourceCountArgs<ExtArgs>
            result: $Utils.Optional<LectureSourceCountAggregateOutputType> | number
          }
        }
      }
      ContentArtifact: {
        payload: Prisma.$ContentArtifactPayload<ExtArgs>
        fields: Prisma.ContentArtifactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentArtifactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentArtifactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          findFirst: {
            args: Prisma.ContentArtifactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentArtifactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          findMany: {
            args: Prisma.ContentArtifactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>[]
          }
          create: {
            args: Prisma.ContentArtifactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          createMany: {
            args: Prisma.ContentArtifactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentArtifactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>[]
          }
          delete: {
            args: Prisma.ContentArtifactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          update: {
            args: Prisma.ContentArtifactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          deleteMany: {
            args: Prisma.ContentArtifactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentArtifactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentArtifactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>[]
          }
          upsert: {
            args: Prisma.ContentArtifactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentArtifactPayload>
          }
          aggregate: {
            args: Prisma.ContentArtifactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentArtifact>
          }
          groupBy: {
            args: Prisma.ContentArtifactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentArtifactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentArtifactCountArgs<ExtArgs>
            result: $Utils.Optional<ContentArtifactCountAggregateOutputType> | number
          }
        }
      }
      ArtifactSource: {
        payload: Prisma.$ArtifactSourcePayload<ExtArgs>
        fields: Prisma.ArtifactSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArtifactSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArtifactSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          findFirst: {
            args: Prisma.ArtifactSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArtifactSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          findMany: {
            args: Prisma.ArtifactSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>[]
          }
          create: {
            args: Prisma.ArtifactSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          createMany: {
            args: Prisma.ArtifactSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArtifactSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>[]
          }
          delete: {
            args: Prisma.ArtifactSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          update: {
            args: Prisma.ArtifactSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          deleteMany: {
            args: Prisma.ArtifactSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArtifactSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ArtifactSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>[]
          }
          upsert: {
            args: Prisma.ArtifactSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArtifactSourcePayload>
          }
          aggregate: {
            args: Prisma.ArtifactSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArtifactSource>
          }
          groupBy: {
            args: Prisma.ArtifactSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArtifactSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArtifactSourceCountArgs<ExtArgs>
            result: $Utils.Optional<ArtifactSourceCountAggregateOutputType> | number
          }
        }
      }
      QAPair: {
        payload: Prisma.$QAPairPayload<ExtArgs>
        fields: Prisma.QAPairFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QAPairFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QAPairFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          findFirst: {
            args: Prisma.QAPairFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QAPairFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          findMany: {
            args: Prisma.QAPairFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>[]
          }
          create: {
            args: Prisma.QAPairCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          createMany: {
            args: Prisma.QAPairCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QAPairCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>[]
          }
          delete: {
            args: Prisma.QAPairDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          update: {
            args: Prisma.QAPairUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          deleteMany: {
            args: Prisma.QAPairDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QAPairUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QAPairUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>[]
          }
          upsert: {
            args: Prisma.QAPairUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QAPairPayload>
          }
          aggregate: {
            args: Prisma.QAPairAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQAPair>
          }
          groupBy: {
            args: Prisma.QAPairGroupByArgs<ExtArgs>
            result: $Utils.Optional<QAPairGroupByOutputType>[]
          }
          count: {
            args: Prisma.QAPairCountArgs<ExtArgs>
            result: $Utils.Optional<QAPairCountAggregateOutputType> | number
          }
        }
      }
      Flashcard: {
        payload: Prisma.$FlashcardPayload<ExtArgs>
        fields: Prisma.FlashcardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlashcardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlashcardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          findFirst: {
            args: Prisma.FlashcardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlashcardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          findMany: {
            args: Prisma.FlashcardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          create: {
            args: Prisma.FlashcardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          createMany: {
            args: Prisma.FlashcardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlashcardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          delete: {
            args: Prisma.FlashcardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          update: {
            args: Prisma.FlashcardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          deleteMany: {
            args: Prisma.FlashcardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlashcardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlashcardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>[]
          }
          upsert: {
            args: Prisma.FlashcardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlashcardPayload>
          }
          aggregate: {
            args: Prisma.FlashcardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlashcard>
          }
          groupBy: {
            args: Prisma.FlashcardGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlashcardGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlashcardCountArgs<ExtArgs>
            result: $Utils.Optional<FlashcardCountAggregateOutputType> | number
          }
        }
      }
      LectureAssistant: {
        payload: Prisma.$LectureAssistantPayload<ExtArgs>
        fields: Prisma.LectureAssistantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LectureAssistantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LectureAssistantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          findFirst: {
            args: Prisma.LectureAssistantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LectureAssistantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          findMany: {
            args: Prisma.LectureAssistantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>[]
          }
          create: {
            args: Prisma.LectureAssistantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          createMany: {
            args: Prisma.LectureAssistantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LectureAssistantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>[]
          }
          delete: {
            args: Prisma.LectureAssistantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          update: {
            args: Prisma.LectureAssistantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          deleteMany: {
            args: Prisma.LectureAssistantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LectureAssistantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LectureAssistantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>[]
          }
          upsert: {
            args: Prisma.LectureAssistantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LectureAssistantPayload>
          }
          aggregate: {
            args: Prisma.LectureAssistantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLectureAssistant>
          }
          groupBy: {
            args: Prisma.LectureAssistantGroupByArgs<ExtArgs>
            result: $Utils.Optional<LectureAssistantGroupByOutputType>[]
          }
          count: {
            args: Prisma.LectureAssistantCountArgs<ExtArgs>
            result: $Utils.Optional<LectureAssistantCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChatMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
      Bookmark: {
        payload: Prisma.$BookmarkPayload<ExtArgs>
        fields: Prisma.BookmarkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookmarkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookmarkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findFirst: {
            args: Prisma.BookmarkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookmarkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          findMany: {
            args: Prisma.BookmarkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          create: {
            args: Prisma.BookmarkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          createMany: {
            args: Prisma.BookmarkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookmarkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          delete: {
            args: Prisma.BookmarkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          update: {
            args: Prisma.BookmarkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          deleteMany: {
            args: Prisma.BookmarkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookmarkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookmarkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>[]
          }
          upsert: {
            args: Prisma.BookmarkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookmarkPayload>
          }
          aggregate: {
            args: Prisma.BookmarkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBookmark>
          }
          groupBy: {
            args: Prisma.BookmarkGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookmarkGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookmarkCountArgs<ExtArgs>
            result: $Utils.Optional<BookmarkCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomMembership: {
        payload: Prisma.$RoomMembershipPayload<ExtArgs>
        fields: Prisma.RoomMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          findFirst: {
            args: Prisma.RoomMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          findMany: {
            args: Prisma.RoomMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>[]
          }
          create: {
            args: Prisma.RoomMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          createMany: {
            args: Prisma.RoomMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>[]
          }
          delete: {
            args: Prisma.RoomMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          update: {
            args: Prisma.RoomMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          deleteMany: {
            args: Prisma.RoomMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>[]
          }
          upsert: {
            args: Prisma.RoomMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          aggregate: {
            args: Prisma.RoomMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomMembership>
          }
          groupBy: {
            args: Prisma.RoomMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<RoomMembershipCountAggregateOutputType> | number
          }
        }
      }
      RoomShare: {
        payload: Prisma.$RoomSharePayload<ExtArgs>
        fields: Prisma.RoomShareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomShareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomShareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          findFirst: {
            args: Prisma.RoomShareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomShareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          findMany: {
            args: Prisma.RoomShareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>[]
          }
          create: {
            args: Prisma.RoomShareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          createMany: {
            args: Prisma.RoomShareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomShareCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>[]
          }
          delete: {
            args: Prisma.RoomShareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          update: {
            args: Prisma.RoomShareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          deleteMany: {
            args: Prisma.RoomShareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomShareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomShareUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>[]
          }
          upsert: {
            args: Prisma.RoomShareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomSharePayload>
          }
          aggregate: {
            args: Prisma.RoomShareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomShare>
          }
          groupBy: {
            args: Prisma.RoomShareGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomShareGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomShareCountArgs<ExtArgs>
            result: $Utils.Optional<RoomShareCountAggregateOutputType> | number
          }
        }
      }
      RoomNote: {
        payload: Prisma.$RoomNotePayload<ExtArgs>
        fields: Prisma.RoomNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          findFirst: {
            args: Prisma.RoomNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          findMany: {
            args: Prisma.RoomNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>[]
          }
          create: {
            args: Prisma.RoomNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          createMany: {
            args: Prisma.RoomNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>[]
          }
          delete: {
            args: Prisma.RoomNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          update: {
            args: Prisma.RoomNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          deleteMany: {
            args: Prisma.RoomNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>[]
          }
          upsert: {
            args: Prisma.RoomNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomNotePayload>
          }
          aggregate: {
            args: Prisma.RoomNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomNote>
          }
          groupBy: {
            args: Prisma.RoomNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomNoteCountArgs<ExtArgs>
            result: $Utils.Optional<RoomNoteCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    session?: SessionOmit
    account?: AccountOmit
    verification?: VerificationOmit
    folder?: FolderOmit
    lecture?: LectureOmit
    lectureSource?: LectureSourceOmit
    contentArtifact?: ContentArtifactOmit
    artifactSource?: ArtifactSourceOmit
    qAPair?: QAPairOmit
    flashcard?: FlashcardOmit
    lectureAssistant?: LectureAssistantOmit
    chatMessage?: ChatMessageOmit
    bookmark?: BookmarkOmit
    room?: RoomOmit
    roomMembership?: RoomMembershipOmit
    roomShare?: RoomShareOmit
    roomNote?: RoomNoteOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    accounts: number
    folders: number
    lectures: number
    bookmarks: number
    ownedRooms: number
    roomMemberships: number
    invitationsSent: number
    artifacts: number
    roomShares: number
    roomNotes: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    folders?: boolean | UserCountOutputTypeCountFoldersArgs
    lectures?: boolean | UserCountOutputTypeCountLecturesArgs
    bookmarks?: boolean | UserCountOutputTypeCountBookmarksArgs
    ownedRooms?: boolean | UserCountOutputTypeCountOwnedRoomsArgs
    roomMemberships?: boolean | UserCountOutputTypeCountRoomMembershipsArgs
    invitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs
    artifacts?: boolean | UserCountOutputTypeCountArtifactsArgs
    roomShares?: boolean | UserCountOutputTypeCountRoomSharesArgs
    roomNotes?: boolean | UserCountOutputTypeCountRoomNotesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentArtifactWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomShareWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomNoteWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    lectures: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lectures?: boolean | FolderCountOutputTypeCountLecturesArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountLecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
  }


  /**
   * Count Type LectureCountOutputType
   */

  export type LectureCountOutputType = {
    sources: number
    artifacts: number
    bookmarks: number
  }

  export type LectureCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sources?: boolean | LectureCountOutputTypeCountSourcesArgs
    artifacts?: boolean | LectureCountOutputTypeCountArtifactsArgs
    bookmarks?: boolean | LectureCountOutputTypeCountBookmarksArgs
  }

  // Custom InputTypes
  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureCountOutputType
     */
    select?: LectureCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureSourceWhereInput
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentArtifactWhereInput
  }

  /**
   * LectureCountOutputType without action
   */
  export type LectureCountOutputTypeCountBookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
  }


  /**
   * Count Type LectureSourceCountOutputType
   */

  export type LectureSourceCountOutputType = {
    artifacts: number
  }

  export type LectureSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifacts?: boolean | LectureSourceCountOutputTypeCountArtifactsArgs
  }

  // Custom InputTypes
  /**
   * LectureSourceCountOutputType without action
   */
  export type LectureSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSourceCountOutputType
     */
    select?: LectureSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LectureSourceCountOutputType without action
   */
  export type LectureSourceCountOutputTypeCountArtifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactSourceWhereInput
  }


  /**
   * Count Type ContentArtifactCountOutputType
   */

  export type ContentArtifactCountOutputType = {
    qaPairs: number
    flashcards: number
    shares: number
    sources: number
  }

  export type ContentArtifactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    qaPairs?: boolean | ContentArtifactCountOutputTypeCountQaPairsArgs
    flashcards?: boolean | ContentArtifactCountOutputTypeCountFlashcardsArgs
    shares?: boolean | ContentArtifactCountOutputTypeCountSharesArgs
    sources?: boolean | ContentArtifactCountOutputTypeCountSourcesArgs
  }

  // Custom InputTypes
  /**
   * ContentArtifactCountOutputType without action
   */
  export type ContentArtifactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifactCountOutputType
     */
    select?: ContentArtifactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentArtifactCountOutputType without action
   */
  export type ContentArtifactCountOutputTypeCountQaPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
  }

  /**
   * ContentArtifactCountOutputType without action
   */
  export type ContentArtifactCountOutputTypeCountFlashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
  }

  /**
   * ContentArtifactCountOutputType without action
   */
  export type ContentArtifactCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomShareWhereInput
  }

  /**
   * ContentArtifactCountOutputType without action
   */
  export type ContentArtifactCountOutputTypeCountSourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactSourceWhereInput
  }


  /**
   * Count Type LectureAssistantCountOutputType
   */

  export type LectureAssistantCountOutputType = {
    messages: number
  }

  export type LectureAssistantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | LectureAssistantCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * LectureAssistantCountOutputType without action
   */
  export type LectureAssistantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistantCountOutputType
     */
    select?: LectureAssistantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LectureAssistantCountOutputType without action
   */
  export type LectureAssistantCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    memberships: number
    shares: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | RoomCountOutputTypeCountMembershipsArgs
    shares?: boolean | RoomCountOutputTypeCountSharesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomShareWhereInput
  }


  /**
   * Count Type RoomShareCountOutputType
   */

  export type RoomShareCountOutputType = {
    notes: number
  }

  export type RoomShareCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | RoomShareCountOutputTypeCountNotesArgs
  }

  // Custom InputTypes
  /**
   * RoomShareCountOutputType without action
   */
  export type RoomShareCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShareCountOutputType
     */
    select?: RoomShareCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomShareCountOutputType without action
   */
  export type RoomShareCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomNoteWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: boolean | null
    image: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    folders?: boolean | User$foldersArgs<ExtArgs>
    lectures?: boolean | User$lecturesArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    ownedRooms?: boolean | User$ownedRoomsArgs<ExtArgs>
    roomMemberships?: boolean | User$roomMembershipsArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    artifacts?: boolean | User$artifactsArgs<ExtArgs>
    roomShares?: boolean | User$roomSharesArgs<ExtArgs>
    roomNotes?: boolean | User$roomNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    folders?: boolean | User$foldersArgs<ExtArgs>
    lectures?: boolean | User$lecturesArgs<ExtArgs>
    bookmarks?: boolean | User$bookmarksArgs<ExtArgs>
    ownedRooms?: boolean | User$ownedRoomsArgs<ExtArgs>
    roomMemberships?: boolean | User$roomMembershipsArgs<ExtArgs>
    invitationsSent?: boolean | User$invitationsSentArgs<ExtArgs>
    artifacts?: boolean | User$artifactsArgs<ExtArgs>
    roomShares?: boolean | User$roomSharesArgs<ExtArgs>
    roomNotes?: boolean | User$roomNotesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      folders: Prisma.$FolderPayload<ExtArgs>[]
      lectures: Prisma.$LecturePayload<ExtArgs>[]
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
      ownedRooms: Prisma.$RoomPayload<ExtArgs>[]
      roomMemberships: Prisma.$RoomMembershipPayload<ExtArgs>[]
      invitationsSent: Prisma.$RoomMembershipPayload<ExtArgs>[]
      artifacts: Prisma.$ContentArtifactPayload<ExtArgs>[]
      roomShares: Prisma.$RoomSharePayload<ExtArgs>[]
      roomNotes: Prisma.$RoomNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      emailVerified: boolean
      image: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends User$foldersArgs<ExtArgs> = {}>(args?: Subset<T, User$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lectures<T extends User$lecturesArgs<ExtArgs> = {}>(args?: Subset<T, User$lecturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookmarks<T extends User$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, User$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ownedRooms<T extends User$ownedRoomsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedRoomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomMemberships<T extends User$roomMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$roomMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitationsSent<T extends User$invitationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends User$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, User$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomShares<T extends User$roomSharesArgs<ExtArgs> = {}>(args?: Subset<T, User$roomSharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roomNotes<T extends User$roomNotesArgs<ExtArgs> = {}>(args?: Subset<T, User$roomNotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly image: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.folders
   */
  export type User$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * User.lectures
   */
  export type User$lecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    cursor?: LectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * User.bookmarks
   */
  export type User$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * User.ownedRooms
   */
  export type User$ownedRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * User.roomMemberships
   */
  export type User$roomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    cursor?: RoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * User.invitationsSent
   */
  export type User$invitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    cursor?: RoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * User.artifacts
   */
  export type User$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    where?: ContentArtifactWhereInput
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    cursor?: ContentArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentArtifactScalarFieldEnum | ContentArtifactScalarFieldEnum[]
  }

  /**
   * User.roomShares
   */
  export type User$roomSharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    where?: RoomShareWhereInput
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    cursor?: RoomShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * User.roomNotes
   */
  export type User$roomNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    where?: RoomNoteWhereInput
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    cursor?: RoomNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomNoteScalarFieldEnum | RoomNoteScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    expiresAt: Date | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    ipAddress: string | null
    userAgent: string | null
    userId: string | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    expiresAt: number
    token: number
    createdAt: number
    updatedAt: number
    ipAddress: number
    userAgent: number
    userId: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    expiresAt?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    ipAddress?: true
    userAgent?: true
    userId?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    expiresAt: Date
    token: string
    createdAt: Date
    updatedAt: Date
    ipAddress: string | null
    userAgent: string | null
    userId: string
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    expiresAt?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    userId?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "expiresAt" | "token" | "createdAt" | "updatedAt" | "ipAddress" | "userAgent" | "userId", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      expiresAt: Date
      token: string
      createdAt: Date
      updatedAt: Date
      ipAddress: string | null
      userAgent: string | null
      userId: string
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly expiresAt: FieldRef<"Session", 'DateTime'>
    readonly token: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly updatedAt: FieldRef<"Session", 'DateTime'>
    readonly ipAddress: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    providerId: string | null
    userId: string | null
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    accountId: number
    providerId: number
    userId: number
    accessToken: number
    refreshToken: number
    idToken: number
    accessTokenExpiresAt: number
    refreshTokenExpiresAt: number
    scope: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    accountId?: true
    providerId?: true
    userId?: true
    accessToken?: true
    refreshToken?: true
    idToken?: true
    accessTokenExpiresAt?: true
    refreshTokenExpiresAt?: true
    scope?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken: string | null
    refreshToken: string | null
    idToken: string | null
    accessTokenExpiresAt: Date | null
    refreshTokenExpiresAt: Date | null
    scope: string | null
    password: string | null
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    accountId?: boolean
    providerId?: boolean
    userId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    idToken?: boolean
    accessTokenExpiresAt?: boolean
    refreshTokenExpiresAt?: boolean
    scope?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "providerId" | "userId" | "accessToken" | "refreshToken" | "idToken" | "accessTokenExpiresAt" | "refreshTokenExpiresAt" | "scope" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      providerId: string
      userId: string
      accessToken: string | null
      refreshToken: string | null
      idToken: string | null
      accessTokenExpiresAt: Date | null
      refreshTokenExpiresAt: Date | null
      scope: string | null
      password: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly accountId: FieldRef<"Account", 'String'>
    readonly providerId: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly accessToken: FieldRef<"Account", 'String'>
    readonly refreshToken: FieldRef<"Account", 'String'>
    readonly idToken: FieldRef<"Account", 'String'>
    readonly accessTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly refreshTokenExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Verification
   */

  export type AggregateVerification = {
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  export type VerificationMinAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationMaxAggregateOutputType = {
    id: string | null
    identifier: string | null
    value: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VerificationCountAggregateOutputType = {
    id: number
    identifier: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VerificationMinAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationMaxAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VerificationCountAggregateInputType = {
    id?: true
    identifier?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verification to aggregate.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Verifications
    **/
    _count?: true | VerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationMaxAggregateInputType
  }

  export type GetVerificationAggregateType<T extends VerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerification[P]>
      : GetScalarType<T[P], AggregateVerification[P]>
  }




  export type VerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationWhereInput
    orderBy?: VerificationOrderByWithAggregationInput | VerificationOrderByWithAggregationInput[]
    by: VerificationScalarFieldEnum[] | VerificationScalarFieldEnum
    having?: VerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationCountAggregateInputType | true
    _min?: VerificationMinAggregateInputType
    _max?: VerificationMaxAggregateInputType
  }

  export type VerificationGroupByOutputType = {
    id: string
    identifier: string
    value: string
    expiresAt: Date
    createdAt: Date | null
    updatedAt: Date | null
    _count: VerificationCountAggregateOutputType | null
    _min: VerificationMinAggregateOutputType | null
    _max: VerificationMaxAggregateOutputType | null
  }

  type GetVerificationGroupByPayload<T extends VerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationGroupByOutputType[P]>
        }
      >
    >


  export type VerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["verification"]>

  export type VerificationSelectScalar = {
    id?: boolean
    identifier?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "identifier" | "value" | "expiresAt" | "createdAt" | "updatedAt", ExtArgs["result"]["verification"]>

  export type $VerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Verification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      identifier: string
      value: string
      expiresAt: Date
      createdAt: Date | null
      updatedAt: Date | null
    }, ExtArgs["result"]["verification"]>
    composites: {}
  }

  type VerificationGetPayload<S extends boolean | null | undefined | VerificationDefaultArgs> = $Result.GetResult<Prisma.$VerificationPayload, S>

  type VerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationCountAggregateInputType | true
    }

  export interface VerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Verification'], meta: { name: 'Verification' } }
    /**
     * Find zero or one Verification that matches the filter.
     * @param {VerificationFindUniqueArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationFindUniqueArgs>(args: SelectSubset<T, VerificationFindUniqueArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Verification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationFindUniqueOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationFindFirstArgs>(args?: SelectSubset<T, VerificationFindFirstArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Verification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindFirstOrThrowArgs} args - Arguments to find a Verification
     * @example
     * // Get one Verification
     * const verification = await prisma.verification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Verifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Verifications
     * const verifications = await prisma.verification.findMany()
     * 
     * // Get first 10 Verifications
     * const verifications = await prisma.verification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationWithIdOnly = await prisma.verification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationFindManyArgs>(args?: SelectSubset<T, VerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Verification.
     * @param {VerificationCreateArgs} args - Arguments to create a Verification.
     * @example
     * // Create one Verification
     * const Verification = await prisma.verification.create({
     *   data: {
     *     // ... data to create a Verification
     *   }
     * })
     * 
     */
    create<T extends VerificationCreateArgs>(args: SelectSubset<T, VerificationCreateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Verifications.
     * @param {VerificationCreateManyArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationCreateManyArgs>(args?: SelectSubset<T, VerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Verifications and returns the data saved in the database.
     * @param {VerificationCreateManyAndReturnArgs} args - Arguments to create many Verifications.
     * @example
     * // Create many Verifications
     * const verification = await prisma.verification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Verification.
     * @param {VerificationDeleteArgs} args - Arguments to delete one Verification.
     * @example
     * // Delete one Verification
     * const Verification = await prisma.verification.delete({
     *   where: {
     *     // ... filter to delete one Verification
     *   }
     * })
     * 
     */
    delete<T extends VerificationDeleteArgs>(args: SelectSubset<T, VerificationDeleteArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Verification.
     * @param {VerificationUpdateArgs} args - Arguments to update one Verification.
     * @example
     * // Update one Verification
     * const verification = await prisma.verification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationUpdateArgs>(args: SelectSubset<T, VerificationUpdateArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Verifications.
     * @param {VerificationDeleteManyArgs} args - Arguments to filter Verifications to delete.
     * @example
     * // Delete a few Verifications
     * const { count } = await prisma.verification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationDeleteManyArgs>(args?: SelectSubset<T, VerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationUpdateManyArgs>(args: SelectSubset<T, VerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Verifications and returns the data updated in the database.
     * @param {VerificationUpdateManyAndReturnArgs} args - Arguments to update many Verifications.
     * @example
     * // Update many Verifications
     * const verification = await prisma.verification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Verifications and only return the `id`
     * const verificationWithIdOnly = await prisma.verification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Verification.
     * @param {VerificationUpsertArgs} args - Arguments to update or create a Verification.
     * @example
     * // Update or create a Verification
     * const verification = await prisma.verification.upsert({
     *   create: {
     *     // ... data to create a Verification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Verification we want to update
     *   }
     * })
     */
    upsert<T extends VerificationUpsertArgs>(args: SelectSubset<T, VerificationUpsertArgs<ExtArgs>>): Prisma__VerificationClient<$Result.GetResult<Prisma.$VerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Verifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationCountArgs} args - Arguments to filter Verifications to count.
     * @example
     * // Count the number of Verifications
     * const count = await prisma.verification.count({
     *   where: {
     *     // ... the filter for the Verifications we want to count
     *   }
     * })
    **/
    count<T extends VerificationCountArgs>(
      args?: Subset<T, VerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationAggregateArgs>(args: Subset<T, VerificationAggregateArgs>): Prisma.PrismaPromise<GetVerificationAggregateType<T>>

    /**
     * Group by Verification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationGroupByArgs['orderBy'] }
        : { orderBy?: VerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Verification model
   */
  readonly fields: VerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Verification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Verification model
   */
  interface VerificationFieldRefs {
    readonly id: FieldRef<"Verification", 'String'>
    readonly identifier: FieldRef<"Verification", 'String'>
    readonly value: FieldRef<"Verification", 'String'>
    readonly expiresAt: FieldRef<"Verification", 'DateTime'>
    readonly createdAt: FieldRef<"Verification", 'DateTime'>
    readonly updatedAt: FieldRef<"Verification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Verification findUnique
   */
  export type VerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findUniqueOrThrow
   */
  export type VerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification findFirst
   */
  export type VerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findFirstOrThrow
   */
  export type VerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verification to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Verifications.
     */
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification findMany
   */
  export type VerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter, which Verifications to fetch.
     */
    where?: VerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Verifications to fetch.
     */
    orderBy?: VerificationOrderByWithRelationInput | VerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Verifications.
     */
    cursor?: VerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Verifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Verifications.
     */
    skip?: number
    distinct?: VerificationScalarFieldEnum | VerificationScalarFieldEnum[]
  }

  /**
   * Verification create
   */
  export type VerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to create a Verification.
     */
    data: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
  }

  /**
   * Verification createMany
   */
  export type VerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification createManyAndReturn
   */
  export type VerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to create many Verifications.
     */
    data: VerificationCreateManyInput | VerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Verification update
   */
  export type VerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data needed to update a Verification.
     */
    data: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
    /**
     * Choose, which Verification to update.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification updateMany
   */
  export type VerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification updateManyAndReturn
   */
  export type VerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The data used to update Verifications.
     */
    data: XOR<VerificationUpdateManyMutationInput, VerificationUncheckedUpdateManyInput>
    /**
     * Filter which Verifications to update
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to update.
     */
    limit?: number
  }

  /**
   * Verification upsert
   */
  export type VerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * The filter to search for the Verification to update in case it exists.
     */
    where: VerificationWhereUniqueInput
    /**
     * In case the Verification found by the `where` argument doesn't exist, create a new Verification with this data.
     */
    create: XOR<VerificationCreateInput, VerificationUncheckedCreateInput>
    /**
     * In case the Verification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationUpdateInput, VerificationUncheckedUpdateInput>
  }

  /**
   * Verification delete
   */
  export type VerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
    /**
     * Filter which Verification to delete.
     */
    where: VerificationWhereUniqueInput
  }

  /**
   * Verification deleteMany
   */
  export type VerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Verifications to delete
     */
    where?: VerificationWhereInput
    /**
     * Limit how many Verifications to delete.
     */
    limit?: number
  }

  /**
   * Verification without action
   */
  export type VerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Verification
     */
    select?: VerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Verification
     */
    omit?: VerificationOmit<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    color: string | null
    emoji: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    name: string | null
    color: string | null
    emoji: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    ownerId: number
    name: number
    color: number
    emoji: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    color?: true
    emoji?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    color?: true
    emoji?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    ownerId?: true
    name?: true
    color?: true
    emoji?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    ownerId: string
    name: string
    color: string | null
    emoji: string | null
    createdAt: Date
    updatedAt: Date
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    color?: boolean
    emoji?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lectures?: boolean | Folder$lecturesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    color?: boolean
    emoji?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    name?: boolean
    color?: boolean
    emoji?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    ownerId?: boolean
    name?: boolean
    color?: boolean
    emoji?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "name" | "color" | "emoji" | "createdAt" | "updatedAt", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    lectures?: boolean | Folder$lecturesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      lectures: Prisma.$LecturePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      name: string
      color: string | null
      emoji: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lectures<T extends Folder$lecturesArgs<ExtArgs> = {}>(args?: Subset<T, Folder$lecturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly ownerId: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly color: FieldRef<"Folder", 'String'>
    readonly emoji: FieldRef<"Folder", 'String'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.lectures
   */
  export type Folder$lecturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    cursor?: LectureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model Lecture
   */

  export type AggregateLecture = {
    _count: LectureCountAggregateOutputType | null
    _min: LectureMinAggregateOutputType | null
    _max: LectureMaxAggregateOutputType | null
  }

  export type LectureMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    folderId: string | null
    title: string | null
    description: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    folderId: string | null
    title: string | null
    description: string | null
    language: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureCountAggregateOutputType = {
    id: number
    ownerId: number
    folderId: number
    title: number
    description: number
    language: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LectureMinAggregateInputType = {
    id?: true
    ownerId?: true
    folderId?: true
    title?: true
    description?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureMaxAggregateInputType = {
    id?: true
    ownerId?: true
    folderId?: true
    title?: true
    description?: true
    language?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureCountAggregateInputType = {
    id?: true
    ownerId?: true
    folderId?: true
    title?: true
    description?: true
    language?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LectureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lecture to aggregate.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lectures
    **/
    _count?: true | LectureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LectureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LectureMaxAggregateInputType
  }

  export type GetLectureAggregateType<T extends LectureAggregateArgs> = {
        [P in keyof T & keyof AggregateLecture]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLecture[P]>
      : GetScalarType<T[P], AggregateLecture[P]>
  }




  export type LectureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureWhereInput
    orderBy?: LectureOrderByWithAggregationInput | LectureOrderByWithAggregationInput[]
    by: LectureScalarFieldEnum[] | LectureScalarFieldEnum
    having?: LectureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LectureCountAggregateInputType | true
    _min?: LectureMinAggregateInputType
    _max?: LectureMaxAggregateInputType
  }

  export type LectureGroupByOutputType = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description: string | null
    language: string | null
    createdAt: Date
    updatedAt: Date
    _count: LectureCountAggregateOutputType | null
    _min: LectureMinAggregateOutputType | null
    _max: LectureMaxAggregateOutputType | null
  }

  type GetLectureGroupByPayload<T extends LectureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LectureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LectureGroupByOutputType[P]>
            : GetScalarType<T[P], LectureGroupByOutputType[P]>
        }
      >
    >


  export type LectureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    folderId?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    sources?: boolean | Lecture$sourcesArgs<ExtArgs>
    artifacts?: boolean | Lecture$artifactsArgs<ExtArgs>
    assistant?: boolean | Lecture$assistantArgs<ExtArgs>
    bookmarks?: boolean | Lecture$bookmarksArgs<ExtArgs>
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecture"]>

  export type LectureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    folderId?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecture"]>

  export type LectureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    folderId?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lecture"]>

  export type LectureSelectScalar = {
    id?: boolean
    ownerId?: boolean
    folderId?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LectureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ownerId" | "folderId" | "title" | "description" | "language" | "createdAt" | "updatedAt", ExtArgs["result"]["lecture"]>
  export type LectureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    sources?: boolean | Lecture$sourcesArgs<ExtArgs>
    artifacts?: boolean | Lecture$artifactsArgs<ExtArgs>
    assistant?: boolean | Lecture$assistantArgs<ExtArgs>
    bookmarks?: boolean | Lecture$bookmarksArgs<ExtArgs>
    _count?: boolean | LectureCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LectureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
  }
  export type LectureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | FolderDefaultArgs<ExtArgs>
  }

  export type $LecturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lecture"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs>
      sources: Prisma.$LectureSourcePayload<ExtArgs>[]
      artifacts: Prisma.$ContentArtifactPayload<ExtArgs>[]
      assistant: Prisma.$LectureAssistantPayload<ExtArgs> | null
      bookmarks: Prisma.$BookmarkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      folderId: string
      title: string
      description: string | null
      language: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lecture"]>
    composites: {}
  }

  type LectureGetPayload<S extends boolean | null | undefined | LectureDefaultArgs> = $Result.GetResult<Prisma.$LecturePayload, S>

  type LectureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LectureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LectureCountAggregateInputType | true
    }

  export interface LectureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lecture'], meta: { name: 'Lecture' } }
    /**
     * Find zero or one Lecture that matches the filter.
     * @param {LectureFindUniqueArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureFindUniqueArgs>(args: SelectSubset<T, LectureFindUniqueArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lecture that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureFindUniqueOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureFindUniqueOrThrowArgs>(args: SelectSubset<T, LectureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecture that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureFindFirstArgs>(args?: SelectSubset<T, LectureFindFirstArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lecture that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindFirstOrThrowArgs} args - Arguments to find a Lecture
     * @example
     * // Get one Lecture
     * const lecture = await prisma.lecture.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureFindFirstOrThrowArgs>(args?: SelectSubset<T, LectureFindFirstOrThrowArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lectures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lectures
     * const lectures = await prisma.lecture.findMany()
     * 
     * // Get first 10 Lectures
     * const lectures = await prisma.lecture.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureWithIdOnly = await prisma.lecture.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LectureFindManyArgs>(args?: SelectSubset<T, LectureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lecture.
     * @param {LectureCreateArgs} args - Arguments to create a Lecture.
     * @example
     * // Create one Lecture
     * const Lecture = await prisma.lecture.create({
     *   data: {
     *     // ... data to create a Lecture
     *   }
     * })
     * 
     */
    create<T extends LectureCreateArgs>(args: SelectSubset<T, LectureCreateArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lectures.
     * @param {LectureCreateManyArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LectureCreateManyArgs>(args?: SelectSubset<T, LectureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lectures and returns the data saved in the database.
     * @param {LectureCreateManyAndReturnArgs} args - Arguments to create many Lectures.
     * @example
     * // Create many Lectures
     * const lecture = await prisma.lecture.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lectures and only return the `id`
     * const lectureWithIdOnly = await prisma.lecture.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LectureCreateManyAndReturnArgs>(args?: SelectSubset<T, LectureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lecture.
     * @param {LectureDeleteArgs} args - Arguments to delete one Lecture.
     * @example
     * // Delete one Lecture
     * const Lecture = await prisma.lecture.delete({
     *   where: {
     *     // ... filter to delete one Lecture
     *   }
     * })
     * 
     */
    delete<T extends LectureDeleteArgs>(args: SelectSubset<T, LectureDeleteArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lecture.
     * @param {LectureUpdateArgs} args - Arguments to update one Lecture.
     * @example
     * // Update one Lecture
     * const lecture = await prisma.lecture.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LectureUpdateArgs>(args: SelectSubset<T, LectureUpdateArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lectures.
     * @param {LectureDeleteManyArgs} args - Arguments to filter Lectures to delete.
     * @example
     * // Delete a few Lectures
     * const { count } = await prisma.lecture.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LectureDeleteManyArgs>(args?: SelectSubset<T, LectureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LectureUpdateManyArgs>(args: SelectSubset<T, LectureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lectures and returns the data updated in the database.
     * @param {LectureUpdateManyAndReturnArgs} args - Arguments to update many Lectures.
     * @example
     * // Update many Lectures
     * const lecture = await prisma.lecture.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lectures and only return the `id`
     * const lectureWithIdOnly = await prisma.lecture.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LectureUpdateManyAndReturnArgs>(args: SelectSubset<T, LectureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lecture.
     * @param {LectureUpsertArgs} args - Arguments to update or create a Lecture.
     * @example
     * // Update or create a Lecture
     * const lecture = await prisma.lecture.upsert({
     *   create: {
     *     // ... data to create a Lecture
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lecture we want to update
     *   }
     * })
     */
    upsert<T extends LectureUpsertArgs>(args: SelectSubset<T, LectureUpsertArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lectures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureCountArgs} args - Arguments to filter Lectures to count.
     * @example
     * // Count the number of Lectures
     * const count = await prisma.lecture.count({
     *   where: {
     *     // ... the filter for the Lectures we want to count
     *   }
     * })
    **/
    count<T extends LectureCountArgs>(
      args?: Subset<T, LectureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureAggregateArgs>(args: Subset<T, LectureAggregateArgs>): Prisma.PrismaPromise<GetLectureAggregateType<T>>

    /**
     * Group by Lecture.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LectureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureGroupByArgs['orderBy'] }
        : { orderBy?: LectureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LectureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLectureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lecture model
   */
  readonly fields: LectureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lecture.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends FolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FolderDefaultArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sources<T extends Lecture$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    artifacts<T extends Lecture$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assistant<T extends Lecture$assistantArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$assistantArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookmarks<T extends Lecture$bookmarksArgs<ExtArgs> = {}>(args?: Subset<T, Lecture$bookmarksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lecture model
   */
  interface LectureFieldRefs {
    readonly id: FieldRef<"Lecture", 'String'>
    readonly ownerId: FieldRef<"Lecture", 'String'>
    readonly folderId: FieldRef<"Lecture", 'String'>
    readonly title: FieldRef<"Lecture", 'String'>
    readonly description: FieldRef<"Lecture", 'String'>
    readonly language: FieldRef<"Lecture", 'String'>
    readonly createdAt: FieldRef<"Lecture", 'DateTime'>
    readonly updatedAt: FieldRef<"Lecture", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lecture findUnique
   */
  export type LectureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture findUniqueOrThrow
   */
  export type LectureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture findFirst
   */
  export type LectureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture findFirstOrThrow
   */
  export type LectureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lecture to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lectures.
     */
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture findMany
   */
  export type LectureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter, which Lectures to fetch.
     */
    where?: LectureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lectures to fetch.
     */
    orderBy?: LectureOrderByWithRelationInput | LectureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lectures.
     */
    cursor?: LectureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lectures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lectures.
     */
    skip?: number
    distinct?: LectureScalarFieldEnum | LectureScalarFieldEnum[]
  }

  /**
   * Lecture create
   */
  export type LectureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The data needed to create a Lecture.
     */
    data: XOR<LectureCreateInput, LectureUncheckedCreateInput>
  }

  /**
   * Lecture createMany
   */
  export type LectureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lecture createManyAndReturn
   */
  export type LectureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * The data used to create many Lectures.
     */
    data: LectureCreateManyInput | LectureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lecture update
   */
  export type LectureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The data needed to update a Lecture.
     */
    data: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
    /**
     * Choose, which Lecture to update.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture updateMany
   */
  export type LectureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput
    /**
     * Limit how many Lectures to update.
     */
    limit?: number
  }

  /**
   * Lecture updateManyAndReturn
   */
  export type LectureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * The data used to update Lectures.
     */
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyInput>
    /**
     * Filter which Lectures to update
     */
    where?: LectureWhereInput
    /**
     * Limit how many Lectures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lecture upsert
   */
  export type LectureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * The filter to search for the Lecture to update in case it exists.
     */
    where: LectureWhereUniqueInput
    /**
     * In case the Lecture found by the `where` argument doesn't exist, create a new Lecture with this data.
     */
    create: XOR<LectureCreateInput, LectureUncheckedCreateInput>
    /**
     * In case the Lecture was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureUpdateInput, LectureUncheckedUpdateInput>
  }

  /**
   * Lecture delete
   */
  export type LectureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
    /**
     * Filter which Lecture to delete.
     */
    where: LectureWhereUniqueInput
  }

  /**
   * Lecture deleteMany
   */
  export type LectureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lectures to delete
     */
    where?: LectureWhereInput
    /**
     * Limit how many Lectures to delete.
     */
    limit?: number
  }

  /**
   * Lecture.sources
   */
  export type Lecture$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    where?: LectureSourceWhereInput
    orderBy?: LectureSourceOrderByWithRelationInput | LectureSourceOrderByWithRelationInput[]
    cursor?: LectureSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LectureSourceScalarFieldEnum | LectureSourceScalarFieldEnum[]
  }

  /**
   * Lecture.artifacts
   */
  export type Lecture$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    where?: ContentArtifactWhereInput
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    cursor?: ContentArtifactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentArtifactScalarFieldEnum | ContentArtifactScalarFieldEnum[]
  }

  /**
   * Lecture.assistant
   */
  export type Lecture$assistantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    where?: LectureAssistantWhereInput
  }

  /**
   * Lecture.bookmarks
   */
  export type Lecture$bookmarksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    cursor?: BookmarkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Lecture without action
   */
  export type LectureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lecture
     */
    select?: LectureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lecture
     */
    omit?: LectureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureInclude<ExtArgs> | null
  }


  /**
   * Model LectureSource
   */

  export type AggregateLectureSource = {
    _count: LectureSourceCountAggregateOutputType | null
    _avg: LectureSourceAvgAggregateOutputType | null
    _sum: LectureSourceSumAggregateOutputType | null
    _min: LectureSourceMinAggregateOutputType | null
    _max: LectureSourceMaxAggregateOutputType | null
  }

  export type LectureSourceAvgAggregateOutputType = {
    durationSeconds: number | null
    pageCount: number | null
  }

  export type LectureSourceSumAggregateOutputType = {
    durationSeconds: number | null
    pageCount: number | null
  }

  export type LectureSourceMinAggregateOutputType = {
    id: string | null
    lectureId: string | null
    kind: $Enums.SourceType | null
    title: string | null
    url: string | null
    fileKey: string | null
    textContent: string | null
    transcript: string | null
    language: string | null
    durationSeconds: number | null
    pageCount: number | null
    checksum: string | null
    status: $Enums.ProcessingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureSourceMaxAggregateOutputType = {
    id: string | null
    lectureId: string | null
    kind: $Enums.SourceType | null
    title: string | null
    url: string | null
    fileKey: string | null
    textContent: string | null
    transcript: string | null
    language: string | null
    durationSeconds: number | null
    pageCount: number | null
    checksum: string | null
    status: $Enums.ProcessingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureSourceCountAggregateOutputType = {
    id: number
    lectureId: number
    kind: number
    title: number
    url: number
    fileKey: number
    textContent: number
    transcript: number
    language: number
    durationSeconds: number
    pageCount: number
    checksum: number
    status: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LectureSourceAvgAggregateInputType = {
    durationSeconds?: true
    pageCount?: true
  }

  export type LectureSourceSumAggregateInputType = {
    durationSeconds?: true
    pageCount?: true
  }

  export type LectureSourceMinAggregateInputType = {
    id?: true
    lectureId?: true
    kind?: true
    title?: true
    url?: true
    fileKey?: true
    textContent?: true
    transcript?: true
    language?: true
    durationSeconds?: true
    pageCount?: true
    checksum?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureSourceMaxAggregateInputType = {
    id?: true
    lectureId?: true
    kind?: true
    title?: true
    url?: true
    fileKey?: true
    textContent?: true
    transcript?: true
    language?: true
    durationSeconds?: true
    pageCount?: true
    checksum?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureSourceCountAggregateInputType = {
    id?: true
    lectureId?: true
    kind?: true
    title?: true
    url?: true
    fileKey?: true
    textContent?: true
    transcript?: true
    language?: true
    durationSeconds?: true
    pageCount?: true
    checksum?: true
    status?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LectureSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LectureSource to aggregate.
     */
    where?: LectureSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureSources to fetch.
     */
    orderBy?: LectureSourceOrderByWithRelationInput | LectureSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LectureSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LectureSources
    **/
    _count?: true | LectureSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LectureSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LectureSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LectureSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LectureSourceMaxAggregateInputType
  }

  export type GetLectureSourceAggregateType<T extends LectureSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateLectureSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLectureSource[P]>
      : GetScalarType<T[P], AggregateLectureSource[P]>
  }




  export type LectureSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureSourceWhereInput
    orderBy?: LectureSourceOrderByWithAggregationInput | LectureSourceOrderByWithAggregationInput[]
    by: LectureSourceScalarFieldEnum[] | LectureSourceScalarFieldEnum
    having?: LectureSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LectureSourceCountAggregateInputType | true
    _avg?: LectureSourceAvgAggregateInputType
    _sum?: LectureSourceSumAggregateInputType
    _min?: LectureSourceMinAggregateInputType
    _max?: LectureSourceMaxAggregateInputType
  }

  export type LectureSourceGroupByOutputType = {
    id: string
    lectureId: string
    kind: $Enums.SourceType
    title: string | null
    url: string | null
    fileKey: string | null
    textContent: string | null
    transcript: string | null
    language: string | null
    durationSeconds: number | null
    pageCount: number | null
    checksum: string | null
    status: $Enums.ProcessingStatus
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LectureSourceCountAggregateOutputType | null
    _avg: LectureSourceAvgAggregateOutputType | null
    _sum: LectureSourceSumAggregateOutputType | null
    _min: LectureSourceMinAggregateOutputType | null
    _max: LectureSourceMaxAggregateOutputType | null
  }

  type GetLectureSourceGroupByPayload<T extends LectureSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LectureSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LectureSourceGroupByOutputType[P]>
            : GetScalarType<T[P], LectureSourceGroupByOutputType[P]>
        }
      >
    >


  export type LectureSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    kind?: boolean
    title?: boolean
    url?: boolean
    fileKey?: boolean
    textContent?: boolean
    transcript?: boolean
    language?: boolean
    durationSeconds?: boolean
    pageCount?: boolean
    checksum?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    artifacts?: boolean | LectureSource$artifactsArgs<ExtArgs>
    _count?: boolean | LectureSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureSource"]>

  export type LectureSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    kind?: boolean
    title?: boolean
    url?: boolean
    fileKey?: boolean
    textContent?: boolean
    transcript?: boolean
    language?: boolean
    durationSeconds?: boolean
    pageCount?: boolean
    checksum?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureSource"]>

  export type LectureSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    kind?: boolean
    title?: boolean
    url?: boolean
    fileKey?: boolean
    textContent?: boolean
    transcript?: boolean
    language?: boolean
    durationSeconds?: boolean
    pageCount?: boolean
    checksum?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureSource"]>

  export type LectureSourceSelectScalar = {
    id?: boolean
    lectureId?: boolean
    kind?: boolean
    title?: boolean
    url?: boolean
    fileKey?: boolean
    textContent?: boolean
    transcript?: boolean
    language?: boolean
    durationSeconds?: boolean
    pageCount?: boolean
    checksum?: boolean
    status?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LectureSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lectureId" | "kind" | "title" | "url" | "fileKey" | "textContent" | "transcript" | "language" | "durationSeconds" | "pageCount" | "checksum" | "status" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["lectureSource"]>
  export type LectureSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    artifacts?: boolean | LectureSource$artifactsArgs<ExtArgs>
    _count?: boolean | LectureSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LectureSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }
  export type LectureSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }

  export type $LectureSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LectureSource"
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>
      artifacts: Prisma.$ArtifactSourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lectureId: string
      kind: $Enums.SourceType
      title: string | null
      url: string | null
      fileKey: string | null
      textContent: string | null
      transcript: string | null
      language: string | null
      durationSeconds: number | null
      pageCount: number | null
      checksum: string | null
      status: $Enums.ProcessingStatus
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lectureSource"]>
    composites: {}
  }

  type LectureSourceGetPayload<S extends boolean | null | undefined | LectureSourceDefaultArgs> = $Result.GetResult<Prisma.$LectureSourcePayload, S>

  type LectureSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LectureSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LectureSourceCountAggregateInputType | true
    }

  export interface LectureSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LectureSource'], meta: { name: 'LectureSource' } }
    /**
     * Find zero or one LectureSource that matches the filter.
     * @param {LectureSourceFindUniqueArgs} args - Arguments to find a LectureSource
     * @example
     * // Get one LectureSource
     * const lectureSource = await prisma.lectureSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureSourceFindUniqueArgs>(args: SelectSubset<T, LectureSourceFindUniqueArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LectureSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureSourceFindUniqueOrThrowArgs} args - Arguments to find a LectureSource
     * @example
     * // Get one LectureSource
     * const lectureSource = await prisma.lectureSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, LectureSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LectureSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceFindFirstArgs} args - Arguments to find a LectureSource
     * @example
     * // Get one LectureSource
     * const lectureSource = await prisma.lectureSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureSourceFindFirstArgs>(args?: SelectSubset<T, LectureSourceFindFirstArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LectureSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceFindFirstOrThrowArgs} args - Arguments to find a LectureSource
     * @example
     * // Get one LectureSource
     * const lectureSource = await prisma.lectureSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, LectureSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LectureSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LectureSources
     * const lectureSources = await prisma.lectureSource.findMany()
     * 
     * // Get first 10 LectureSources
     * const lectureSources = await prisma.lectureSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureSourceWithIdOnly = await prisma.lectureSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LectureSourceFindManyArgs>(args?: SelectSubset<T, LectureSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LectureSource.
     * @param {LectureSourceCreateArgs} args - Arguments to create a LectureSource.
     * @example
     * // Create one LectureSource
     * const LectureSource = await prisma.lectureSource.create({
     *   data: {
     *     // ... data to create a LectureSource
     *   }
     * })
     * 
     */
    create<T extends LectureSourceCreateArgs>(args: SelectSubset<T, LectureSourceCreateArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LectureSources.
     * @param {LectureSourceCreateManyArgs} args - Arguments to create many LectureSources.
     * @example
     * // Create many LectureSources
     * const lectureSource = await prisma.lectureSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LectureSourceCreateManyArgs>(args?: SelectSubset<T, LectureSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LectureSources and returns the data saved in the database.
     * @param {LectureSourceCreateManyAndReturnArgs} args - Arguments to create many LectureSources.
     * @example
     * // Create many LectureSources
     * const lectureSource = await prisma.lectureSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LectureSources and only return the `id`
     * const lectureSourceWithIdOnly = await prisma.lectureSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LectureSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, LectureSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LectureSource.
     * @param {LectureSourceDeleteArgs} args - Arguments to delete one LectureSource.
     * @example
     * // Delete one LectureSource
     * const LectureSource = await prisma.lectureSource.delete({
     *   where: {
     *     // ... filter to delete one LectureSource
     *   }
     * })
     * 
     */
    delete<T extends LectureSourceDeleteArgs>(args: SelectSubset<T, LectureSourceDeleteArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LectureSource.
     * @param {LectureSourceUpdateArgs} args - Arguments to update one LectureSource.
     * @example
     * // Update one LectureSource
     * const lectureSource = await prisma.lectureSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LectureSourceUpdateArgs>(args: SelectSubset<T, LectureSourceUpdateArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LectureSources.
     * @param {LectureSourceDeleteManyArgs} args - Arguments to filter LectureSources to delete.
     * @example
     * // Delete a few LectureSources
     * const { count } = await prisma.lectureSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LectureSourceDeleteManyArgs>(args?: SelectSubset<T, LectureSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LectureSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LectureSources
     * const lectureSource = await prisma.lectureSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LectureSourceUpdateManyArgs>(args: SelectSubset<T, LectureSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LectureSources and returns the data updated in the database.
     * @param {LectureSourceUpdateManyAndReturnArgs} args - Arguments to update many LectureSources.
     * @example
     * // Update many LectureSources
     * const lectureSource = await prisma.lectureSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LectureSources and only return the `id`
     * const lectureSourceWithIdOnly = await prisma.lectureSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LectureSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, LectureSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LectureSource.
     * @param {LectureSourceUpsertArgs} args - Arguments to update or create a LectureSource.
     * @example
     * // Update or create a LectureSource
     * const lectureSource = await prisma.lectureSource.upsert({
     *   create: {
     *     // ... data to create a LectureSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LectureSource we want to update
     *   }
     * })
     */
    upsert<T extends LectureSourceUpsertArgs>(args: SelectSubset<T, LectureSourceUpsertArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LectureSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceCountArgs} args - Arguments to filter LectureSources to count.
     * @example
     * // Count the number of LectureSources
     * const count = await prisma.lectureSource.count({
     *   where: {
     *     // ... the filter for the LectureSources we want to count
     *   }
     * })
    **/
    count<T extends LectureSourceCountArgs>(
      args?: Subset<T, LectureSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LectureSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureSourceAggregateArgs>(args: Subset<T, LectureSourceAggregateArgs>): Prisma.PrismaPromise<GetLectureSourceAggregateType<T>>

    /**
     * Group by LectureSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LectureSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureSourceGroupByArgs['orderBy'] }
        : { orderBy?: LectureSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LectureSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLectureSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LectureSource model
   */
  readonly fields: LectureSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LectureSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artifacts<T extends LectureSource$artifactsArgs<ExtArgs> = {}>(args?: Subset<T, LectureSource$artifactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LectureSource model
   */
  interface LectureSourceFieldRefs {
    readonly id: FieldRef<"LectureSource", 'String'>
    readonly lectureId: FieldRef<"LectureSource", 'String'>
    readonly kind: FieldRef<"LectureSource", 'SourceType'>
    readonly title: FieldRef<"LectureSource", 'String'>
    readonly url: FieldRef<"LectureSource", 'String'>
    readonly fileKey: FieldRef<"LectureSource", 'String'>
    readonly textContent: FieldRef<"LectureSource", 'String'>
    readonly transcript: FieldRef<"LectureSource", 'String'>
    readonly language: FieldRef<"LectureSource", 'String'>
    readonly durationSeconds: FieldRef<"LectureSource", 'Int'>
    readonly pageCount: FieldRef<"LectureSource", 'Int'>
    readonly checksum: FieldRef<"LectureSource", 'String'>
    readonly status: FieldRef<"LectureSource", 'ProcessingStatus'>
    readonly metadata: FieldRef<"LectureSource", 'Json'>
    readonly createdAt: FieldRef<"LectureSource", 'DateTime'>
    readonly updatedAt: FieldRef<"LectureSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LectureSource findUnique
   */
  export type LectureSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter, which LectureSource to fetch.
     */
    where: LectureSourceWhereUniqueInput
  }

  /**
   * LectureSource findUniqueOrThrow
   */
  export type LectureSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter, which LectureSource to fetch.
     */
    where: LectureSourceWhereUniqueInput
  }

  /**
   * LectureSource findFirst
   */
  export type LectureSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter, which LectureSource to fetch.
     */
    where?: LectureSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureSources to fetch.
     */
    orderBy?: LectureSourceOrderByWithRelationInput | LectureSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LectureSources.
     */
    cursor?: LectureSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LectureSources.
     */
    distinct?: LectureSourceScalarFieldEnum | LectureSourceScalarFieldEnum[]
  }

  /**
   * LectureSource findFirstOrThrow
   */
  export type LectureSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter, which LectureSource to fetch.
     */
    where?: LectureSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureSources to fetch.
     */
    orderBy?: LectureSourceOrderByWithRelationInput | LectureSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LectureSources.
     */
    cursor?: LectureSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LectureSources.
     */
    distinct?: LectureSourceScalarFieldEnum | LectureSourceScalarFieldEnum[]
  }

  /**
   * LectureSource findMany
   */
  export type LectureSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter, which LectureSources to fetch.
     */
    where?: LectureSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureSources to fetch.
     */
    orderBy?: LectureSourceOrderByWithRelationInput | LectureSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LectureSources.
     */
    cursor?: LectureSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureSources.
     */
    skip?: number
    distinct?: LectureSourceScalarFieldEnum | LectureSourceScalarFieldEnum[]
  }

  /**
   * LectureSource create
   */
  export type LectureSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a LectureSource.
     */
    data: XOR<LectureSourceCreateInput, LectureSourceUncheckedCreateInput>
  }

  /**
   * LectureSource createMany
   */
  export type LectureSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LectureSources.
     */
    data: LectureSourceCreateManyInput | LectureSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LectureSource createManyAndReturn
   */
  export type LectureSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * The data used to create many LectureSources.
     */
    data: LectureSourceCreateManyInput | LectureSourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LectureSource update
   */
  export type LectureSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a LectureSource.
     */
    data: XOR<LectureSourceUpdateInput, LectureSourceUncheckedUpdateInput>
    /**
     * Choose, which LectureSource to update.
     */
    where: LectureSourceWhereUniqueInput
  }

  /**
   * LectureSource updateMany
   */
  export type LectureSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LectureSources.
     */
    data: XOR<LectureSourceUpdateManyMutationInput, LectureSourceUncheckedUpdateManyInput>
    /**
     * Filter which LectureSources to update
     */
    where?: LectureSourceWhereInput
    /**
     * Limit how many LectureSources to update.
     */
    limit?: number
  }

  /**
   * LectureSource updateManyAndReturn
   */
  export type LectureSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * The data used to update LectureSources.
     */
    data: XOR<LectureSourceUpdateManyMutationInput, LectureSourceUncheckedUpdateManyInput>
    /**
     * Filter which LectureSources to update
     */
    where?: LectureSourceWhereInput
    /**
     * Limit how many LectureSources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LectureSource upsert
   */
  export type LectureSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the LectureSource to update in case it exists.
     */
    where: LectureSourceWhereUniqueInput
    /**
     * In case the LectureSource found by the `where` argument doesn't exist, create a new LectureSource with this data.
     */
    create: XOR<LectureSourceCreateInput, LectureSourceUncheckedCreateInput>
    /**
     * In case the LectureSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureSourceUpdateInput, LectureSourceUncheckedUpdateInput>
  }

  /**
   * LectureSource delete
   */
  export type LectureSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
    /**
     * Filter which LectureSource to delete.
     */
    where: LectureSourceWhereUniqueInput
  }

  /**
   * LectureSource deleteMany
   */
  export type LectureSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LectureSources to delete
     */
    where?: LectureSourceWhereInput
    /**
     * Limit how many LectureSources to delete.
     */
    limit?: number
  }

  /**
   * LectureSource.artifacts
   */
  export type LectureSource$artifactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    where?: ArtifactSourceWhereInput
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    cursor?: ArtifactSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactSourceScalarFieldEnum | ArtifactSourceScalarFieldEnum[]
  }

  /**
   * LectureSource without action
   */
  export type LectureSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureSource
     */
    select?: LectureSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureSource
     */
    omit?: LectureSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureSourceInclude<ExtArgs> | null
  }


  /**
   * Model ContentArtifact
   */

  export type AggregateContentArtifact = {
    _count: ContentArtifactCountAggregateOutputType | null
    _avg: ContentArtifactAvgAggregateOutputType | null
    _sum: ContentArtifactSumAggregateOutputType | null
    _min: ContentArtifactMinAggregateOutputType | null
    _max: ContentArtifactMaxAggregateOutputType | null
  }

  export type ContentArtifactAvgAggregateOutputType = {
    durationSeconds: number | null
  }

  export type ContentArtifactSumAggregateOutputType = {
    durationSeconds: number | null
  }

  export type ContentArtifactMinAggregateOutputType = {
    id: string | null
    lectureId: string | null
    ownerId: string | null
    type: $Enums.ArtifactType | null
    title: string | null
    description: string | null
    language: string | null
    status: $Enums.ProcessingStatus | null
    coverImageUrl: string | null
    fileUrl: string | null
    transcript: string | null
    durationSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentArtifactMaxAggregateOutputType = {
    id: string | null
    lectureId: string | null
    ownerId: string | null
    type: $Enums.ArtifactType | null
    title: string | null
    description: string | null
    language: string | null
    status: $Enums.ProcessingStatus | null
    coverImageUrl: string | null
    fileUrl: string | null
    transcript: string | null
    durationSeconds: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentArtifactCountAggregateOutputType = {
    id: number
    lectureId: number
    ownerId: number
    type: number
    title: number
    description: number
    language: number
    status: number
    coverImageUrl: number
    fileUrl: number
    transcript: number
    durationSeconds: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentArtifactAvgAggregateInputType = {
    durationSeconds?: true
  }

  export type ContentArtifactSumAggregateInputType = {
    durationSeconds?: true
  }

  export type ContentArtifactMinAggregateInputType = {
    id?: true
    lectureId?: true
    ownerId?: true
    type?: true
    title?: true
    description?: true
    language?: true
    status?: true
    coverImageUrl?: true
    fileUrl?: true
    transcript?: true
    durationSeconds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentArtifactMaxAggregateInputType = {
    id?: true
    lectureId?: true
    ownerId?: true
    type?: true
    title?: true
    description?: true
    language?: true
    status?: true
    coverImageUrl?: true
    fileUrl?: true
    transcript?: true
    durationSeconds?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentArtifactCountAggregateInputType = {
    id?: true
    lectureId?: true
    ownerId?: true
    type?: true
    title?: true
    description?: true
    language?: true
    status?: true
    coverImageUrl?: true
    fileUrl?: true
    transcript?: true
    durationSeconds?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentArtifactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentArtifact to aggregate.
     */
    where?: ContentArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentArtifacts to fetch.
     */
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentArtifacts
    **/
    _count?: true | ContentArtifactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentArtifactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentArtifactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentArtifactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentArtifactMaxAggregateInputType
  }

  export type GetContentArtifactAggregateType<T extends ContentArtifactAggregateArgs> = {
        [P in keyof T & keyof AggregateContentArtifact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentArtifact[P]>
      : GetScalarType<T[P], AggregateContentArtifact[P]>
  }




  export type ContentArtifactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentArtifactWhereInput
    orderBy?: ContentArtifactOrderByWithAggregationInput | ContentArtifactOrderByWithAggregationInput[]
    by: ContentArtifactScalarFieldEnum[] | ContentArtifactScalarFieldEnum
    having?: ContentArtifactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentArtifactCountAggregateInputType | true
    _avg?: ContentArtifactAvgAggregateInputType
    _sum?: ContentArtifactSumAggregateInputType
    _min?: ContentArtifactMinAggregateInputType
    _max?: ContentArtifactMaxAggregateInputType
  }

  export type ContentArtifactGroupByOutputType = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description: string | null
    language: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl: string | null
    fileUrl: string | null
    transcript: string | null
    durationSeconds: number | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContentArtifactCountAggregateOutputType | null
    _avg: ContentArtifactAvgAggregateOutputType | null
    _sum: ContentArtifactSumAggregateOutputType | null
    _min: ContentArtifactMinAggregateOutputType | null
    _max: ContentArtifactMaxAggregateOutputType | null
  }

  type GetContentArtifactGroupByPayload<T extends ContentArtifactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentArtifactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentArtifactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentArtifactGroupByOutputType[P]>
            : GetScalarType<T[P], ContentArtifactGroupByOutputType[P]>
        }
      >
    >


  export type ContentArtifactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    ownerId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    status?: boolean
    coverImageUrl?: boolean
    fileUrl?: boolean
    transcript?: boolean
    durationSeconds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    qaPairs?: boolean | ContentArtifact$qaPairsArgs<ExtArgs>
    flashcards?: boolean | ContentArtifact$flashcardsArgs<ExtArgs>
    shares?: boolean | ContentArtifact$sharesArgs<ExtArgs>
    sources?: boolean | ContentArtifact$sourcesArgs<ExtArgs>
    _count?: boolean | ContentArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentArtifact"]>

  export type ContentArtifactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    ownerId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    status?: boolean
    coverImageUrl?: boolean
    fileUrl?: boolean
    transcript?: boolean
    durationSeconds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentArtifact"]>

  export type ContentArtifactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    ownerId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    status?: boolean
    coverImageUrl?: boolean
    fileUrl?: boolean
    transcript?: boolean
    durationSeconds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentArtifact"]>

  export type ContentArtifactSelectScalar = {
    id?: boolean
    lectureId?: boolean
    ownerId?: boolean
    type?: boolean
    title?: boolean
    description?: boolean
    language?: boolean
    status?: boolean
    coverImageUrl?: boolean
    fileUrl?: boolean
    transcript?: boolean
    durationSeconds?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentArtifactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lectureId" | "ownerId" | "type" | "title" | "description" | "language" | "status" | "coverImageUrl" | "fileUrl" | "transcript" | "durationSeconds" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["contentArtifact"]>
  export type ContentArtifactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    qaPairs?: boolean | ContentArtifact$qaPairsArgs<ExtArgs>
    flashcards?: boolean | ContentArtifact$flashcardsArgs<ExtArgs>
    shares?: boolean | ContentArtifact$sharesArgs<ExtArgs>
    sources?: boolean | ContentArtifact$sourcesArgs<ExtArgs>
    _count?: boolean | ContentArtifactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentArtifactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ContentArtifactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ContentArtifactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentArtifact"
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      qaPairs: Prisma.$QAPairPayload<ExtArgs>[]
      flashcards: Prisma.$FlashcardPayload<ExtArgs>[]
      shares: Prisma.$RoomSharePayload<ExtArgs>[]
      sources: Prisma.$ArtifactSourcePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lectureId: string
      ownerId: string
      type: $Enums.ArtifactType
      title: string
      description: string | null
      language: string | null
      status: $Enums.ProcessingStatus
      coverImageUrl: string | null
      fileUrl: string | null
      transcript: string | null
      durationSeconds: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contentArtifact"]>
    composites: {}
  }

  type ContentArtifactGetPayload<S extends boolean | null | undefined | ContentArtifactDefaultArgs> = $Result.GetResult<Prisma.$ContentArtifactPayload, S>

  type ContentArtifactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentArtifactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentArtifactCountAggregateInputType | true
    }

  export interface ContentArtifactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentArtifact'], meta: { name: 'ContentArtifact' } }
    /**
     * Find zero or one ContentArtifact that matches the filter.
     * @param {ContentArtifactFindUniqueArgs} args - Arguments to find a ContentArtifact
     * @example
     * // Get one ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentArtifactFindUniqueArgs>(args: SelectSubset<T, ContentArtifactFindUniqueArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentArtifact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentArtifactFindUniqueOrThrowArgs} args - Arguments to find a ContentArtifact
     * @example
     * // Get one ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentArtifactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentArtifactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentArtifact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactFindFirstArgs} args - Arguments to find a ContentArtifact
     * @example
     * // Get one ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentArtifactFindFirstArgs>(args?: SelectSubset<T, ContentArtifactFindFirstArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentArtifact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactFindFirstOrThrowArgs} args - Arguments to find a ContentArtifact
     * @example
     * // Get one ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentArtifactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentArtifactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentArtifacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentArtifacts
     * const contentArtifacts = await prisma.contentArtifact.findMany()
     * 
     * // Get first 10 ContentArtifacts
     * const contentArtifacts = await prisma.contentArtifact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentArtifactWithIdOnly = await prisma.contentArtifact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentArtifactFindManyArgs>(args?: SelectSubset<T, ContentArtifactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentArtifact.
     * @param {ContentArtifactCreateArgs} args - Arguments to create a ContentArtifact.
     * @example
     * // Create one ContentArtifact
     * const ContentArtifact = await prisma.contentArtifact.create({
     *   data: {
     *     // ... data to create a ContentArtifact
     *   }
     * })
     * 
     */
    create<T extends ContentArtifactCreateArgs>(args: SelectSubset<T, ContentArtifactCreateArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentArtifacts.
     * @param {ContentArtifactCreateManyArgs} args - Arguments to create many ContentArtifacts.
     * @example
     * // Create many ContentArtifacts
     * const contentArtifact = await prisma.contentArtifact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentArtifactCreateManyArgs>(args?: SelectSubset<T, ContentArtifactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentArtifacts and returns the data saved in the database.
     * @param {ContentArtifactCreateManyAndReturnArgs} args - Arguments to create many ContentArtifacts.
     * @example
     * // Create many ContentArtifacts
     * const contentArtifact = await prisma.contentArtifact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentArtifacts and only return the `id`
     * const contentArtifactWithIdOnly = await prisma.contentArtifact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentArtifactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentArtifactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentArtifact.
     * @param {ContentArtifactDeleteArgs} args - Arguments to delete one ContentArtifact.
     * @example
     * // Delete one ContentArtifact
     * const ContentArtifact = await prisma.contentArtifact.delete({
     *   where: {
     *     // ... filter to delete one ContentArtifact
     *   }
     * })
     * 
     */
    delete<T extends ContentArtifactDeleteArgs>(args: SelectSubset<T, ContentArtifactDeleteArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentArtifact.
     * @param {ContentArtifactUpdateArgs} args - Arguments to update one ContentArtifact.
     * @example
     * // Update one ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentArtifactUpdateArgs>(args: SelectSubset<T, ContentArtifactUpdateArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentArtifacts.
     * @param {ContentArtifactDeleteManyArgs} args - Arguments to filter ContentArtifacts to delete.
     * @example
     * // Delete a few ContentArtifacts
     * const { count } = await prisma.contentArtifact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentArtifactDeleteManyArgs>(args?: SelectSubset<T, ContentArtifactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentArtifacts
     * const contentArtifact = await prisma.contentArtifact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentArtifactUpdateManyArgs>(args: SelectSubset<T, ContentArtifactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentArtifacts and returns the data updated in the database.
     * @param {ContentArtifactUpdateManyAndReturnArgs} args - Arguments to update many ContentArtifacts.
     * @example
     * // Update many ContentArtifacts
     * const contentArtifact = await prisma.contentArtifact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentArtifacts and only return the `id`
     * const contentArtifactWithIdOnly = await prisma.contentArtifact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentArtifactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentArtifactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentArtifact.
     * @param {ContentArtifactUpsertArgs} args - Arguments to update or create a ContentArtifact.
     * @example
     * // Update or create a ContentArtifact
     * const contentArtifact = await prisma.contentArtifact.upsert({
     *   create: {
     *     // ... data to create a ContentArtifact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentArtifact we want to update
     *   }
     * })
     */
    upsert<T extends ContentArtifactUpsertArgs>(args: SelectSubset<T, ContentArtifactUpsertArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentArtifacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactCountArgs} args - Arguments to filter ContentArtifacts to count.
     * @example
     * // Count the number of ContentArtifacts
     * const count = await prisma.contentArtifact.count({
     *   where: {
     *     // ... the filter for the ContentArtifacts we want to count
     *   }
     * })
    **/
    count<T extends ContentArtifactCountArgs>(
      args?: Subset<T, ContentArtifactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentArtifactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentArtifactAggregateArgs>(args: Subset<T, ContentArtifactAggregateArgs>): Prisma.PrismaPromise<GetContentArtifactAggregateType<T>>

    /**
     * Group by ContentArtifact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentArtifactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentArtifactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentArtifactGroupByArgs['orderBy'] }
        : { orderBy?: ContentArtifactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentArtifactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentArtifactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentArtifact model
   */
  readonly fields: ContentArtifactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentArtifact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentArtifactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    qaPairs<T extends ContentArtifact$qaPairsArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifact$qaPairsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    flashcards<T extends ContentArtifact$flashcardsArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifact$flashcardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shares<T extends ContentArtifact$sharesArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifact$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sources<T extends ContentArtifact$sourcesArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifact$sourcesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentArtifact model
   */
  interface ContentArtifactFieldRefs {
    readonly id: FieldRef<"ContentArtifact", 'String'>
    readonly lectureId: FieldRef<"ContentArtifact", 'String'>
    readonly ownerId: FieldRef<"ContentArtifact", 'String'>
    readonly type: FieldRef<"ContentArtifact", 'ArtifactType'>
    readonly title: FieldRef<"ContentArtifact", 'String'>
    readonly description: FieldRef<"ContentArtifact", 'String'>
    readonly language: FieldRef<"ContentArtifact", 'String'>
    readonly status: FieldRef<"ContentArtifact", 'ProcessingStatus'>
    readonly coverImageUrl: FieldRef<"ContentArtifact", 'String'>
    readonly fileUrl: FieldRef<"ContentArtifact", 'String'>
    readonly transcript: FieldRef<"ContentArtifact", 'String'>
    readonly durationSeconds: FieldRef<"ContentArtifact", 'Int'>
    readonly metadata: FieldRef<"ContentArtifact", 'Json'>
    readonly createdAt: FieldRef<"ContentArtifact", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentArtifact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContentArtifact findUnique
   */
  export type ContentArtifactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ContentArtifact to fetch.
     */
    where: ContentArtifactWhereUniqueInput
  }

  /**
   * ContentArtifact findUniqueOrThrow
   */
  export type ContentArtifactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ContentArtifact to fetch.
     */
    where: ContentArtifactWhereUniqueInput
  }

  /**
   * ContentArtifact findFirst
   */
  export type ContentArtifactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ContentArtifact to fetch.
     */
    where?: ContentArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentArtifacts to fetch.
     */
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentArtifacts.
     */
    cursor?: ContentArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentArtifacts.
     */
    distinct?: ContentArtifactScalarFieldEnum | ContentArtifactScalarFieldEnum[]
  }

  /**
   * ContentArtifact findFirstOrThrow
   */
  export type ContentArtifactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ContentArtifact to fetch.
     */
    where?: ContentArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentArtifacts to fetch.
     */
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentArtifacts.
     */
    cursor?: ContentArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentArtifacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentArtifacts.
     */
    distinct?: ContentArtifactScalarFieldEnum | ContentArtifactScalarFieldEnum[]
  }

  /**
   * ContentArtifact findMany
   */
  export type ContentArtifactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter, which ContentArtifacts to fetch.
     */
    where?: ContentArtifactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentArtifacts to fetch.
     */
    orderBy?: ContentArtifactOrderByWithRelationInput | ContentArtifactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentArtifacts.
     */
    cursor?: ContentArtifactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentArtifacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentArtifacts.
     */
    skip?: number
    distinct?: ContentArtifactScalarFieldEnum | ContentArtifactScalarFieldEnum[]
  }

  /**
   * ContentArtifact create
   */
  export type ContentArtifactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentArtifact.
     */
    data: XOR<ContentArtifactCreateInput, ContentArtifactUncheckedCreateInput>
  }

  /**
   * ContentArtifact createMany
   */
  export type ContentArtifactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentArtifacts.
     */
    data: ContentArtifactCreateManyInput | ContentArtifactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentArtifact createManyAndReturn
   */
  export type ContentArtifactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * The data used to create many ContentArtifacts.
     */
    data: ContentArtifactCreateManyInput | ContentArtifactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentArtifact update
   */
  export type ContentArtifactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentArtifact.
     */
    data: XOR<ContentArtifactUpdateInput, ContentArtifactUncheckedUpdateInput>
    /**
     * Choose, which ContentArtifact to update.
     */
    where: ContentArtifactWhereUniqueInput
  }

  /**
   * ContentArtifact updateMany
   */
  export type ContentArtifactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentArtifacts.
     */
    data: XOR<ContentArtifactUpdateManyMutationInput, ContentArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ContentArtifacts to update
     */
    where?: ContentArtifactWhereInput
    /**
     * Limit how many ContentArtifacts to update.
     */
    limit?: number
  }

  /**
   * ContentArtifact updateManyAndReturn
   */
  export type ContentArtifactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * The data used to update ContentArtifacts.
     */
    data: XOR<ContentArtifactUpdateManyMutationInput, ContentArtifactUncheckedUpdateManyInput>
    /**
     * Filter which ContentArtifacts to update
     */
    where?: ContentArtifactWhereInput
    /**
     * Limit how many ContentArtifacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentArtifact upsert
   */
  export type ContentArtifactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentArtifact to update in case it exists.
     */
    where: ContentArtifactWhereUniqueInput
    /**
     * In case the ContentArtifact found by the `where` argument doesn't exist, create a new ContentArtifact with this data.
     */
    create: XOR<ContentArtifactCreateInput, ContentArtifactUncheckedCreateInput>
    /**
     * In case the ContentArtifact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentArtifactUpdateInput, ContentArtifactUncheckedUpdateInput>
  }

  /**
   * ContentArtifact delete
   */
  export type ContentArtifactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
    /**
     * Filter which ContentArtifact to delete.
     */
    where: ContentArtifactWhereUniqueInput
  }

  /**
   * ContentArtifact deleteMany
   */
  export type ContentArtifactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentArtifacts to delete
     */
    where?: ContentArtifactWhereInput
    /**
     * Limit how many ContentArtifacts to delete.
     */
    limit?: number
  }

  /**
   * ContentArtifact.qaPairs
   */
  export type ContentArtifact$qaPairsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    cursor?: QAPairWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * ContentArtifact.flashcards
   */
  export type ContentArtifact$flashcardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    cursor?: FlashcardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * ContentArtifact.shares
   */
  export type ContentArtifact$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    where?: RoomShareWhereInput
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    cursor?: RoomShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * ContentArtifact.sources
   */
  export type ContentArtifact$sourcesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    where?: ArtifactSourceWhereInput
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    cursor?: ArtifactSourceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArtifactSourceScalarFieldEnum | ArtifactSourceScalarFieldEnum[]
  }

  /**
   * ContentArtifact without action
   */
  export type ContentArtifactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentArtifact
     */
    select?: ContentArtifactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentArtifact
     */
    omit?: ContentArtifactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentArtifactInclude<ExtArgs> | null
  }


  /**
   * Model ArtifactSource
   */

  export type AggregateArtifactSource = {
    _count: ArtifactSourceCountAggregateOutputType | null
    _min: ArtifactSourceMinAggregateOutputType | null
    _max: ArtifactSourceMaxAggregateOutputType | null
  }

  export type ArtifactSourceMinAggregateOutputType = {
    artifactId: string | null
    sourceId: string | null
  }

  export type ArtifactSourceMaxAggregateOutputType = {
    artifactId: string | null
    sourceId: string | null
  }

  export type ArtifactSourceCountAggregateOutputType = {
    artifactId: number
    sourceId: number
    _all: number
  }


  export type ArtifactSourceMinAggregateInputType = {
    artifactId?: true
    sourceId?: true
  }

  export type ArtifactSourceMaxAggregateInputType = {
    artifactId?: true
    sourceId?: true
  }

  export type ArtifactSourceCountAggregateInputType = {
    artifactId?: true
    sourceId?: true
    _all?: true
  }

  export type ArtifactSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactSource to aggregate.
     */
    where?: ArtifactSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactSources to fetch.
     */
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArtifactSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArtifactSources
    **/
    _count?: true | ArtifactSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArtifactSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArtifactSourceMaxAggregateInputType
  }

  export type GetArtifactSourceAggregateType<T extends ArtifactSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateArtifactSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArtifactSource[P]>
      : GetScalarType<T[P], AggregateArtifactSource[P]>
  }




  export type ArtifactSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArtifactSourceWhereInput
    orderBy?: ArtifactSourceOrderByWithAggregationInput | ArtifactSourceOrderByWithAggregationInput[]
    by: ArtifactSourceScalarFieldEnum[] | ArtifactSourceScalarFieldEnum
    having?: ArtifactSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArtifactSourceCountAggregateInputType | true
    _min?: ArtifactSourceMinAggregateInputType
    _max?: ArtifactSourceMaxAggregateInputType
  }

  export type ArtifactSourceGroupByOutputType = {
    artifactId: string
    sourceId: string
    _count: ArtifactSourceCountAggregateOutputType | null
    _min: ArtifactSourceMinAggregateOutputType | null
    _max: ArtifactSourceMaxAggregateOutputType | null
  }

  type GetArtifactSourceGroupByPayload<T extends ArtifactSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArtifactSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArtifactSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArtifactSourceGroupByOutputType[P]>
            : GetScalarType<T[P], ArtifactSourceGroupByOutputType[P]>
        }
      >
    >


  export type ArtifactSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artifactId?: boolean
    sourceId?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactSource"]>

  export type ArtifactSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artifactId?: boolean
    sourceId?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactSource"]>

  export type ArtifactSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    artifactId?: boolean
    sourceId?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["artifactSource"]>

  export type ArtifactSourceSelectScalar = {
    artifactId?: boolean
    sourceId?: boolean
  }

  export type ArtifactSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"artifactId" | "sourceId", ExtArgs["result"]["artifactSource"]>
  export type ArtifactSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }
  export type ArtifactSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }
  export type ArtifactSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    source?: boolean | LectureSourceDefaultArgs<ExtArgs>
  }

  export type $ArtifactSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArtifactSource"
    objects: {
      artifact: Prisma.$ContentArtifactPayload<ExtArgs>
      source: Prisma.$LectureSourcePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      artifactId: string
      sourceId: string
    }, ExtArgs["result"]["artifactSource"]>
    composites: {}
  }

  type ArtifactSourceGetPayload<S extends boolean | null | undefined | ArtifactSourceDefaultArgs> = $Result.GetResult<Prisma.$ArtifactSourcePayload, S>

  type ArtifactSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ArtifactSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ArtifactSourceCountAggregateInputType | true
    }

  export interface ArtifactSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArtifactSource'], meta: { name: 'ArtifactSource' } }
    /**
     * Find zero or one ArtifactSource that matches the filter.
     * @param {ArtifactSourceFindUniqueArgs} args - Arguments to find a ArtifactSource
     * @example
     * // Get one ArtifactSource
     * const artifactSource = await prisma.artifactSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArtifactSourceFindUniqueArgs>(args: SelectSubset<T, ArtifactSourceFindUniqueArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ArtifactSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ArtifactSourceFindUniqueOrThrowArgs} args - Arguments to find a ArtifactSource
     * @example
     * // Get one ArtifactSource
     * const artifactSource = await prisma.artifactSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArtifactSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, ArtifactSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceFindFirstArgs} args - Arguments to find a ArtifactSource
     * @example
     * // Get one ArtifactSource
     * const artifactSource = await prisma.artifactSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArtifactSourceFindFirstArgs>(args?: SelectSubset<T, ArtifactSourceFindFirstArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ArtifactSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceFindFirstOrThrowArgs} args - Arguments to find a ArtifactSource
     * @example
     * // Get one ArtifactSource
     * const artifactSource = await prisma.artifactSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArtifactSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, ArtifactSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ArtifactSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArtifactSources
     * const artifactSources = await prisma.artifactSource.findMany()
     * 
     * // Get first 10 ArtifactSources
     * const artifactSources = await prisma.artifactSource.findMany({ take: 10 })
     * 
     * // Only select the `artifactId`
     * const artifactSourceWithArtifactIdOnly = await prisma.artifactSource.findMany({ select: { artifactId: true } })
     * 
     */
    findMany<T extends ArtifactSourceFindManyArgs>(args?: SelectSubset<T, ArtifactSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ArtifactSource.
     * @param {ArtifactSourceCreateArgs} args - Arguments to create a ArtifactSource.
     * @example
     * // Create one ArtifactSource
     * const ArtifactSource = await prisma.artifactSource.create({
     *   data: {
     *     // ... data to create a ArtifactSource
     *   }
     * })
     * 
     */
    create<T extends ArtifactSourceCreateArgs>(args: SelectSubset<T, ArtifactSourceCreateArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ArtifactSources.
     * @param {ArtifactSourceCreateManyArgs} args - Arguments to create many ArtifactSources.
     * @example
     * // Create many ArtifactSources
     * const artifactSource = await prisma.artifactSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArtifactSourceCreateManyArgs>(args?: SelectSubset<T, ArtifactSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArtifactSources and returns the data saved in the database.
     * @param {ArtifactSourceCreateManyAndReturnArgs} args - Arguments to create many ArtifactSources.
     * @example
     * // Create many ArtifactSources
     * const artifactSource = await prisma.artifactSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArtifactSources and only return the `artifactId`
     * const artifactSourceWithArtifactIdOnly = await prisma.artifactSource.createManyAndReturn({
     *   select: { artifactId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArtifactSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, ArtifactSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ArtifactSource.
     * @param {ArtifactSourceDeleteArgs} args - Arguments to delete one ArtifactSource.
     * @example
     * // Delete one ArtifactSource
     * const ArtifactSource = await prisma.artifactSource.delete({
     *   where: {
     *     // ... filter to delete one ArtifactSource
     *   }
     * })
     * 
     */
    delete<T extends ArtifactSourceDeleteArgs>(args: SelectSubset<T, ArtifactSourceDeleteArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ArtifactSource.
     * @param {ArtifactSourceUpdateArgs} args - Arguments to update one ArtifactSource.
     * @example
     * // Update one ArtifactSource
     * const artifactSource = await prisma.artifactSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArtifactSourceUpdateArgs>(args: SelectSubset<T, ArtifactSourceUpdateArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ArtifactSources.
     * @param {ArtifactSourceDeleteManyArgs} args - Arguments to filter ArtifactSources to delete.
     * @example
     * // Delete a few ArtifactSources
     * const { count } = await prisma.artifactSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArtifactSourceDeleteManyArgs>(args?: SelectSubset<T, ArtifactSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArtifactSources
     * const artifactSource = await prisma.artifactSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArtifactSourceUpdateManyArgs>(args: SelectSubset<T, ArtifactSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArtifactSources and returns the data updated in the database.
     * @param {ArtifactSourceUpdateManyAndReturnArgs} args - Arguments to update many ArtifactSources.
     * @example
     * // Update many ArtifactSources
     * const artifactSource = await prisma.artifactSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ArtifactSources and only return the `artifactId`
     * const artifactSourceWithArtifactIdOnly = await prisma.artifactSource.updateManyAndReturn({
     *   select: { artifactId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ArtifactSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, ArtifactSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ArtifactSource.
     * @param {ArtifactSourceUpsertArgs} args - Arguments to update or create a ArtifactSource.
     * @example
     * // Update or create a ArtifactSource
     * const artifactSource = await prisma.artifactSource.upsert({
     *   create: {
     *     // ... data to create a ArtifactSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArtifactSource we want to update
     *   }
     * })
     */
    upsert<T extends ArtifactSourceUpsertArgs>(args: SelectSubset<T, ArtifactSourceUpsertArgs<ExtArgs>>): Prisma__ArtifactSourceClient<$Result.GetResult<Prisma.$ArtifactSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ArtifactSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceCountArgs} args - Arguments to filter ArtifactSources to count.
     * @example
     * // Count the number of ArtifactSources
     * const count = await prisma.artifactSource.count({
     *   where: {
     *     // ... the filter for the ArtifactSources we want to count
     *   }
     * })
    **/
    count<T extends ArtifactSourceCountArgs>(
      args?: Subset<T, ArtifactSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArtifactSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArtifactSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArtifactSourceAggregateArgs>(args: Subset<T, ArtifactSourceAggregateArgs>): Prisma.PrismaPromise<GetArtifactSourceAggregateType<T>>

    /**
     * Group by ArtifactSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArtifactSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArtifactSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArtifactSourceGroupByArgs['orderBy'] }
        : { orderBy?: ArtifactSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArtifactSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArtifactSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArtifactSource model
   */
  readonly fields: ArtifactSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArtifactSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArtifactSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifact<T extends ContentArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifactDefaultArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    source<T extends LectureSourceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureSourceDefaultArgs<ExtArgs>>): Prisma__LectureSourceClient<$Result.GetResult<Prisma.$LectureSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArtifactSource model
   */
  interface ArtifactSourceFieldRefs {
    readonly artifactId: FieldRef<"ArtifactSource", 'String'>
    readonly sourceId: FieldRef<"ArtifactSource", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ArtifactSource findUnique
   */
  export type ArtifactSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactSource to fetch.
     */
    where: ArtifactSourceWhereUniqueInput
  }

  /**
   * ArtifactSource findUniqueOrThrow
   */
  export type ArtifactSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactSource to fetch.
     */
    where: ArtifactSourceWhereUniqueInput
  }

  /**
   * ArtifactSource findFirst
   */
  export type ArtifactSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactSource to fetch.
     */
    where?: ArtifactSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactSources to fetch.
     */
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactSources.
     */
    cursor?: ArtifactSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactSources.
     */
    distinct?: ArtifactSourceScalarFieldEnum | ArtifactSourceScalarFieldEnum[]
  }

  /**
   * ArtifactSource findFirstOrThrow
   */
  export type ArtifactSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactSource to fetch.
     */
    where?: ArtifactSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactSources to fetch.
     */
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArtifactSources.
     */
    cursor?: ArtifactSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArtifactSources.
     */
    distinct?: ArtifactSourceScalarFieldEnum | ArtifactSourceScalarFieldEnum[]
  }

  /**
   * ArtifactSource findMany
   */
  export type ArtifactSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter, which ArtifactSources to fetch.
     */
    where?: ArtifactSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArtifactSources to fetch.
     */
    orderBy?: ArtifactSourceOrderByWithRelationInput | ArtifactSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArtifactSources.
     */
    cursor?: ArtifactSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArtifactSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArtifactSources.
     */
    skip?: number
    distinct?: ArtifactSourceScalarFieldEnum | ArtifactSourceScalarFieldEnum[]
  }

  /**
   * ArtifactSource create
   */
  export type ArtifactSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a ArtifactSource.
     */
    data: XOR<ArtifactSourceCreateInput, ArtifactSourceUncheckedCreateInput>
  }

  /**
   * ArtifactSource createMany
   */
  export type ArtifactSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArtifactSources.
     */
    data: ArtifactSourceCreateManyInput | ArtifactSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ArtifactSource createManyAndReturn
   */
  export type ArtifactSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * The data used to create many ArtifactSources.
     */
    data: ArtifactSourceCreateManyInput | ArtifactSourceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtifactSource update
   */
  export type ArtifactSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a ArtifactSource.
     */
    data: XOR<ArtifactSourceUpdateInput, ArtifactSourceUncheckedUpdateInput>
    /**
     * Choose, which ArtifactSource to update.
     */
    where: ArtifactSourceWhereUniqueInput
  }

  /**
   * ArtifactSource updateMany
   */
  export type ArtifactSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArtifactSources.
     */
    data: XOR<ArtifactSourceUpdateManyMutationInput, ArtifactSourceUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactSources to update
     */
    where?: ArtifactSourceWhereInput
    /**
     * Limit how many ArtifactSources to update.
     */
    limit?: number
  }

  /**
   * ArtifactSource updateManyAndReturn
   */
  export type ArtifactSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * The data used to update ArtifactSources.
     */
    data: XOR<ArtifactSourceUpdateManyMutationInput, ArtifactSourceUncheckedUpdateManyInput>
    /**
     * Filter which ArtifactSources to update
     */
    where?: ArtifactSourceWhereInput
    /**
     * Limit how many ArtifactSources to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArtifactSource upsert
   */
  export type ArtifactSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the ArtifactSource to update in case it exists.
     */
    where: ArtifactSourceWhereUniqueInput
    /**
     * In case the ArtifactSource found by the `where` argument doesn't exist, create a new ArtifactSource with this data.
     */
    create: XOR<ArtifactSourceCreateInput, ArtifactSourceUncheckedCreateInput>
    /**
     * In case the ArtifactSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArtifactSourceUpdateInput, ArtifactSourceUncheckedUpdateInput>
  }

  /**
   * ArtifactSource delete
   */
  export type ArtifactSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
    /**
     * Filter which ArtifactSource to delete.
     */
    where: ArtifactSourceWhereUniqueInput
  }

  /**
   * ArtifactSource deleteMany
   */
  export type ArtifactSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArtifactSources to delete
     */
    where?: ArtifactSourceWhereInput
    /**
     * Limit how many ArtifactSources to delete.
     */
    limit?: number
  }

  /**
   * ArtifactSource without action
   */
  export type ArtifactSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArtifactSource
     */
    select?: ArtifactSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ArtifactSource
     */
    omit?: ArtifactSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArtifactSourceInclude<ExtArgs> | null
  }


  /**
   * Model QAPair
   */

  export type AggregateQAPair = {
    _count: QAPairCountAggregateOutputType | null
    _avg: QAPairAvgAggregateOutputType | null
    _sum: QAPairSumAggregateOutputType | null
    _min: QAPairMinAggregateOutputType | null
    _max: QAPairMaxAggregateOutputType | null
  }

  export type QAPairAvgAggregateOutputType = {
    difficulty: number | null
  }

  export type QAPairSumAggregateOutputType = {
    difficulty: number | null
  }

  export type QAPairMinAggregateOutputType = {
    id: string | null
    artifactId: string | null
    question: string | null
    answer: string | null
    correctKey: string | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QAPairMaxAggregateOutputType = {
    id: string | null
    artifactId: string | null
    question: string | null
    answer: string | null
    correctKey: string | null
    difficulty: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QAPairCountAggregateOutputType = {
    id: number
    artifactId: number
    question: number
    answer: number
    choices: number
    correctKey: number
    difficulty: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QAPairAvgAggregateInputType = {
    difficulty?: true
  }

  export type QAPairSumAggregateInputType = {
    difficulty?: true
  }

  export type QAPairMinAggregateInputType = {
    id?: true
    artifactId?: true
    question?: true
    answer?: true
    correctKey?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QAPairMaxAggregateInputType = {
    id?: true
    artifactId?: true
    question?: true
    answer?: true
    correctKey?: true
    difficulty?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QAPairCountAggregateInputType = {
    id?: true
    artifactId?: true
    question?: true
    answer?: true
    choices?: true
    correctKey?: true
    difficulty?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QAPairAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAPair to aggregate.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QAPairs
    **/
    _count?: true | QAPairCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QAPairAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QAPairSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QAPairMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QAPairMaxAggregateInputType
  }

  export type GetQAPairAggregateType<T extends QAPairAggregateArgs> = {
        [P in keyof T & keyof AggregateQAPair]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQAPair[P]>
      : GetScalarType<T[P], AggregateQAPair[P]>
  }




  export type QAPairGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QAPairWhereInput
    orderBy?: QAPairOrderByWithAggregationInput | QAPairOrderByWithAggregationInput[]
    by: QAPairScalarFieldEnum[] | QAPairScalarFieldEnum
    having?: QAPairScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QAPairCountAggregateInputType | true
    _avg?: QAPairAvgAggregateInputType
    _sum?: QAPairSumAggregateInputType
    _min?: QAPairMinAggregateInputType
    _max?: QAPairMaxAggregateInputType
  }

  export type QAPairGroupByOutputType = {
    id: string
    artifactId: string
    question: string
    answer: string
    choices: JsonValue | null
    correctKey: string | null
    difficulty: number | null
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: QAPairCountAggregateOutputType | null
    _avg: QAPairAvgAggregateOutputType | null
    _sum: QAPairSumAggregateOutputType | null
    _min: QAPairMinAggregateOutputType | null
    _max: QAPairMaxAggregateOutputType | null
  }

  type GetQAPairGroupByPayload<T extends QAPairGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QAPairGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QAPairGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QAPairGroupByOutputType[P]>
            : GetScalarType<T[P], QAPairGroupByOutputType[P]>
        }
      >
    >


  export type QAPairSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    question?: boolean
    answer?: boolean
    choices?: boolean
    correctKey?: boolean
    difficulty?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAPair"]>

  export type QAPairSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    question?: boolean
    answer?: boolean
    choices?: boolean
    correctKey?: boolean
    difficulty?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAPair"]>

  export type QAPairSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    question?: boolean
    answer?: boolean
    choices?: boolean
    correctKey?: boolean
    difficulty?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["qAPair"]>

  export type QAPairSelectScalar = {
    id?: boolean
    artifactId?: boolean
    question?: boolean
    answer?: boolean
    choices?: boolean
    correctKey?: boolean
    difficulty?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QAPairOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artifactId" | "question" | "answer" | "choices" | "correctKey" | "difficulty" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["qAPair"]>
  export type QAPairInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }
  export type QAPairIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }
  export type QAPairIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }

  export type $QAPairPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QAPair"
    objects: {
      artifact: Prisma.$ContentArtifactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artifactId: string
      question: string
      answer: string
      choices: Prisma.JsonValue | null
      correctKey: string | null
      difficulty: number | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["qAPair"]>
    composites: {}
  }

  type QAPairGetPayload<S extends boolean | null | undefined | QAPairDefaultArgs> = $Result.GetResult<Prisma.$QAPairPayload, S>

  type QAPairCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QAPairFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QAPairCountAggregateInputType | true
    }

  export interface QAPairDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QAPair'], meta: { name: 'QAPair' } }
    /**
     * Find zero or one QAPair that matches the filter.
     * @param {QAPairFindUniqueArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QAPairFindUniqueArgs>(args: SelectSubset<T, QAPairFindUniqueArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QAPair that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QAPairFindUniqueOrThrowArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QAPairFindUniqueOrThrowArgs>(args: SelectSubset<T, QAPairFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QAPair that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindFirstArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QAPairFindFirstArgs>(args?: SelectSubset<T, QAPairFindFirstArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QAPair that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindFirstOrThrowArgs} args - Arguments to find a QAPair
     * @example
     * // Get one QAPair
     * const qAPair = await prisma.qAPair.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QAPairFindFirstOrThrowArgs>(args?: SelectSubset<T, QAPairFindFirstOrThrowArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QAPairs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QAPairs
     * const qAPairs = await prisma.qAPair.findMany()
     * 
     * // Get first 10 QAPairs
     * const qAPairs = await prisma.qAPair.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const qAPairWithIdOnly = await prisma.qAPair.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QAPairFindManyArgs>(args?: SelectSubset<T, QAPairFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QAPair.
     * @param {QAPairCreateArgs} args - Arguments to create a QAPair.
     * @example
     * // Create one QAPair
     * const QAPair = await prisma.qAPair.create({
     *   data: {
     *     // ... data to create a QAPair
     *   }
     * })
     * 
     */
    create<T extends QAPairCreateArgs>(args: SelectSubset<T, QAPairCreateArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QAPairs.
     * @param {QAPairCreateManyArgs} args - Arguments to create many QAPairs.
     * @example
     * // Create many QAPairs
     * const qAPair = await prisma.qAPair.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QAPairCreateManyArgs>(args?: SelectSubset<T, QAPairCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QAPairs and returns the data saved in the database.
     * @param {QAPairCreateManyAndReturnArgs} args - Arguments to create many QAPairs.
     * @example
     * // Create many QAPairs
     * const qAPair = await prisma.qAPair.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QAPairs and only return the `id`
     * const qAPairWithIdOnly = await prisma.qAPair.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QAPairCreateManyAndReturnArgs>(args?: SelectSubset<T, QAPairCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QAPair.
     * @param {QAPairDeleteArgs} args - Arguments to delete one QAPair.
     * @example
     * // Delete one QAPair
     * const QAPair = await prisma.qAPair.delete({
     *   where: {
     *     // ... filter to delete one QAPair
     *   }
     * })
     * 
     */
    delete<T extends QAPairDeleteArgs>(args: SelectSubset<T, QAPairDeleteArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QAPair.
     * @param {QAPairUpdateArgs} args - Arguments to update one QAPair.
     * @example
     * // Update one QAPair
     * const qAPair = await prisma.qAPair.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QAPairUpdateArgs>(args: SelectSubset<T, QAPairUpdateArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QAPairs.
     * @param {QAPairDeleteManyArgs} args - Arguments to filter QAPairs to delete.
     * @example
     * // Delete a few QAPairs
     * const { count } = await prisma.qAPair.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QAPairDeleteManyArgs>(args?: SelectSubset<T, QAPairDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QAPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QAPairs
     * const qAPair = await prisma.qAPair.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QAPairUpdateManyArgs>(args: SelectSubset<T, QAPairUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QAPairs and returns the data updated in the database.
     * @param {QAPairUpdateManyAndReturnArgs} args - Arguments to update many QAPairs.
     * @example
     * // Update many QAPairs
     * const qAPair = await prisma.qAPair.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QAPairs and only return the `id`
     * const qAPairWithIdOnly = await prisma.qAPair.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QAPairUpdateManyAndReturnArgs>(args: SelectSubset<T, QAPairUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QAPair.
     * @param {QAPairUpsertArgs} args - Arguments to update or create a QAPair.
     * @example
     * // Update or create a QAPair
     * const qAPair = await prisma.qAPair.upsert({
     *   create: {
     *     // ... data to create a QAPair
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QAPair we want to update
     *   }
     * })
     */
    upsert<T extends QAPairUpsertArgs>(args: SelectSubset<T, QAPairUpsertArgs<ExtArgs>>): Prisma__QAPairClient<$Result.GetResult<Prisma.$QAPairPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QAPairs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairCountArgs} args - Arguments to filter QAPairs to count.
     * @example
     * // Count the number of QAPairs
     * const count = await prisma.qAPair.count({
     *   where: {
     *     // ... the filter for the QAPairs we want to count
     *   }
     * })
    **/
    count<T extends QAPairCountArgs>(
      args?: Subset<T, QAPairCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QAPairCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QAPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QAPairAggregateArgs>(args: Subset<T, QAPairAggregateArgs>): Prisma.PrismaPromise<GetQAPairAggregateType<T>>

    /**
     * Group by QAPair.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QAPairGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QAPairGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QAPairGroupByArgs['orderBy'] }
        : { orderBy?: QAPairGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QAPairGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQAPairGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QAPair model
   */
  readonly fields: QAPairFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QAPair.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QAPairClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifact<T extends ContentArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifactDefaultArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QAPair model
   */
  interface QAPairFieldRefs {
    readonly id: FieldRef<"QAPair", 'String'>
    readonly artifactId: FieldRef<"QAPair", 'String'>
    readonly question: FieldRef<"QAPair", 'String'>
    readonly answer: FieldRef<"QAPair", 'String'>
    readonly choices: FieldRef<"QAPair", 'Json'>
    readonly correctKey: FieldRef<"QAPair", 'String'>
    readonly difficulty: FieldRef<"QAPair", 'Int'>
    readonly tags: FieldRef<"QAPair", 'String[]'>
    readonly metadata: FieldRef<"QAPair", 'Json'>
    readonly createdAt: FieldRef<"QAPair", 'DateTime'>
    readonly updatedAt: FieldRef<"QAPair", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QAPair findUnique
   */
  export type QAPairFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair findUniqueOrThrow
   */
  export type QAPairFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair findFirst
   */
  export type QAPairFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAPairs.
     */
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair findFirstOrThrow
   */
  export type QAPairFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPair to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QAPairs.
     */
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair findMany
   */
  export type QAPairFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter, which QAPairs to fetch.
     */
    where?: QAPairWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QAPairs to fetch.
     */
    orderBy?: QAPairOrderByWithRelationInput | QAPairOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QAPairs.
     */
    cursor?: QAPairWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QAPairs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QAPairs.
     */
    skip?: number
    distinct?: QAPairScalarFieldEnum | QAPairScalarFieldEnum[]
  }

  /**
   * QAPair create
   */
  export type QAPairCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The data needed to create a QAPair.
     */
    data: XOR<QAPairCreateInput, QAPairUncheckedCreateInput>
  }

  /**
   * QAPair createMany
   */
  export type QAPairCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QAPairs.
     */
    data: QAPairCreateManyInput | QAPairCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QAPair createManyAndReturn
   */
  export type QAPairCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * The data used to create many QAPairs.
     */
    data: QAPairCreateManyInput | QAPairCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QAPair update
   */
  export type QAPairUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The data needed to update a QAPair.
     */
    data: XOR<QAPairUpdateInput, QAPairUncheckedUpdateInput>
    /**
     * Choose, which QAPair to update.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair updateMany
   */
  export type QAPairUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QAPairs.
     */
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyInput>
    /**
     * Filter which QAPairs to update
     */
    where?: QAPairWhereInput
    /**
     * Limit how many QAPairs to update.
     */
    limit?: number
  }

  /**
   * QAPair updateManyAndReturn
   */
  export type QAPairUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * The data used to update QAPairs.
     */
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyInput>
    /**
     * Filter which QAPairs to update
     */
    where?: QAPairWhereInput
    /**
     * Limit how many QAPairs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QAPair upsert
   */
  export type QAPairUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * The filter to search for the QAPair to update in case it exists.
     */
    where: QAPairWhereUniqueInput
    /**
     * In case the QAPair found by the `where` argument doesn't exist, create a new QAPair with this data.
     */
    create: XOR<QAPairCreateInput, QAPairUncheckedCreateInput>
    /**
     * In case the QAPair was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QAPairUpdateInput, QAPairUncheckedUpdateInput>
  }

  /**
   * QAPair delete
   */
  export type QAPairDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
    /**
     * Filter which QAPair to delete.
     */
    where: QAPairWhereUniqueInput
  }

  /**
   * QAPair deleteMany
   */
  export type QAPairDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QAPairs to delete
     */
    where?: QAPairWhereInput
    /**
     * Limit how many QAPairs to delete.
     */
    limit?: number
  }

  /**
   * QAPair without action
   */
  export type QAPairDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QAPair
     */
    select?: QAPairSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QAPair
     */
    omit?: QAPairOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QAPairInclude<ExtArgs> | null
  }


  /**
   * Model Flashcard
   */

  export type AggregateFlashcard = {
    _count: FlashcardCountAggregateOutputType | null
    _min: FlashcardMinAggregateOutputType | null
    _max: FlashcardMaxAggregateOutputType | null
  }

  export type FlashcardMinAggregateOutputType = {
    id: string | null
    artifactId: string | null
    front: string | null
    back: string | null
    hint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlashcardMaxAggregateOutputType = {
    id: string | null
    artifactId: string | null
    front: string | null
    back: string | null
    hint: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlashcardCountAggregateOutputType = {
    id: number
    artifactId: number
    front: number
    back: number
    hint: number
    tags: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlashcardMinAggregateInputType = {
    id?: true
    artifactId?: true
    front?: true
    back?: true
    hint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlashcardMaxAggregateInputType = {
    id?: true
    artifactId?: true
    front?: true
    back?: true
    hint?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlashcardCountAggregateInputType = {
    id?: true
    artifactId?: true
    front?: true
    back?: true
    hint?: true
    tags?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlashcardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flashcard to aggregate.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flashcards
    **/
    _count?: true | FlashcardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlashcardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlashcardMaxAggregateInputType
  }

  export type GetFlashcardAggregateType<T extends FlashcardAggregateArgs> = {
        [P in keyof T & keyof AggregateFlashcard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlashcard[P]>
      : GetScalarType<T[P], AggregateFlashcard[P]>
  }




  export type FlashcardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlashcardWhereInput
    orderBy?: FlashcardOrderByWithAggregationInput | FlashcardOrderByWithAggregationInput[]
    by: FlashcardScalarFieldEnum[] | FlashcardScalarFieldEnum
    having?: FlashcardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlashcardCountAggregateInputType | true
    _min?: FlashcardMinAggregateInputType
    _max?: FlashcardMaxAggregateInputType
  }

  export type FlashcardGroupByOutputType = {
    id: string
    artifactId: string
    front: string
    back: string
    hint: string | null
    tags: string[]
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FlashcardCountAggregateOutputType | null
    _min: FlashcardMinAggregateOutputType | null
    _max: FlashcardMaxAggregateOutputType | null
  }

  type GetFlashcardGroupByPayload<T extends FlashcardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlashcardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlashcardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlashcardGroupByOutputType[P]>
            : GetScalarType<T[P], FlashcardGroupByOutputType[P]>
        }
      >
    >


  export type FlashcardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    front?: boolean
    back?: boolean
    hint?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    front?: boolean
    back?: boolean
    hint?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    artifactId?: boolean
    front?: boolean
    back?: boolean
    hint?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flashcard"]>

  export type FlashcardSelectScalar = {
    id?: boolean
    artifactId?: boolean
    front?: boolean
    back?: boolean
    hint?: boolean
    tags?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlashcardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "artifactId" | "front" | "back" | "hint" | "tags" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["flashcard"]>
  export type FlashcardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }
  export type FlashcardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }
  export type FlashcardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
  }

  export type $FlashcardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flashcard"
    objects: {
      artifact: Prisma.$ContentArtifactPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      artifactId: string
      front: string
      back: string
      hint: string | null
      tags: string[]
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flashcard"]>
    composites: {}
  }

  type FlashcardGetPayload<S extends boolean | null | undefined | FlashcardDefaultArgs> = $Result.GetResult<Prisma.$FlashcardPayload, S>

  type FlashcardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlashcardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlashcardCountAggregateInputType | true
    }

  export interface FlashcardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flashcard'], meta: { name: 'Flashcard' } }
    /**
     * Find zero or one Flashcard that matches the filter.
     * @param {FlashcardFindUniqueArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlashcardFindUniqueArgs>(args: SelectSubset<T, FlashcardFindUniqueArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Flashcard that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlashcardFindUniqueOrThrowArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlashcardFindUniqueOrThrowArgs>(args: SelectSubset<T, FlashcardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flashcard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindFirstArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlashcardFindFirstArgs>(args?: SelectSubset<T, FlashcardFindFirstArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Flashcard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindFirstOrThrowArgs} args - Arguments to find a Flashcard
     * @example
     * // Get one Flashcard
     * const flashcard = await prisma.flashcard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlashcardFindFirstOrThrowArgs>(args?: SelectSubset<T, FlashcardFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Flashcards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flashcards
     * const flashcards = await prisma.flashcard.findMany()
     * 
     * // Get first 10 Flashcards
     * const flashcards = await prisma.flashcard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlashcardFindManyArgs>(args?: SelectSubset<T, FlashcardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Flashcard.
     * @param {FlashcardCreateArgs} args - Arguments to create a Flashcard.
     * @example
     * // Create one Flashcard
     * const Flashcard = await prisma.flashcard.create({
     *   data: {
     *     // ... data to create a Flashcard
     *   }
     * })
     * 
     */
    create<T extends FlashcardCreateArgs>(args: SelectSubset<T, FlashcardCreateArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Flashcards.
     * @param {FlashcardCreateManyArgs} args - Arguments to create many Flashcards.
     * @example
     * // Create many Flashcards
     * const flashcard = await prisma.flashcard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlashcardCreateManyArgs>(args?: SelectSubset<T, FlashcardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flashcards and returns the data saved in the database.
     * @param {FlashcardCreateManyAndReturnArgs} args - Arguments to create many Flashcards.
     * @example
     * // Create many Flashcards
     * const flashcard = await prisma.flashcard.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flashcards and only return the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlashcardCreateManyAndReturnArgs>(args?: SelectSubset<T, FlashcardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Flashcard.
     * @param {FlashcardDeleteArgs} args - Arguments to delete one Flashcard.
     * @example
     * // Delete one Flashcard
     * const Flashcard = await prisma.flashcard.delete({
     *   where: {
     *     // ... filter to delete one Flashcard
     *   }
     * })
     * 
     */
    delete<T extends FlashcardDeleteArgs>(args: SelectSubset<T, FlashcardDeleteArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Flashcard.
     * @param {FlashcardUpdateArgs} args - Arguments to update one Flashcard.
     * @example
     * // Update one Flashcard
     * const flashcard = await prisma.flashcard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlashcardUpdateArgs>(args: SelectSubset<T, FlashcardUpdateArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Flashcards.
     * @param {FlashcardDeleteManyArgs} args - Arguments to filter Flashcards to delete.
     * @example
     * // Delete a few Flashcards
     * const { count } = await prisma.flashcard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlashcardDeleteManyArgs>(args?: SelectSubset<T, FlashcardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flashcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flashcards
     * const flashcard = await prisma.flashcard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlashcardUpdateManyArgs>(args: SelectSubset<T, FlashcardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flashcards and returns the data updated in the database.
     * @param {FlashcardUpdateManyAndReturnArgs} args - Arguments to update many Flashcards.
     * @example
     * // Update many Flashcards
     * const flashcard = await prisma.flashcard.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Flashcards and only return the `id`
     * const flashcardWithIdOnly = await prisma.flashcard.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlashcardUpdateManyAndReturnArgs>(args: SelectSubset<T, FlashcardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Flashcard.
     * @param {FlashcardUpsertArgs} args - Arguments to update or create a Flashcard.
     * @example
     * // Update or create a Flashcard
     * const flashcard = await prisma.flashcard.upsert({
     *   create: {
     *     // ... data to create a Flashcard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flashcard we want to update
     *   }
     * })
     */
    upsert<T extends FlashcardUpsertArgs>(args: SelectSubset<T, FlashcardUpsertArgs<ExtArgs>>): Prisma__FlashcardClient<$Result.GetResult<Prisma.$FlashcardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Flashcards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardCountArgs} args - Arguments to filter Flashcards to count.
     * @example
     * // Count the number of Flashcards
     * const count = await prisma.flashcard.count({
     *   where: {
     *     // ... the filter for the Flashcards we want to count
     *   }
     * })
    **/
    count<T extends FlashcardCountArgs>(
      args?: Subset<T, FlashcardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlashcardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flashcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlashcardAggregateArgs>(args: Subset<T, FlashcardAggregateArgs>): Prisma.PrismaPromise<GetFlashcardAggregateType<T>>

    /**
     * Group by Flashcard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlashcardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlashcardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlashcardGroupByArgs['orderBy'] }
        : { orderBy?: FlashcardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlashcardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlashcardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flashcard model
   */
  readonly fields: FlashcardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flashcard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlashcardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    artifact<T extends ContentArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifactDefaultArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flashcard model
   */
  interface FlashcardFieldRefs {
    readonly id: FieldRef<"Flashcard", 'String'>
    readonly artifactId: FieldRef<"Flashcard", 'String'>
    readonly front: FieldRef<"Flashcard", 'String'>
    readonly back: FieldRef<"Flashcard", 'String'>
    readonly hint: FieldRef<"Flashcard", 'String'>
    readonly tags: FieldRef<"Flashcard", 'String[]'>
    readonly metadata: FieldRef<"Flashcard", 'Json'>
    readonly createdAt: FieldRef<"Flashcard", 'DateTime'>
    readonly updatedAt: FieldRef<"Flashcard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flashcard findUnique
   */
  export type FlashcardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard findUniqueOrThrow
   */
  export type FlashcardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard findFirst
   */
  export type FlashcardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flashcards.
     */
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard findFirstOrThrow
   */
  export type FlashcardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcard to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flashcards.
     */
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard findMany
   */
  export type FlashcardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter, which Flashcards to fetch.
     */
    where?: FlashcardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flashcards to fetch.
     */
    orderBy?: FlashcardOrderByWithRelationInput | FlashcardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flashcards.
     */
    cursor?: FlashcardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flashcards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flashcards.
     */
    skip?: number
    distinct?: FlashcardScalarFieldEnum | FlashcardScalarFieldEnum[]
  }

  /**
   * Flashcard create
   */
  export type FlashcardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The data needed to create a Flashcard.
     */
    data: XOR<FlashcardCreateInput, FlashcardUncheckedCreateInput>
  }

  /**
   * Flashcard createMany
   */
  export type FlashcardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flashcards.
     */
    data: FlashcardCreateManyInput | FlashcardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flashcard createManyAndReturn
   */
  export type FlashcardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * The data used to create many Flashcards.
     */
    data: FlashcardCreateManyInput | FlashcardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flashcard update
   */
  export type FlashcardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The data needed to update a Flashcard.
     */
    data: XOR<FlashcardUpdateInput, FlashcardUncheckedUpdateInput>
    /**
     * Choose, which Flashcard to update.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard updateMany
   */
  export type FlashcardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flashcards.
     */
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyInput>
    /**
     * Filter which Flashcards to update
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to update.
     */
    limit?: number
  }

  /**
   * Flashcard updateManyAndReturn
   */
  export type FlashcardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * The data used to update Flashcards.
     */
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyInput>
    /**
     * Filter which Flashcards to update
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flashcard upsert
   */
  export type FlashcardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * The filter to search for the Flashcard to update in case it exists.
     */
    where: FlashcardWhereUniqueInput
    /**
     * In case the Flashcard found by the `where` argument doesn't exist, create a new Flashcard with this data.
     */
    create: XOR<FlashcardCreateInput, FlashcardUncheckedCreateInput>
    /**
     * In case the Flashcard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlashcardUpdateInput, FlashcardUncheckedUpdateInput>
  }

  /**
   * Flashcard delete
   */
  export type FlashcardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
    /**
     * Filter which Flashcard to delete.
     */
    where: FlashcardWhereUniqueInput
  }

  /**
   * Flashcard deleteMany
   */
  export type FlashcardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flashcards to delete
     */
    where?: FlashcardWhereInput
    /**
     * Limit how many Flashcards to delete.
     */
    limit?: number
  }

  /**
   * Flashcard without action
   */
  export type FlashcardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flashcard
     */
    select?: FlashcardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Flashcard
     */
    omit?: FlashcardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlashcardInclude<ExtArgs> | null
  }


  /**
   * Model LectureAssistant
   */

  export type AggregateLectureAssistant = {
    _count: LectureAssistantCountAggregateOutputType | null
    _min: LectureAssistantMinAggregateOutputType | null
    _max: LectureAssistantMaxAggregateOutputType | null
  }

  export type LectureAssistantMinAggregateOutputType = {
    id: string | null
    lectureId: string | null
    displayName: string | null
    systemPrompt: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureAssistantMaxAggregateOutputType = {
    id: string | null
    lectureId: string | null
    displayName: string | null
    systemPrompt: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LectureAssistantCountAggregateOutputType = {
    id: number
    lectureId: number
    displayName: number
    systemPrompt: number
    model: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LectureAssistantMinAggregateInputType = {
    id?: true
    lectureId?: true
    displayName?: true
    systemPrompt?: true
    model?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureAssistantMaxAggregateInputType = {
    id?: true
    lectureId?: true
    displayName?: true
    systemPrompt?: true
    model?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LectureAssistantCountAggregateInputType = {
    id?: true
    lectureId?: true
    displayName?: true
    systemPrompt?: true
    model?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LectureAssistantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LectureAssistant to aggregate.
     */
    where?: LectureAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureAssistants to fetch.
     */
    orderBy?: LectureAssistantOrderByWithRelationInput | LectureAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LectureAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LectureAssistants
    **/
    _count?: true | LectureAssistantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LectureAssistantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LectureAssistantMaxAggregateInputType
  }

  export type GetLectureAssistantAggregateType<T extends LectureAssistantAggregateArgs> = {
        [P in keyof T & keyof AggregateLectureAssistant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLectureAssistant[P]>
      : GetScalarType<T[P], AggregateLectureAssistant[P]>
  }




  export type LectureAssistantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LectureAssistantWhereInput
    orderBy?: LectureAssistantOrderByWithAggregationInput | LectureAssistantOrderByWithAggregationInput[]
    by: LectureAssistantScalarFieldEnum[] | LectureAssistantScalarFieldEnum
    having?: LectureAssistantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LectureAssistantCountAggregateInputType | true
    _min?: LectureAssistantMinAggregateInputType
    _max?: LectureAssistantMaxAggregateInputType
  }

  export type LectureAssistantGroupByOutputType = {
    id: string
    lectureId: string
    displayName: string | null
    systemPrompt: string | null
    model: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: LectureAssistantCountAggregateOutputType | null
    _min: LectureAssistantMinAggregateOutputType | null
    _max: LectureAssistantMaxAggregateOutputType | null
  }

  type GetLectureAssistantGroupByPayload<T extends LectureAssistantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LectureAssistantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LectureAssistantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LectureAssistantGroupByOutputType[P]>
            : GetScalarType<T[P], LectureAssistantGroupByOutputType[P]>
        }
      >
    >


  export type LectureAssistantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    displayName?: boolean
    systemPrompt?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    messages?: boolean | LectureAssistant$messagesArgs<ExtArgs>
    _count?: boolean | LectureAssistantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureAssistant"]>

  export type LectureAssistantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    displayName?: boolean
    systemPrompt?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureAssistant"]>

  export type LectureAssistantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lectureId?: boolean
    displayName?: boolean
    systemPrompt?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lectureAssistant"]>

  export type LectureAssistantSelectScalar = {
    id?: boolean
    lectureId?: boolean
    displayName?: boolean
    systemPrompt?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LectureAssistantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lectureId" | "displayName" | "systemPrompt" | "model" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["lectureAssistant"]>
  export type LectureAssistantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
    messages?: boolean | LectureAssistant$messagesArgs<ExtArgs>
    _count?: boolean | LectureAssistantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LectureAssistantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }
  export type LectureAssistantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }

  export type $LectureAssistantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LectureAssistant"
    objects: {
      lecture: Prisma.$LecturePayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lectureId: string
      displayName: string | null
      systemPrompt: string | null
      model: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lectureAssistant"]>
    composites: {}
  }

  type LectureAssistantGetPayload<S extends boolean | null | undefined | LectureAssistantDefaultArgs> = $Result.GetResult<Prisma.$LectureAssistantPayload, S>

  type LectureAssistantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LectureAssistantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LectureAssistantCountAggregateInputType | true
    }

  export interface LectureAssistantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LectureAssistant'], meta: { name: 'LectureAssistant' } }
    /**
     * Find zero or one LectureAssistant that matches the filter.
     * @param {LectureAssistantFindUniqueArgs} args - Arguments to find a LectureAssistant
     * @example
     * // Get one LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LectureAssistantFindUniqueArgs>(args: SelectSubset<T, LectureAssistantFindUniqueArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LectureAssistant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LectureAssistantFindUniqueOrThrowArgs} args - Arguments to find a LectureAssistant
     * @example
     * // Get one LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LectureAssistantFindUniqueOrThrowArgs>(args: SelectSubset<T, LectureAssistantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LectureAssistant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantFindFirstArgs} args - Arguments to find a LectureAssistant
     * @example
     * // Get one LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LectureAssistantFindFirstArgs>(args?: SelectSubset<T, LectureAssistantFindFirstArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LectureAssistant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantFindFirstOrThrowArgs} args - Arguments to find a LectureAssistant
     * @example
     * // Get one LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LectureAssistantFindFirstOrThrowArgs>(args?: SelectSubset<T, LectureAssistantFindFirstOrThrowArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LectureAssistants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LectureAssistants
     * const lectureAssistants = await prisma.lectureAssistant.findMany()
     * 
     * // Get first 10 LectureAssistants
     * const lectureAssistants = await prisma.lectureAssistant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lectureAssistantWithIdOnly = await prisma.lectureAssistant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LectureAssistantFindManyArgs>(args?: SelectSubset<T, LectureAssistantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LectureAssistant.
     * @param {LectureAssistantCreateArgs} args - Arguments to create a LectureAssistant.
     * @example
     * // Create one LectureAssistant
     * const LectureAssistant = await prisma.lectureAssistant.create({
     *   data: {
     *     // ... data to create a LectureAssistant
     *   }
     * })
     * 
     */
    create<T extends LectureAssistantCreateArgs>(args: SelectSubset<T, LectureAssistantCreateArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LectureAssistants.
     * @param {LectureAssistantCreateManyArgs} args - Arguments to create many LectureAssistants.
     * @example
     * // Create many LectureAssistants
     * const lectureAssistant = await prisma.lectureAssistant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LectureAssistantCreateManyArgs>(args?: SelectSubset<T, LectureAssistantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LectureAssistants and returns the data saved in the database.
     * @param {LectureAssistantCreateManyAndReturnArgs} args - Arguments to create many LectureAssistants.
     * @example
     * // Create many LectureAssistants
     * const lectureAssistant = await prisma.lectureAssistant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LectureAssistants and only return the `id`
     * const lectureAssistantWithIdOnly = await prisma.lectureAssistant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LectureAssistantCreateManyAndReturnArgs>(args?: SelectSubset<T, LectureAssistantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LectureAssistant.
     * @param {LectureAssistantDeleteArgs} args - Arguments to delete one LectureAssistant.
     * @example
     * // Delete one LectureAssistant
     * const LectureAssistant = await prisma.lectureAssistant.delete({
     *   where: {
     *     // ... filter to delete one LectureAssistant
     *   }
     * })
     * 
     */
    delete<T extends LectureAssistantDeleteArgs>(args: SelectSubset<T, LectureAssistantDeleteArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LectureAssistant.
     * @param {LectureAssistantUpdateArgs} args - Arguments to update one LectureAssistant.
     * @example
     * // Update one LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LectureAssistantUpdateArgs>(args: SelectSubset<T, LectureAssistantUpdateArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LectureAssistants.
     * @param {LectureAssistantDeleteManyArgs} args - Arguments to filter LectureAssistants to delete.
     * @example
     * // Delete a few LectureAssistants
     * const { count } = await prisma.lectureAssistant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LectureAssistantDeleteManyArgs>(args?: SelectSubset<T, LectureAssistantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LectureAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LectureAssistants
     * const lectureAssistant = await prisma.lectureAssistant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LectureAssistantUpdateManyArgs>(args: SelectSubset<T, LectureAssistantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LectureAssistants and returns the data updated in the database.
     * @param {LectureAssistantUpdateManyAndReturnArgs} args - Arguments to update many LectureAssistants.
     * @example
     * // Update many LectureAssistants
     * const lectureAssistant = await prisma.lectureAssistant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LectureAssistants and only return the `id`
     * const lectureAssistantWithIdOnly = await prisma.lectureAssistant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LectureAssistantUpdateManyAndReturnArgs>(args: SelectSubset<T, LectureAssistantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LectureAssistant.
     * @param {LectureAssistantUpsertArgs} args - Arguments to update or create a LectureAssistant.
     * @example
     * // Update or create a LectureAssistant
     * const lectureAssistant = await prisma.lectureAssistant.upsert({
     *   create: {
     *     // ... data to create a LectureAssistant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LectureAssistant we want to update
     *   }
     * })
     */
    upsert<T extends LectureAssistantUpsertArgs>(args: SelectSubset<T, LectureAssistantUpsertArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LectureAssistants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantCountArgs} args - Arguments to filter LectureAssistants to count.
     * @example
     * // Count the number of LectureAssistants
     * const count = await prisma.lectureAssistant.count({
     *   where: {
     *     // ... the filter for the LectureAssistants we want to count
     *   }
     * })
    **/
    count<T extends LectureAssistantCountArgs>(
      args?: Subset<T, LectureAssistantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LectureAssistantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LectureAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LectureAssistantAggregateArgs>(args: Subset<T, LectureAssistantAggregateArgs>): Prisma.PrismaPromise<GetLectureAssistantAggregateType<T>>

    /**
     * Group by LectureAssistant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LectureAssistantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LectureAssistantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LectureAssistantGroupByArgs['orderBy'] }
        : { orderBy?: LectureAssistantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LectureAssistantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLectureAssistantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LectureAssistant model
   */
  readonly fields: LectureAssistantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LectureAssistant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LectureAssistantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends LectureAssistant$messagesArgs<ExtArgs> = {}>(args?: Subset<T, LectureAssistant$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LectureAssistant model
   */
  interface LectureAssistantFieldRefs {
    readonly id: FieldRef<"LectureAssistant", 'String'>
    readonly lectureId: FieldRef<"LectureAssistant", 'String'>
    readonly displayName: FieldRef<"LectureAssistant", 'String'>
    readonly systemPrompt: FieldRef<"LectureAssistant", 'String'>
    readonly model: FieldRef<"LectureAssistant", 'String'>
    readonly metadata: FieldRef<"LectureAssistant", 'Json'>
    readonly createdAt: FieldRef<"LectureAssistant", 'DateTime'>
    readonly updatedAt: FieldRef<"LectureAssistant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LectureAssistant findUnique
   */
  export type LectureAssistantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter, which LectureAssistant to fetch.
     */
    where: LectureAssistantWhereUniqueInput
  }

  /**
   * LectureAssistant findUniqueOrThrow
   */
  export type LectureAssistantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter, which LectureAssistant to fetch.
     */
    where: LectureAssistantWhereUniqueInput
  }

  /**
   * LectureAssistant findFirst
   */
  export type LectureAssistantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter, which LectureAssistant to fetch.
     */
    where?: LectureAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureAssistants to fetch.
     */
    orderBy?: LectureAssistantOrderByWithRelationInput | LectureAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LectureAssistants.
     */
    cursor?: LectureAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LectureAssistants.
     */
    distinct?: LectureAssistantScalarFieldEnum | LectureAssistantScalarFieldEnum[]
  }

  /**
   * LectureAssistant findFirstOrThrow
   */
  export type LectureAssistantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter, which LectureAssistant to fetch.
     */
    where?: LectureAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureAssistants to fetch.
     */
    orderBy?: LectureAssistantOrderByWithRelationInput | LectureAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LectureAssistants.
     */
    cursor?: LectureAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureAssistants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LectureAssistants.
     */
    distinct?: LectureAssistantScalarFieldEnum | LectureAssistantScalarFieldEnum[]
  }

  /**
   * LectureAssistant findMany
   */
  export type LectureAssistantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter, which LectureAssistants to fetch.
     */
    where?: LectureAssistantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LectureAssistants to fetch.
     */
    orderBy?: LectureAssistantOrderByWithRelationInput | LectureAssistantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LectureAssistants.
     */
    cursor?: LectureAssistantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LectureAssistants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LectureAssistants.
     */
    skip?: number
    distinct?: LectureAssistantScalarFieldEnum | LectureAssistantScalarFieldEnum[]
  }

  /**
   * LectureAssistant create
   */
  export type LectureAssistantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * The data needed to create a LectureAssistant.
     */
    data: XOR<LectureAssistantCreateInput, LectureAssistantUncheckedCreateInput>
  }

  /**
   * LectureAssistant createMany
   */
  export type LectureAssistantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LectureAssistants.
     */
    data: LectureAssistantCreateManyInput | LectureAssistantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LectureAssistant createManyAndReturn
   */
  export type LectureAssistantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * The data used to create many LectureAssistants.
     */
    data: LectureAssistantCreateManyInput | LectureAssistantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LectureAssistant update
   */
  export type LectureAssistantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * The data needed to update a LectureAssistant.
     */
    data: XOR<LectureAssistantUpdateInput, LectureAssistantUncheckedUpdateInput>
    /**
     * Choose, which LectureAssistant to update.
     */
    where: LectureAssistantWhereUniqueInput
  }

  /**
   * LectureAssistant updateMany
   */
  export type LectureAssistantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LectureAssistants.
     */
    data: XOR<LectureAssistantUpdateManyMutationInput, LectureAssistantUncheckedUpdateManyInput>
    /**
     * Filter which LectureAssistants to update
     */
    where?: LectureAssistantWhereInput
    /**
     * Limit how many LectureAssistants to update.
     */
    limit?: number
  }

  /**
   * LectureAssistant updateManyAndReturn
   */
  export type LectureAssistantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * The data used to update LectureAssistants.
     */
    data: XOR<LectureAssistantUpdateManyMutationInput, LectureAssistantUncheckedUpdateManyInput>
    /**
     * Filter which LectureAssistants to update
     */
    where?: LectureAssistantWhereInput
    /**
     * Limit how many LectureAssistants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LectureAssistant upsert
   */
  export type LectureAssistantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * The filter to search for the LectureAssistant to update in case it exists.
     */
    where: LectureAssistantWhereUniqueInput
    /**
     * In case the LectureAssistant found by the `where` argument doesn't exist, create a new LectureAssistant with this data.
     */
    create: XOR<LectureAssistantCreateInput, LectureAssistantUncheckedCreateInput>
    /**
     * In case the LectureAssistant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LectureAssistantUpdateInput, LectureAssistantUncheckedUpdateInput>
  }

  /**
   * LectureAssistant delete
   */
  export type LectureAssistantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
    /**
     * Filter which LectureAssistant to delete.
     */
    where: LectureAssistantWhereUniqueInput
  }

  /**
   * LectureAssistant deleteMany
   */
  export type LectureAssistantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LectureAssistants to delete
     */
    where?: LectureAssistantWhereInput
    /**
     * Limit how many LectureAssistants to delete.
     */
    limit?: number
  }

  /**
   * LectureAssistant.messages
   */
  export type LectureAssistant$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * LectureAssistant without action
   */
  export type LectureAssistantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LectureAssistant
     */
    select?: LectureAssistantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LectureAssistant
     */
    omit?: LectureAssistantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LectureAssistantInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    assistantId: string | null
    role: $Enums.ChatRole | null
    content: string | null
    toolName: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    assistantId: string | null
    role: $Enums.ChatRole | null
    content: string | null
    toolName: string | null
    model: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    assistantId: number
    role: number
    content: number
    toolName: number
    model: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    assistantId?: true
    role?: true
    content?: true
    toolName?: true
    model?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    assistantId?: true
    role?: true
    content?: true
    toolName?: true
    model?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    assistantId?: true
    role?: true
    content?: true
    toolName?: true
    model?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    assistantId: string
    role: $Enums.ChatRole
    content: string
    toolName: string | null
    model: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assistantId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assistantId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assistantId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    assistantId?: boolean
    role?: boolean
    content?: boolean
    toolName?: boolean
    model?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "assistantId" | "role" | "content" | "toolName" | "model" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["chatMessage"]>
  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assistant?: boolean | LectureAssistantDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      assistant: Prisma.$LectureAssistantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assistantId: string
      role: $Enums.ChatRole
      content: string
      toolName: string | null
      model: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages and returns the data updated in the database.
     * @param {ChatMessageUpdateManyAndReturnArgs} args - Arguments to update many ChatMessages.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChatMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, ChatMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assistant<T extends LectureAssistantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureAssistantDefaultArgs<ExtArgs>>): Prisma__LectureAssistantClient<$Result.GetResult<Prisma.$LectureAssistantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly assistantId: FieldRef<"ChatMessage", 'String'>
    readonly role: FieldRef<"ChatMessage", 'ChatRole'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly toolName: FieldRef<"ChatMessage", 'String'>
    readonly model: FieldRef<"ChatMessage", 'String'>
    readonly metadata: FieldRef<"ChatMessage", 'Json'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
  }

  /**
   * ChatMessage updateManyAndReturn
   */
  export type ChatMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
    /**
     * Limit how many ChatMessages to delete.
     */
    limit?: number
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChatMessage
     */
    omit?: ChatMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Model Bookmark
   */

  export type AggregateBookmark = {
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  export type BookmarkMinAggregateOutputType = {
    userId: string | null
    lectureId: string | null
    createdAt: Date | null
  }

  export type BookmarkMaxAggregateOutputType = {
    userId: string | null
    lectureId: string | null
    createdAt: Date | null
  }

  export type BookmarkCountAggregateOutputType = {
    userId: number
    lectureId: number
    createdAt: number
    _all: number
  }


  export type BookmarkMinAggregateInputType = {
    userId?: true
    lectureId?: true
    createdAt?: true
  }

  export type BookmarkMaxAggregateInputType = {
    userId?: true
    lectureId?: true
    createdAt?: true
  }

  export type BookmarkCountAggregateInputType = {
    userId?: true
    lectureId?: true
    createdAt?: true
    _all?: true
  }

  export type BookmarkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmark to aggregate.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookmarks
    **/
    _count?: true | BookmarkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookmarkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookmarkMaxAggregateInputType
  }

  export type GetBookmarkAggregateType<T extends BookmarkAggregateArgs> = {
        [P in keyof T & keyof AggregateBookmark]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBookmark[P]>
      : GetScalarType<T[P], AggregateBookmark[P]>
  }




  export type BookmarkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookmarkWhereInput
    orderBy?: BookmarkOrderByWithAggregationInput | BookmarkOrderByWithAggregationInput[]
    by: BookmarkScalarFieldEnum[] | BookmarkScalarFieldEnum
    having?: BookmarkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookmarkCountAggregateInputType | true
    _min?: BookmarkMinAggregateInputType
    _max?: BookmarkMaxAggregateInputType
  }

  export type BookmarkGroupByOutputType = {
    userId: string
    lectureId: string
    createdAt: Date
    _count: BookmarkCountAggregateOutputType | null
    _min: BookmarkMinAggregateOutputType | null
    _max: BookmarkMaxAggregateOutputType | null
  }

  type GetBookmarkGroupByPayload<T extends BookmarkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookmarkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookmarkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
            : GetScalarType<T[P], BookmarkGroupByOutputType[P]>
        }
      >
    >


  export type BookmarkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lectureId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lectureId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    lectureId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bookmark"]>

  export type BookmarkSelectScalar = {
    userId?: boolean
    lectureId?: boolean
    createdAt?: boolean
  }

  export type BookmarkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "lectureId" | "createdAt", ExtArgs["result"]["bookmark"]>
  export type BookmarkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }
  export type BookmarkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    lecture?: boolean | LectureDefaultArgs<ExtArgs>
  }

  export type $BookmarkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bookmark"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      lecture: Prisma.$LecturePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      lectureId: string
      createdAt: Date
    }, ExtArgs["result"]["bookmark"]>
    composites: {}
  }

  type BookmarkGetPayload<S extends boolean | null | undefined | BookmarkDefaultArgs> = $Result.GetResult<Prisma.$BookmarkPayload, S>

  type BookmarkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookmarkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookmarkCountAggregateInputType | true
    }

  export interface BookmarkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bookmark'], meta: { name: 'Bookmark' } }
    /**
     * Find zero or one Bookmark that matches the filter.
     * @param {BookmarkFindUniqueArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookmarkFindUniqueArgs>(args: SelectSubset<T, BookmarkFindUniqueArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bookmark that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookmarkFindUniqueOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookmarkFindUniqueOrThrowArgs>(args: SelectSubset<T, BookmarkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmark that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookmarkFindFirstArgs>(args?: SelectSubset<T, BookmarkFindFirstArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bookmark that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindFirstOrThrowArgs} args - Arguments to find a Bookmark
     * @example
     * // Get one Bookmark
     * const bookmark = await prisma.bookmark.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookmarkFindFirstOrThrowArgs>(args?: SelectSubset<T, BookmarkFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookmarks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookmarks
     * const bookmarks = await prisma.bookmark.findMany()
     * 
     * // Get first 10 Bookmarks
     * const bookmarks = await prisma.bookmark.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const bookmarkWithUserIdOnly = await prisma.bookmark.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends BookmarkFindManyArgs>(args?: SelectSubset<T, BookmarkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bookmark.
     * @param {BookmarkCreateArgs} args - Arguments to create a Bookmark.
     * @example
     * // Create one Bookmark
     * const Bookmark = await prisma.bookmark.create({
     *   data: {
     *     // ... data to create a Bookmark
     *   }
     * })
     * 
     */
    create<T extends BookmarkCreateArgs>(args: SelectSubset<T, BookmarkCreateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookmarks.
     * @param {BookmarkCreateManyArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookmarkCreateManyArgs>(args?: SelectSubset<T, BookmarkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookmarks and returns the data saved in the database.
     * @param {BookmarkCreateManyAndReturnArgs} args - Arguments to create many Bookmarks.
     * @example
     * // Create many Bookmarks
     * const bookmark = await prisma.bookmark.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookmarks and only return the `userId`
     * const bookmarkWithUserIdOnly = await prisma.bookmark.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookmarkCreateManyAndReturnArgs>(args?: SelectSubset<T, BookmarkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bookmark.
     * @param {BookmarkDeleteArgs} args - Arguments to delete one Bookmark.
     * @example
     * // Delete one Bookmark
     * const Bookmark = await prisma.bookmark.delete({
     *   where: {
     *     // ... filter to delete one Bookmark
     *   }
     * })
     * 
     */
    delete<T extends BookmarkDeleteArgs>(args: SelectSubset<T, BookmarkDeleteArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bookmark.
     * @param {BookmarkUpdateArgs} args - Arguments to update one Bookmark.
     * @example
     * // Update one Bookmark
     * const bookmark = await prisma.bookmark.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookmarkUpdateArgs>(args: SelectSubset<T, BookmarkUpdateArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookmarks.
     * @param {BookmarkDeleteManyArgs} args - Arguments to filter Bookmarks to delete.
     * @example
     * // Delete a few Bookmarks
     * const { count } = await prisma.bookmark.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookmarkDeleteManyArgs>(args?: SelectSubset<T, BookmarkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookmarkUpdateManyArgs>(args: SelectSubset<T, BookmarkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookmarks and returns the data updated in the database.
     * @param {BookmarkUpdateManyAndReturnArgs} args - Arguments to update many Bookmarks.
     * @example
     * // Update many Bookmarks
     * const bookmark = await prisma.bookmark.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookmarks and only return the `userId`
     * const bookmarkWithUserIdOnly = await prisma.bookmark.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookmarkUpdateManyAndReturnArgs>(args: SelectSubset<T, BookmarkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bookmark.
     * @param {BookmarkUpsertArgs} args - Arguments to update or create a Bookmark.
     * @example
     * // Update or create a Bookmark
     * const bookmark = await prisma.bookmark.upsert({
     *   create: {
     *     // ... data to create a Bookmark
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bookmark we want to update
     *   }
     * })
     */
    upsert<T extends BookmarkUpsertArgs>(args: SelectSubset<T, BookmarkUpsertArgs<ExtArgs>>): Prisma__BookmarkClient<$Result.GetResult<Prisma.$BookmarkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookmarks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkCountArgs} args - Arguments to filter Bookmarks to count.
     * @example
     * // Count the number of Bookmarks
     * const count = await prisma.bookmark.count({
     *   where: {
     *     // ... the filter for the Bookmarks we want to count
     *   }
     * })
    **/
    count<T extends BookmarkCountArgs>(
      args?: Subset<T, BookmarkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookmarkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookmarkAggregateArgs>(args: Subset<T, BookmarkAggregateArgs>): Prisma.PrismaPromise<GetBookmarkAggregateType<T>>

    /**
     * Group by Bookmark.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookmarkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookmarkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookmarkGroupByArgs['orderBy'] }
        : { orderBy?: BookmarkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookmarkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookmarkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bookmark model
   */
  readonly fields: BookmarkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bookmark.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookmarkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lecture<T extends LectureDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LectureDefaultArgs<ExtArgs>>): Prisma__LectureClient<$Result.GetResult<Prisma.$LecturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bookmark model
   */
  interface BookmarkFieldRefs {
    readonly userId: FieldRef<"Bookmark", 'String'>
    readonly lectureId: FieldRef<"Bookmark", 'String'>
    readonly createdAt: FieldRef<"Bookmark", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bookmark findUnique
   */
  export type BookmarkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findUniqueOrThrow
   */
  export type BookmarkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark findFirst
   */
  export type BookmarkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findFirstOrThrow
   */
  export type BookmarkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmark to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookmarks.
     */
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark findMany
   */
  export type BookmarkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter, which Bookmarks to fetch.
     */
    where?: BookmarkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookmarks to fetch.
     */
    orderBy?: BookmarkOrderByWithRelationInput | BookmarkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookmarks.
     */
    cursor?: BookmarkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookmarks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookmarks.
     */
    skip?: number
    distinct?: BookmarkScalarFieldEnum | BookmarkScalarFieldEnum[]
  }

  /**
   * Bookmark create
   */
  export type BookmarkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to create a Bookmark.
     */
    data: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
  }

  /**
   * Bookmark createMany
   */
  export type BookmarkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bookmark createManyAndReturn
   */
  export type BookmarkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * The data used to create many Bookmarks.
     */
    data: BookmarkCreateManyInput | BookmarkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmark update
   */
  export type BookmarkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The data needed to update a Bookmark.
     */
    data: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
    /**
     * Choose, which Bookmark to update.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark updateMany
   */
  export type BookmarkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
  }

  /**
   * Bookmark updateManyAndReturn
   */
  export type BookmarkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * The data used to update Bookmarks.
     */
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyInput>
    /**
     * Filter which Bookmarks to update
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bookmark upsert
   */
  export type BookmarkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * The filter to search for the Bookmark to update in case it exists.
     */
    where: BookmarkWhereUniqueInput
    /**
     * In case the Bookmark found by the `where` argument doesn't exist, create a new Bookmark with this data.
     */
    create: XOR<BookmarkCreateInput, BookmarkUncheckedCreateInput>
    /**
     * In case the Bookmark was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookmarkUpdateInput, BookmarkUncheckedUpdateInput>
  }

  /**
   * Bookmark delete
   */
  export type BookmarkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
    /**
     * Filter which Bookmark to delete.
     */
    where: BookmarkWhereUniqueInput
  }

  /**
   * Bookmark deleteMany
   */
  export type BookmarkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookmarks to delete
     */
    where?: BookmarkWhereInput
    /**
     * Limit how many Bookmarks to delete.
     */
    limit?: number
  }

  /**
   * Bookmark without action
   */
  export type BookmarkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bookmark
     */
    select?: BookmarkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bookmark
     */
    omit?: BookmarkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookmarkInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    isPrivate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    ownerId: string | null
    isPrivate: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    description: number
    ownerId: number
    isPrivate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isPrivate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isPrivate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    ownerId?: true
    isPrivate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    name: string
    description: string | null
    ownerId: string
    isPrivate: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Room$membershipsArgs<ExtArgs>
    shares?: boolean | Room$sharesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    ownerId?: boolean
    isPrivate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "ownerId" | "isPrivate" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Room$membershipsArgs<ExtArgs>
    shares?: boolean | Room$sharesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      memberships: Prisma.$RoomMembershipPayload<ExtArgs>[]
      shares: Prisma.$RoomSharePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      ownerId: string
      isPrivate: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    memberships<T extends Room$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Room$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shares<T extends Room$sharesArgs<ExtArgs> = {}>(args?: Subset<T, Room$sharesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly description: FieldRef<"Room", 'String'>
    readonly ownerId: FieldRef<"Room", 'String'>
    readonly isPrivate: FieldRef<"Room", 'Boolean'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.memberships
   */
  export type Room$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    cursor?: RoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * Room.shares
   */
  export type Room$sharesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    where?: RoomShareWhereInput
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    cursor?: RoomShareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model RoomMembership
   */

  export type AggregateRoomMembership = {
    _count: RoomMembershipCountAggregateOutputType | null
    _min: RoomMembershipMinAggregateOutputType | null
    _max: RoomMembershipMaxAggregateOutputType | null
  }

  export type RoomMembershipMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    invitedById: string | null
    role: $Enums.MemberRole | null
    status: $Enums.MemberStatus | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMembershipMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    invitedById: string | null
    role: $Enums.MemberRole | null
    status: $Enums.MemberStatus | null
    joinedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMembershipCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    invitedById: number
    role: number
    status: number
    joinedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMembershipMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    invitedById?: true
    role?: true
    status?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMembershipMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    invitedById?: true
    role?: true
    status?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMembershipCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    invitedById?: true
    role?: true
    status?: true
    joinedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMembership to aggregate.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomMemberships
    **/
    _count?: true | RoomMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMembershipMaxAggregateInputType
  }

  export type GetRoomMembershipAggregateType<T extends RoomMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomMembership[P]>
      : GetScalarType<T[P], AggregateRoomMembership[P]>
  }




  export type RoomMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithAggregationInput | RoomMembershipOrderByWithAggregationInput[]
    by: RoomMembershipScalarFieldEnum[] | RoomMembershipScalarFieldEnum
    having?: RoomMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomMembershipCountAggregateInputType | true
    _min?: RoomMembershipMinAggregateInputType
    _max?: RoomMembershipMaxAggregateInputType
  }

  export type RoomMembershipGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    invitedById: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: RoomMembershipCountAggregateOutputType | null
    _min: RoomMembershipMinAggregateOutputType | null
    _max: RoomMembershipMaxAggregateOutputType | null
  }

  type GetRoomMembershipGroupByPayload<T extends RoomMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], RoomMembershipGroupByOutputType[P]>
        }
      >
    >


  export type RoomMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    invitedById?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMembership"]>

  export type RoomMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    invitedById?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMembership"]>

  export type RoomMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    invitedById?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMembership"]>

  export type RoomMembershipSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    invitedById?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "userId" | "invitedById" | "role" | "status" | "joinedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["roomMembership"]>
  export type RoomMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invitedBy?: boolean | RoomMembership$invitedByArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomMembership"
    objects: {
      invitedBy: Prisma.$UserPayload<ExtArgs> | null
      room: Prisma.$RoomPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      invitedById: string | null
      role: $Enums.MemberRole
      status: $Enums.MemberStatus
      joinedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomMembership"]>
    composites: {}
  }

  type RoomMembershipGetPayload<S extends boolean | null | undefined | RoomMembershipDefaultArgs> = $Result.GetResult<Prisma.$RoomMembershipPayload, S>

  type RoomMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomMembershipCountAggregateInputType | true
    }

  export interface RoomMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomMembership'], meta: { name: 'RoomMembership' } }
    /**
     * Find zero or one RoomMembership that matches the filter.
     * @param {RoomMembershipFindUniqueArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomMembershipFindUniqueArgs>(args: SelectSubset<T, RoomMembershipFindUniqueArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomMembershipFindUniqueOrThrowArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindFirstArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomMembershipFindFirstArgs>(args?: SelectSubset<T, RoomMembershipFindFirstArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindFirstOrThrowArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomMemberships
     * const roomMemberships = await prisma.roomMembership.findMany()
     * 
     * // Get first 10 RoomMemberships
     * const roomMemberships = await prisma.roomMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomMembershipWithIdOnly = await prisma.roomMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomMembershipFindManyArgs>(args?: SelectSubset<T, RoomMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomMembership.
     * @param {RoomMembershipCreateArgs} args - Arguments to create a RoomMembership.
     * @example
     * // Create one RoomMembership
     * const RoomMembership = await prisma.roomMembership.create({
     *   data: {
     *     // ... data to create a RoomMembership
     *   }
     * })
     * 
     */
    create<T extends RoomMembershipCreateArgs>(args: SelectSubset<T, RoomMembershipCreateArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomMemberships.
     * @param {RoomMembershipCreateManyArgs} args - Arguments to create many RoomMemberships.
     * @example
     * // Create many RoomMemberships
     * const roomMembership = await prisma.roomMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomMembershipCreateManyArgs>(args?: SelectSubset<T, RoomMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomMemberships and returns the data saved in the database.
     * @param {RoomMembershipCreateManyAndReturnArgs} args - Arguments to create many RoomMemberships.
     * @example
     * // Create many RoomMemberships
     * const roomMembership = await prisma.roomMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomMemberships and only return the `id`
     * const roomMembershipWithIdOnly = await prisma.roomMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomMembership.
     * @param {RoomMembershipDeleteArgs} args - Arguments to delete one RoomMembership.
     * @example
     * // Delete one RoomMembership
     * const RoomMembership = await prisma.roomMembership.delete({
     *   where: {
     *     // ... filter to delete one RoomMembership
     *   }
     * })
     * 
     */
    delete<T extends RoomMembershipDeleteArgs>(args: SelectSubset<T, RoomMembershipDeleteArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomMembership.
     * @param {RoomMembershipUpdateArgs} args - Arguments to update one RoomMembership.
     * @example
     * // Update one RoomMembership
     * const roomMembership = await prisma.roomMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomMembershipUpdateArgs>(args: SelectSubset<T, RoomMembershipUpdateArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomMemberships.
     * @param {RoomMembershipDeleteManyArgs} args - Arguments to filter RoomMemberships to delete.
     * @example
     * // Delete a few RoomMemberships
     * const { count } = await prisma.roomMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomMembershipDeleteManyArgs>(args?: SelectSubset<T, RoomMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomMemberships
     * const roomMembership = await prisma.roomMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomMembershipUpdateManyArgs>(args: SelectSubset<T, RoomMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomMemberships and returns the data updated in the database.
     * @param {RoomMembershipUpdateManyAndReturnArgs} args - Arguments to update many RoomMemberships.
     * @example
     * // Update many RoomMemberships
     * const roomMembership = await prisma.roomMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomMemberships and only return the `id`
     * const roomMembershipWithIdOnly = await prisma.roomMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomMembership.
     * @param {RoomMembershipUpsertArgs} args - Arguments to update or create a RoomMembership.
     * @example
     * // Update or create a RoomMembership
     * const roomMembership = await prisma.roomMembership.upsert({
     *   create: {
     *     // ... data to create a RoomMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomMembership we want to update
     *   }
     * })
     */
    upsert<T extends RoomMembershipUpsertArgs>(args: SelectSubset<T, RoomMembershipUpsertArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipCountArgs} args - Arguments to filter RoomMemberships to count.
     * @example
     * // Count the number of RoomMemberships
     * const count = await prisma.roomMembership.count({
     *   where: {
     *     // ... the filter for the RoomMemberships we want to count
     *   }
     * })
    **/
    count<T extends RoomMembershipCountArgs>(
      args?: Subset<T, RoomMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomMembershipAggregateArgs>(args: Subset<T, RoomMembershipAggregateArgs>): Prisma.PrismaPromise<GetRoomMembershipAggregateType<T>>

    /**
     * Group by RoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomMembershipGroupByArgs['orderBy'] }
        : { orderBy?: RoomMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomMembership model
   */
  readonly fields: RoomMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invitedBy<T extends RoomMembership$invitedByArgs<ExtArgs> = {}>(args?: Subset<T, RoomMembership$invitedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomMembership model
   */
  interface RoomMembershipFieldRefs {
    readonly id: FieldRef<"RoomMembership", 'String'>
    readonly roomId: FieldRef<"RoomMembership", 'String'>
    readonly userId: FieldRef<"RoomMembership", 'String'>
    readonly invitedById: FieldRef<"RoomMembership", 'String'>
    readonly role: FieldRef<"RoomMembership", 'MemberRole'>
    readonly status: FieldRef<"RoomMembership", 'MemberStatus'>
    readonly joinedAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly createdAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomMembership findUnique
   */
  export type RoomMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership findUniqueOrThrow
   */
  export type RoomMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership findFirst
   */
  export type RoomMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMemberships.
     */
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership findFirstOrThrow
   */
  export type RoomMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMemberships.
     */
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership findMany
   */
  export type RoomMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMemberships to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership create
   */
  export type RoomMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomMembership.
     */
    data: XOR<RoomMembershipCreateInput, RoomMembershipUncheckedCreateInput>
  }

  /**
   * RoomMembership createMany
   */
  export type RoomMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomMemberships.
     */
    data: RoomMembershipCreateManyInput | RoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomMembership createManyAndReturn
   */
  export type RoomMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many RoomMemberships.
     */
    data: RoomMembershipCreateManyInput | RoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomMembership update
   */
  export type RoomMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomMembership.
     */
    data: XOR<RoomMembershipUpdateInput, RoomMembershipUncheckedUpdateInput>
    /**
     * Choose, which RoomMembership to update.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership updateMany
   */
  export type RoomMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomMemberships.
     */
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RoomMemberships to update
     */
    where?: RoomMembershipWhereInput
    /**
     * Limit how many RoomMemberships to update.
     */
    limit?: number
  }

  /**
   * RoomMembership updateManyAndReturn
   */
  export type RoomMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * The data used to update RoomMemberships.
     */
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RoomMemberships to update
     */
    where?: RoomMembershipWhereInput
    /**
     * Limit how many RoomMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomMembership upsert
   */
  export type RoomMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomMembership to update in case it exists.
     */
    where: RoomMembershipWhereUniqueInput
    /**
     * In case the RoomMembership found by the `where` argument doesn't exist, create a new RoomMembership with this data.
     */
    create: XOR<RoomMembershipCreateInput, RoomMembershipUncheckedCreateInput>
    /**
     * In case the RoomMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomMembershipUpdateInput, RoomMembershipUncheckedUpdateInput>
  }

  /**
   * RoomMembership delete
   */
  export type RoomMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter which RoomMembership to delete.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership deleteMany
   */
  export type RoomMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMemberships to delete
     */
    where?: RoomMembershipWhereInput
    /**
     * Limit how many RoomMemberships to delete.
     */
    limit?: number
  }

  /**
   * RoomMembership.invitedBy
   */
  export type RoomMembership$invitedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * RoomMembership without action
   */
  export type RoomMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomMembership
     */
    omit?: RoomMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
  }


  /**
   * Model RoomShare
   */

  export type AggregateRoomShare = {
    _count: RoomShareCountAggregateOutputType | null
    _min: RoomShareMinAggregateOutputType | null
    _max: RoomShareMaxAggregateOutputType | null
  }

  export type RoomShareMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    artifactId: string | null
    sharedById: string | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomShareMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    artifactId: string | null
    sharedById: string | null
    caption: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomShareCountAggregateOutputType = {
    id: number
    roomId: number
    artifactId: number
    sharedById: number
    caption: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomShareMinAggregateInputType = {
    id?: true
    roomId?: true
    artifactId?: true
    sharedById?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomShareMaxAggregateInputType = {
    id?: true
    roomId?: true
    artifactId?: true
    sharedById?: true
    caption?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomShareCountAggregateInputType = {
    id?: true
    roomId?: true
    artifactId?: true
    sharedById?: true
    caption?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomShareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomShare to aggregate.
     */
    where?: RoomShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomShares to fetch.
     */
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomShares
    **/
    _count?: true | RoomShareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomShareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomShareMaxAggregateInputType
  }

  export type GetRoomShareAggregateType<T extends RoomShareAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomShare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomShare[P]>
      : GetScalarType<T[P], AggregateRoomShare[P]>
  }




  export type RoomShareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomShareWhereInput
    orderBy?: RoomShareOrderByWithAggregationInput | RoomShareOrderByWithAggregationInput[]
    by: RoomShareScalarFieldEnum[] | RoomShareScalarFieldEnum
    having?: RoomShareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomShareCountAggregateInputType | true
    _min?: RoomShareMinAggregateInputType
    _max?: RoomShareMaxAggregateInputType
  }

  export type RoomShareGroupByOutputType = {
    id: string
    roomId: string
    artifactId: string
    sharedById: string
    caption: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RoomShareCountAggregateOutputType | null
    _min: RoomShareMinAggregateOutputType | null
    _max: RoomShareMaxAggregateOutputType | null
  }

  type GetRoomShareGroupByPayload<T extends RoomShareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomShareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomShareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomShareGroupByOutputType[P]>
            : GetScalarType<T[P], RoomShareGroupByOutputType[P]>
        }
      >
    >


  export type RoomShareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    artifactId?: boolean
    sharedById?: boolean
    caption?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
    notes?: boolean | RoomShare$notesArgs<ExtArgs>
    _count?: boolean | RoomShareCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomShare"]>

  export type RoomShareSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    artifactId?: boolean
    sharedById?: boolean
    caption?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomShare"]>

  export type RoomShareSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    artifactId?: boolean
    sharedById?: boolean
    caption?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomShare"]>

  export type RoomShareSelectScalar = {
    id?: boolean
    roomId?: boolean
    artifactId?: boolean
    sharedById?: boolean
    caption?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomShareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "artifactId" | "sharedById" | "caption" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["roomShare"]>
  export type RoomShareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
    notes?: boolean | RoomShare$notesArgs<ExtArgs>
    _count?: boolean | RoomShareCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomShareIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomShareIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    artifact?: boolean | ContentArtifactDefaultArgs<ExtArgs>
    sharedBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomSharePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomShare"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      artifact: Prisma.$ContentArtifactPayload<ExtArgs>
      sharedBy: Prisma.$UserPayload<ExtArgs>
      notes: Prisma.$RoomNotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      artifactId: string
      sharedById: string
      caption: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomShare"]>
    composites: {}
  }

  type RoomShareGetPayload<S extends boolean | null | undefined | RoomShareDefaultArgs> = $Result.GetResult<Prisma.$RoomSharePayload, S>

  type RoomShareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomShareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomShareCountAggregateInputType | true
    }

  export interface RoomShareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomShare'], meta: { name: 'RoomShare' } }
    /**
     * Find zero or one RoomShare that matches the filter.
     * @param {RoomShareFindUniqueArgs} args - Arguments to find a RoomShare
     * @example
     * // Get one RoomShare
     * const roomShare = await prisma.roomShare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomShareFindUniqueArgs>(args: SelectSubset<T, RoomShareFindUniqueArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomShare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomShareFindUniqueOrThrowArgs} args - Arguments to find a RoomShare
     * @example
     * // Get one RoomShare
     * const roomShare = await prisma.roomShare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomShareFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomShareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomShare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareFindFirstArgs} args - Arguments to find a RoomShare
     * @example
     * // Get one RoomShare
     * const roomShare = await prisma.roomShare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomShareFindFirstArgs>(args?: SelectSubset<T, RoomShareFindFirstArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomShare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareFindFirstOrThrowArgs} args - Arguments to find a RoomShare
     * @example
     * // Get one RoomShare
     * const roomShare = await prisma.roomShare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomShareFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomShareFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomShares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomShares
     * const roomShares = await prisma.roomShare.findMany()
     * 
     * // Get first 10 RoomShares
     * const roomShares = await prisma.roomShare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomShareWithIdOnly = await prisma.roomShare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomShareFindManyArgs>(args?: SelectSubset<T, RoomShareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomShare.
     * @param {RoomShareCreateArgs} args - Arguments to create a RoomShare.
     * @example
     * // Create one RoomShare
     * const RoomShare = await prisma.roomShare.create({
     *   data: {
     *     // ... data to create a RoomShare
     *   }
     * })
     * 
     */
    create<T extends RoomShareCreateArgs>(args: SelectSubset<T, RoomShareCreateArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomShares.
     * @param {RoomShareCreateManyArgs} args - Arguments to create many RoomShares.
     * @example
     * // Create many RoomShares
     * const roomShare = await prisma.roomShare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomShareCreateManyArgs>(args?: SelectSubset<T, RoomShareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomShares and returns the data saved in the database.
     * @param {RoomShareCreateManyAndReturnArgs} args - Arguments to create many RoomShares.
     * @example
     * // Create many RoomShares
     * const roomShare = await prisma.roomShare.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomShares and only return the `id`
     * const roomShareWithIdOnly = await prisma.roomShare.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomShareCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomShareCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomShare.
     * @param {RoomShareDeleteArgs} args - Arguments to delete one RoomShare.
     * @example
     * // Delete one RoomShare
     * const RoomShare = await prisma.roomShare.delete({
     *   where: {
     *     // ... filter to delete one RoomShare
     *   }
     * })
     * 
     */
    delete<T extends RoomShareDeleteArgs>(args: SelectSubset<T, RoomShareDeleteArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomShare.
     * @param {RoomShareUpdateArgs} args - Arguments to update one RoomShare.
     * @example
     * // Update one RoomShare
     * const roomShare = await prisma.roomShare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomShareUpdateArgs>(args: SelectSubset<T, RoomShareUpdateArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomShares.
     * @param {RoomShareDeleteManyArgs} args - Arguments to filter RoomShares to delete.
     * @example
     * // Delete a few RoomShares
     * const { count } = await prisma.roomShare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomShareDeleteManyArgs>(args?: SelectSubset<T, RoomShareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomShares
     * const roomShare = await prisma.roomShare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomShareUpdateManyArgs>(args: SelectSubset<T, RoomShareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomShares and returns the data updated in the database.
     * @param {RoomShareUpdateManyAndReturnArgs} args - Arguments to update many RoomShares.
     * @example
     * // Update many RoomShares
     * const roomShare = await prisma.roomShare.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomShares and only return the `id`
     * const roomShareWithIdOnly = await prisma.roomShare.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomShareUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomShareUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomShare.
     * @param {RoomShareUpsertArgs} args - Arguments to update or create a RoomShare.
     * @example
     * // Update or create a RoomShare
     * const roomShare = await prisma.roomShare.upsert({
     *   create: {
     *     // ... data to create a RoomShare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomShare we want to update
     *   }
     * })
     */
    upsert<T extends RoomShareUpsertArgs>(args: SelectSubset<T, RoomShareUpsertArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomShares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareCountArgs} args - Arguments to filter RoomShares to count.
     * @example
     * // Count the number of RoomShares
     * const count = await prisma.roomShare.count({
     *   where: {
     *     // ... the filter for the RoomShares we want to count
     *   }
     * })
    **/
    count<T extends RoomShareCountArgs>(
      args?: Subset<T, RoomShareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomShareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomShareAggregateArgs>(args: Subset<T, RoomShareAggregateArgs>): Prisma.PrismaPromise<GetRoomShareAggregateType<T>>

    /**
     * Group by RoomShare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomShareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomShareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomShareGroupByArgs['orderBy'] }
        : { orderBy?: RoomShareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomShareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomShareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomShare model
   */
  readonly fields: RoomShareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomShare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomShareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    artifact<T extends ContentArtifactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentArtifactDefaultArgs<ExtArgs>>): Prisma__ContentArtifactClient<$Result.GetResult<Prisma.$ContentArtifactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sharedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notes<T extends RoomShare$notesArgs<ExtArgs> = {}>(args?: Subset<T, RoomShare$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomShare model
   */
  interface RoomShareFieldRefs {
    readonly id: FieldRef<"RoomShare", 'String'>
    readonly roomId: FieldRef<"RoomShare", 'String'>
    readonly artifactId: FieldRef<"RoomShare", 'String'>
    readonly sharedById: FieldRef<"RoomShare", 'String'>
    readonly caption: FieldRef<"RoomShare", 'String'>
    readonly metadata: FieldRef<"RoomShare", 'Json'>
    readonly createdAt: FieldRef<"RoomShare", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomShare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomShare findUnique
   */
  export type RoomShareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter, which RoomShare to fetch.
     */
    where: RoomShareWhereUniqueInput
  }

  /**
   * RoomShare findUniqueOrThrow
   */
  export type RoomShareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter, which RoomShare to fetch.
     */
    where: RoomShareWhereUniqueInput
  }

  /**
   * RoomShare findFirst
   */
  export type RoomShareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter, which RoomShare to fetch.
     */
    where?: RoomShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomShares to fetch.
     */
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomShares.
     */
    cursor?: RoomShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomShares.
     */
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * RoomShare findFirstOrThrow
   */
  export type RoomShareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter, which RoomShare to fetch.
     */
    where?: RoomShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomShares to fetch.
     */
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomShares.
     */
    cursor?: RoomShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomShares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomShares.
     */
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * RoomShare findMany
   */
  export type RoomShareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter, which RoomShares to fetch.
     */
    where?: RoomShareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomShares to fetch.
     */
    orderBy?: RoomShareOrderByWithRelationInput | RoomShareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomShares.
     */
    cursor?: RoomShareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomShares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomShares.
     */
    skip?: number
    distinct?: RoomShareScalarFieldEnum | RoomShareScalarFieldEnum[]
  }

  /**
   * RoomShare create
   */
  export type RoomShareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomShare.
     */
    data: XOR<RoomShareCreateInput, RoomShareUncheckedCreateInput>
  }

  /**
   * RoomShare createMany
   */
  export type RoomShareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomShares.
     */
    data: RoomShareCreateManyInput | RoomShareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomShare createManyAndReturn
   */
  export type RoomShareCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * The data used to create many RoomShares.
     */
    data: RoomShareCreateManyInput | RoomShareCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomShare update
   */
  export type RoomShareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomShare.
     */
    data: XOR<RoomShareUpdateInput, RoomShareUncheckedUpdateInput>
    /**
     * Choose, which RoomShare to update.
     */
    where: RoomShareWhereUniqueInput
  }

  /**
   * RoomShare updateMany
   */
  export type RoomShareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomShares.
     */
    data: XOR<RoomShareUpdateManyMutationInput, RoomShareUncheckedUpdateManyInput>
    /**
     * Filter which RoomShares to update
     */
    where?: RoomShareWhereInput
    /**
     * Limit how many RoomShares to update.
     */
    limit?: number
  }

  /**
   * RoomShare updateManyAndReturn
   */
  export type RoomShareUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * The data used to update RoomShares.
     */
    data: XOR<RoomShareUpdateManyMutationInput, RoomShareUncheckedUpdateManyInput>
    /**
     * Filter which RoomShares to update
     */
    where?: RoomShareWhereInput
    /**
     * Limit how many RoomShares to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomShare upsert
   */
  export type RoomShareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomShare to update in case it exists.
     */
    where: RoomShareWhereUniqueInput
    /**
     * In case the RoomShare found by the `where` argument doesn't exist, create a new RoomShare with this data.
     */
    create: XOR<RoomShareCreateInput, RoomShareUncheckedCreateInput>
    /**
     * In case the RoomShare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomShareUpdateInput, RoomShareUncheckedUpdateInput>
  }

  /**
   * RoomShare delete
   */
  export type RoomShareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
    /**
     * Filter which RoomShare to delete.
     */
    where: RoomShareWhereUniqueInput
  }

  /**
   * RoomShare deleteMany
   */
  export type RoomShareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomShares to delete
     */
    where?: RoomShareWhereInput
    /**
     * Limit how many RoomShares to delete.
     */
    limit?: number
  }

  /**
   * RoomShare.notes
   */
  export type RoomShare$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    where?: RoomNoteWhereInput
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    cursor?: RoomNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomNoteScalarFieldEnum | RoomNoteScalarFieldEnum[]
  }

  /**
   * RoomShare without action
   */
  export type RoomShareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomShare
     */
    select?: RoomShareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomShare
     */
    omit?: RoomShareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomShareInclude<ExtArgs> | null
  }


  /**
   * Model RoomNote
   */

  export type AggregateRoomNote = {
    _count: RoomNoteCountAggregateOutputType | null
    _min: RoomNoteMinAggregateOutputType | null
    _max: RoomNoteMaxAggregateOutputType | null
  }

  export type RoomNoteMinAggregateOutputType = {
    id: string | null
    shareId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomNoteMaxAggregateOutputType = {
    id: string | null
    shareId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomNoteCountAggregateOutputType = {
    id: number
    shareId: number
    authorId: number
    content: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomNoteMinAggregateInputType = {
    id?: true
    shareId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomNoteMaxAggregateInputType = {
    id?: true
    shareId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomNoteCountAggregateInputType = {
    id?: true
    shareId?: true
    authorId?: true
    content?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomNote to aggregate.
     */
    where?: RoomNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomNotes to fetch.
     */
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomNotes
    **/
    _count?: true | RoomNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomNoteMaxAggregateInputType
  }

  export type GetRoomNoteAggregateType<T extends RoomNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomNote[P]>
      : GetScalarType<T[P], AggregateRoomNote[P]>
  }




  export type RoomNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomNoteWhereInput
    orderBy?: RoomNoteOrderByWithAggregationInput | RoomNoteOrderByWithAggregationInput[]
    by: RoomNoteScalarFieldEnum[] | RoomNoteScalarFieldEnum
    having?: RoomNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomNoteCountAggregateInputType | true
    _min?: RoomNoteMinAggregateInputType
    _max?: RoomNoteMaxAggregateInputType
  }

  export type RoomNoteGroupByOutputType = {
    id: string
    shareId: string
    authorId: string
    content: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RoomNoteCountAggregateOutputType | null
    _min: RoomNoteMinAggregateOutputType | null
    _max: RoomNoteMaxAggregateOutputType | null
  }

  type GetRoomNoteGroupByPayload<T extends RoomNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomNoteGroupByOutputType[P]>
            : GetScalarType<T[P], RoomNoteGroupByOutputType[P]>
        }
      >
    >


  export type RoomNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shareId?: boolean
    authorId?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomNote"]>

  export type RoomNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shareId?: boolean
    authorId?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomNote"]>

  export type RoomNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shareId?: boolean
    authorId?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomNote"]>

  export type RoomNoteSelectScalar = {
    id?: boolean
    shareId?: boolean
    authorId?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shareId" | "authorId" | "content" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["roomNote"]>
  export type RoomNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    share?: boolean | RoomShareDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomNote"
    objects: {
      share: Prisma.$RoomSharePayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shareId: string
      authorId: string
      content: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomNote"]>
    composites: {}
  }

  type RoomNoteGetPayload<S extends boolean | null | undefined | RoomNoteDefaultArgs> = $Result.GetResult<Prisma.$RoomNotePayload, S>

  type RoomNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomNoteCountAggregateInputType | true
    }

  export interface RoomNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomNote'], meta: { name: 'RoomNote' } }
    /**
     * Find zero or one RoomNote that matches the filter.
     * @param {RoomNoteFindUniqueArgs} args - Arguments to find a RoomNote
     * @example
     * // Get one RoomNote
     * const roomNote = await prisma.roomNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomNoteFindUniqueArgs>(args: SelectSubset<T, RoomNoteFindUniqueArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomNoteFindUniqueOrThrowArgs} args - Arguments to find a RoomNote
     * @example
     * // Get one RoomNote
     * const roomNote = await prisma.roomNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteFindFirstArgs} args - Arguments to find a RoomNote
     * @example
     * // Get one RoomNote
     * const roomNote = await prisma.roomNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomNoteFindFirstArgs>(args?: SelectSubset<T, RoomNoteFindFirstArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteFindFirstOrThrowArgs} args - Arguments to find a RoomNote
     * @example
     * // Get one RoomNote
     * const roomNote = await prisma.roomNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomNotes
     * const roomNotes = await prisma.roomNote.findMany()
     * 
     * // Get first 10 RoomNotes
     * const roomNotes = await prisma.roomNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomNoteWithIdOnly = await prisma.roomNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomNoteFindManyArgs>(args?: SelectSubset<T, RoomNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomNote.
     * @param {RoomNoteCreateArgs} args - Arguments to create a RoomNote.
     * @example
     * // Create one RoomNote
     * const RoomNote = await prisma.roomNote.create({
     *   data: {
     *     // ... data to create a RoomNote
     *   }
     * })
     * 
     */
    create<T extends RoomNoteCreateArgs>(args: SelectSubset<T, RoomNoteCreateArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomNotes.
     * @param {RoomNoteCreateManyArgs} args - Arguments to create many RoomNotes.
     * @example
     * // Create many RoomNotes
     * const roomNote = await prisma.roomNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomNoteCreateManyArgs>(args?: SelectSubset<T, RoomNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomNotes and returns the data saved in the database.
     * @param {RoomNoteCreateManyAndReturnArgs} args - Arguments to create many RoomNotes.
     * @example
     * // Create many RoomNotes
     * const roomNote = await prisma.roomNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomNotes and only return the `id`
     * const roomNoteWithIdOnly = await prisma.roomNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomNote.
     * @param {RoomNoteDeleteArgs} args - Arguments to delete one RoomNote.
     * @example
     * // Delete one RoomNote
     * const RoomNote = await prisma.roomNote.delete({
     *   where: {
     *     // ... filter to delete one RoomNote
     *   }
     * })
     * 
     */
    delete<T extends RoomNoteDeleteArgs>(args: SelectSubset<T, RoomNoteDeleteArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomNote.
     * @param {RoomNoteUpdateArgs} args - Arguments to update one RoomNote.
     * @example
     * // Update one RoomNote
     * const roomNote = await prisma.roomNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomNoteUpdateArgs>(args: SelectSubset<T, RoomNoteUpdateArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomNotes.
     * @param {RoomNoteDeleteManyArgs} args - Arguments to filter RoomNotes to delete.
     * @example
     * // Delete a few RoomNotes
     * const { count } = await prisma.roomNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomNoteDeleteManyArgs>(args?: SelectSubset<T, RoomNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomNotes
     * const roomNote = await prisma.roomNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomNoteUpdateManyArgs>(args: SelectSubset<T, RoomNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomNotes and returns the data updated in the database.
     * @param {RoomNoteUpdateManyAndReturnArgs} args - Arguments to update many RoomNotes.
     * @example
     * // Update many RoomNotes
     * const roomNote = await prisma.roomNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomNotes and only return the `id`
     * const roomNoteWithIdOnly = await prisma.roomNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomNote.
     * @param {RoomNoteUpsertArgs} args - Arguments to update or create a RoomNote.
     * @example
     * // Update or create a RoomNote
     * const roomNote = await prisma.roomNote.upsert({
     *   create: {
     *     // ... data to create a RoomNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomNote we want to update
     *   }
     * })
     */
    upsert<T extends RoomNoteUpsertArgs>(args: SelectSubset<T, RoomNoteUpsertArgs<ExtArgs>>): Prisma__RoomNoteClient<$Result.GetResult<Prisma.$RoomNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteCountArgs} args - Arguments to filter RoomNotes to count.
     * @example
     * // Count the number of RoomNotes
     * const count = await prisma.roomNote.count({
     *   where: {
     *     // ... the filter for the RoomNotes we want to count
     *   }
     * })
    **/
    count<T extends RoomNoteCountArgs>(
      args?: Subset<T, RoomNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomNoteAggregateArgs>(args: Subset<T, RoomNoteAggregateArgs>): Prisma.PrismaPromise<GetRoomNoteAggregateType<T>>

    /**
     * Group by RoomNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomNoteGroupByArgs['orderBy'] }
        : { orderBy?: RoomNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomNote model
   */
  readonly fields: RoomNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    share<T extends RoomShareDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomShareDefaultArgs<ExtArgs>>): Prisma__RoomShareClient<$Result.GetResult<Prisma.$RoomSharePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomNote model
   */
  interface RoomNoteFieldRefs {
    readonly id: FieldRef<"RoomNote", 'String'>
    readonly shareId: FieldRef<"RoomNote", 'String'>
    readonly authorId: FieldRef<"RoomNote", 'String'>
    readonly content: FieldRef<"RoomNote", 'String'>
    readonly metadata: FieldRef<"RoomNote", 'Json'>
    readonly createdAt: FieldRef<"RoomNote", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomNote findUnique
   */
  export type RoomNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter, which RoomNote to fetch.
     */
    where: RoomNoteWhereUniqueInput
  }

  /**
   * RoomNote findUniqueOrThrow
   */
  export type RoomNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter, which RoomNote to fetch.
     */
    where: RoomNoteWhereUniqueInput
  }

  /**
   * RoomNote findFirst
   */
  export type RoomNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter, which RoomNote to fetch.
     */
    where?: RoomNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomNotes to fetch.
     */
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomNotes.
     */
    cursor?: RoomNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomNotes.
     */
    distinct?: RoomNoteScalarFieldEnum | RoomNoteScalarFieldEnum[]
  }

  /**
   * RoomNote findFirstOrThrow
   */
  export type RoomNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter, which RoomNote to fetch.
     */
    where?: RoomNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomNotes to fetch.
     */
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomNotes.
     */
    cursor?: RoomNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomNotes.
     */
    distinct?: RoomNoteScalarFieldEnum | RoomNoteScalarFieldEnum[]
  }

  /**
   * RoomNote findMany
   */
  export type RoomNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter, which RoomNotes to fetch.
     */
    where?: RoomNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomNotes to fetch.
     */
    orderBy?: RoomNoteOrderByWithRelationInput | RoomNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomNotes.
     */
    cursor?: RoomNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomNotes.
     */
    skip?: number
    distinct?: RoomNoteScalarFieldEnum | RoomNoteScalarFieldEnum[]
  }

  /**
   * RoomNote create
   */
  export type RoomNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomNote.
     */
    data: XOR<RoomNoteCreateInput, RoomNoteUncheckedCreateInput>
  }

  /**
   * RoomNote createMany
   */
  export type RoomNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomNotes.
     */
    data: RoomNoteCreateManyInput | RoomNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomNote createManyAndReturn
   */
  export type RoomNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * The data used to create many RoomNotes.
     */
    data: RoomNoteCreateManyInput | RoomNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomNote update
   */
  export type RoomNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomNote.
     */
    data: XOR<RoomNoteUpdateInput, RoomNoteUncheckedUpdateInput>
    /**
     * Choose, which RoomNote to update.
     */
    where: RoomNoteWhereUniqueInput
  }

  /**
   * RoomNote updateMany
   */
  export type RoomNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomNotes.
     */
    data: XOR<RoomNoteUpdateManyMutationInput, RoomNoteUncheckedUpdateManyInput>
    /**
     * Filter which RoomNotes to update
     */
    where?: RoomNoteWhereInput
    /**
     * Limit how many RoomNotes to update.
     */
    limit?: number
  }

  /**
   * RoomNote updateManyAndReturn
   */
  export type RoomNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * The data used to update RoomNotes.
     */
    data: XOR<RoomNoteUpdateManyMutationInput, RoomNoteUncheckedUpdateManyInput>
    /**
     * Filter which RoomNotes to update
     */
    where?: RoomNoteWhereInput
    /**
     * Limit how many RoomNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomNote upsert
   */
  export type RoomNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomNote to update in case it exists.
     */
    where: RoomNoteWhereUniqueInput
    /**
     * In case the RoomNote found by the `where` argument doesn't exist, create a new RoomNote with this data.
     */
    create: XOR<RoomNoteCreateInput, RoomNoteUncheckedCreateInput>
    /**
     * In case the RoomNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomNoteUpdateInput, RoomNoteUncheckedUpdateInput>
  }

  /**
   * RoomNote delete
   */
  export type RoomNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
    /**
     * Filter which RoomNote to delete.
     */
    where: RoomNoteWhereUniqueInput
  }

  /**
   * RoomNote deleteMany
   */
  export type RoomNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomNotes to delete
     */
    where?: RoomNoteWhereInput
    /**
     * Limit how many RoomNotes to delete.
     */
    limit?: number
  }

  /**
   * RoomNote without action
   */
  export type RoomNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomNote
     */
    select?: RoomNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomNote
     */
    omit?: RoomNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomNoteInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    expiresAt: 'expiresAt',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    userId: 'userId'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    providerId: 'providerId',
    userId: 'userId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    idToken: 'idToken',
    accessTokenExpiresAt: 'accessTokenExpiresAt',
    refreshTokenExpiresAt: 'refreshTokenExpiresAt',
    scope: 'scope',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const VerificationScalarFieldEnum: {
    id: 'id',
    identifier: 'identifier',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VerificationScalarFieldEnum = (typeof VerificationScalarFieldEnum)[keyof typeof VerificationScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    name: 'name',
    color: 'color',
    emoji: 'emoji',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const LectureScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    folderId: 'folderId',
    title: 'title',
    description: 'description',
    language: 'language',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LectureScalarFieldEnum = (typeof LectureScalarFieldEnum)[keyof typeof LectureScalarFieldEnum]


  export const LectureSourceScalarFieldEnum: {
    id: 'id',
    lectureId: 'lectureId',
    kind: 'kind',
    title: 'title',
    url: 'url',
    fileKey: 'fileKey',
    textContent: 'textContent',
    transcript: 'transcript',
    language: 'language',
    durationSeconds: 'durationSeconds',
    pageCount: 'pageCount',
    checksum: 'checksum',
    status: 'status',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LectureSourceScalarFieldEnum = (typeof LectureSourceScalarFieldEnum)[keyof typeof LectureSourceScalarFieldEnum]


  export const ContentArtifactScalarFieldEnum: {
    id: 'id',
    lectureId: 'lectureId',
    ownerId: 'ownerId',
    type: 'type',
    title: 'title',
    description: 'description',
    language: 'language',
    status: 'status',
    coverImageUrl: 'coverImageUrl',
    fileUrl: 'fileUrl',
    transcript: 'transcript',
    durationSeconds: 'durationSeconds',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentArtifactScalarFieldEnum = (typeof ContentArtifactScalarFieldEnum)[keyof typeof ContentArtifactScalarFieldEnum]


  export const ArtifactSourceScalarFieldEnum: {
    artifactId: 'artifactId',
    sourceId: 'sourceId'
  };

  export type ArtifactSourceScalarFieldEnum = (typeof ArtifactSourceScalarFieldEnum)[keyof typeof ArtifactSourceScalarFieldEnum]


  export const QAPairScalarFieldEnum: {
    id: 'id',
    artifactId: 'artifactId',
    question: 'question',
    answer: 'answer',
    choices: 'choices',
    correctKey: 'correctKey',
    difficulty: 'difficulty',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QAPairScalarFieldEnum = (typeof QAPairScalarFieldEnum)[keyof typeof QAPairScalarFieldEnum]


  export const FlashcardScalarFieldEnum: {
    id: 'id',
    artifactId: 'artifactId',
    front: 'front',
    back: 'back',
    hint: 'hint',
    tags: 'tags',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlashcardScalarFieldEnum = (typeof FlashcardScalarFieldEnum)[keyof typeof FlashcardScalarFieldEnum]


  export const LectureAssistantScalarFieldEnum: {
    id: 'id',
    lectureId: 'lectureId',
    displayName: 'displayName',
    systemPrompt: 'systemPrompt',
    model: 'model',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LectureAssistantScalarFieldEnum = (typeof LectureAssistantScalarFieldEnum)[keyof typeof LectureAssistantScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    assistantId: 'assistantId',
    role: 'role',
    content: 'content',
    toolName: 'toolName',
    model: 'model',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const BookmarkScalarFieldEnum: {
    userId: 'userId',
    lectureId: 'lectureId',
    createdAt: 'createdAt'
  };

  export type BookmarkScalarFieldEnum = (typeof BookmarkScalarFieldEnum)[keyof typeof BookmarkScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    ownerId: 'ownerId',
    isPrivate: 'isPrivate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomMembershipScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    invitedById: 'invitedById',
    role: 'role',
    status: 'status',
    joinedAt: 'joinedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomMembershipScalarFieldEnum = (typeof RoomMembershipScalarFieldEnum)[keyof typeof RoomMembershipScalarFieldEnum]


  export const RoomShareScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    artifactId: 'artifactId',
    sharedById: 'sharedById',
    caption: 'caption',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomShareScalarFieldEnum = (typeof RoomShareScalarFieldEnum)[keyof typeof RoomShareScalarFieldEnum]


  export const RoomNoteScalarFieldEnum: {
    id: 'id',
    shareId: 'shareId',
    authorId: 'authorId',
    content: 'content',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomNoteScalarFieldEnum = (typeof RoomNoteScalarFieldEnum)[keyof typeof RoomNoteScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'SourceType'
   */
  export type EnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType'>
    


  /**
   * Reference to a field of type 'SourceType[]'
   */
  export type ListEnumSourceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SourceType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ProcessingStatus'
   */
  export type EnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus'>
    


  /**
   * Reference to a field of type 'ProcessingStatus[]'
   */
  export type ListEnumProcessingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProcessingStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ArtifactType'
   */
  export type EnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType'>
    


  /**
   * Reference to a field of type 'ArtifactType[]'
   */
  export type ListEnumArtifactTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ArtifactType[]'>
    


  /**
   * Reference to a field of type 'ChatRole'
   */
  export type EnumChatRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRole'>
    


  /**
   * Reference to a field of type 'ChatRole[]'
   */
  export type ListEnumChatRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChatRole[]'>
    


  /**
   * Reference to a field of type 'MemberRole'
   */
  export type EnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole'>
    


  /**
   * Reference to a field of type 'MemberRole[]'
   */
  export type ListEnumMemberRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberRole[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    folders?: FolderListRelationFilter
    lectures?: LectureListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    ownedRooms?: RoomListRelationFilter
    roomMemberships?: RoomMembershipListRelationFilter
    invitationsSent?: RoomMembershipListRelationFilter
    artifacts?: ContentArtifactListRelationFilter
    roomShares?: RoomShareListRelationFilter
    roomNotes?: RoomNoteListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    accounts?: AccountOrderByRelationAggregateInput
    folders?: FolderOrderByRelationAggregateInput
    lectures?: LectureOrderByRelationAggregateInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
    ownedRooms?: RoomOrderByRelationAggregateInput
    roomMemberships?: RoomMembershipOrderByRelationAggregateInput
    invitationsSent?: RoomMembershipOrderByRelationAggregateInput
    artifacts?: ContentArtifactOrderByRelationAggregateInput
    roomShares?: RoomShareOrderByRelationAggregateInput
    roomNotes?: RoomNoteOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    emailVerified?: BoolFilter<"User"> | boolean
    image?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    sessions?: SessionListRelationFilter
    accounts?: AccountListRelationFilter
    folders?: FolderListRelationFilter
    lectures?: LectureListRelationFilter
    bookmarks?: BookmarkListRelationFilter
    ownedRooms?: RoomListRelationFilter
    roomMemberships?: RoomMembershipListRelationFilter
    invitationsSent?: RoomMembershipListRelationFilter
    artifacts?: ContentArtifactListRelationFilter
    roomShares?: RoomShareListRelationFilter
    roomNotes?: RoomNoteListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    token?: StringWithAggregatesFilter<"Session"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    userId?: StringWithAggregatesFilter<"Session"> | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    idToken?: SortOrderInput | SortOrder
    accessTokenExpiresAt?: SortOrderInput | SortOrder
    refreshTokenExpiresAt?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    accountId?: StringWithAggregatesFilter<"Account"> | string
    providerId?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    accessToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    idToken?: StringNullableWithAggregatesFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    password?: StringNullableWithAggregatesFilter<"Account"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type VerificationWhereInput = {
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    id?: StringFilter<"Verification"> | string
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }

  export type VerificationOrderByWithRelationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
  }

  export type VerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VerificationWhereInput | VerificationWhereInput[]
    OR?: VerificationWhereInput[]
    NOT?: VerificationWhereInput | VerificationWhereInput[]
    identifier?: StringFilter<"Verification"> | string
    value?: StringFilter<"Verification"> | string
    expiresAt?: DateTimeFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableFilter<"Verification"> | Date | string | null
  }, "id">

  export type VerificationOrderByWithAggregationInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedAt?: SortOrderInput | SortOrder
    _count?: VerificationCountOrderByAggregateInput
    _max?: VerificationMaxOrderByAggregateInput
    _min?: VerificationMinOrderByAggregateInput
  }

  export type VerificationScalarWhereWithAggregatesInput = {
    AND?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    OR?: VerificationScalarWhereWithAggregatesInput[]
    NOT?: VerificationScalarWhereWithAggregatesInput | VerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Verification"> | string
    identifier?: StringWithAggregatesFilter<"Verification"> | string
    value?: StringWithAggregatesFilter<"Verification"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Verification"> | Date | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
    updatedAt?: DateTimeNullableWithAggregatesFilter<"Verification"> | Date | string | null
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    ownerId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    color?: StringNullableFilter<"Folder"> | string | null
    emoji?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    lectures?: LectureListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    lectures?: LectureOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    ownerId_name?: FolderOwnerIdNameCompoundUniqueInput
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    ownerId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    color?: StringNullableFilter<"Folder"> | string | null
    emoji?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    lectures?: LectureListRelationFilter
  }, "id" | "ownerId_name">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    ownerId?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    color?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    emoji?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
  }

  export type LectureWhereInput = {
    AND?: LectureWhereInput | LectureWhereInput[]
    OR?: LectureWhereInput[]
    NOT?: LectureWhereInput | LectureWhereInput[]
    id?: StringFilter<"Lecture"> | string
    ownerId?: StringFilter<"Lecture"> | string
    folderId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    description?: StringNullableFilter<"Lecture"> | string | null
    language?: StringNullableFilter<"Lecture"> | string | null
    createdAt?: DateTimeFilter<"Lecture"> | Date | string
    updatedAt?: DateTimeFilter<"Lecture"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    sources?: LectureSourceListRelationFilter
    artifacts?: ContentArtifactListRelationFilter
    assistant?: XOR<LectureAssistantNullableScalarRelationFilter, LectureAssistantWhereInput> | null
    bookmarks?: BookmarkListRelationFilter
  }

  export type LectureOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    folderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    sources?: LectureSourceOrderByRelationAggregateInput
    artifacts?: ContentArtifactOrderByRelationAggregateInput
    assistant?: LectureAssistantOrderByWithRelationInput
    bookmarks?: BookmarkOrderByRelationAggregateInput
  }

  export type LectureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LectureWhereInput | LectureWhereInput[]
    OR?: LectureWhereInput[]
    NOT?: LectureWhereInput | LectureWhereInput[]
    ownerId?: StringFilter<"Lecture"> | string
    folderId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    description?: StringNullableFilter<"Lecture"> | string | null
    language?: StringNullableFilter<"Lecture"> | string | null
    createdAt?: DateTimeFilter<"Lecture"> | Date | string
    updatedAt?: DateTimeFilter<"Lecture"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    sources?: LectureSourceListRelationFilter
    artifacts?: ContentArtifactListRelationFilter
    assistant?: XOR<LectureAssistantNullableScalarRelationFilter, LectureAssistantWhereInput> | null
    bookmarks?: BookmarkListRelationFilter
  }, "id">

  export type LectureOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    folderId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LectureCountOrderByAggregateInput
    _max?: LectureMaxOrderByAggregateInput
    _min?: LectureMinOrderByAggregateInput
  }

  export type LectureScalarWhereWithAggregatesInput = {
    AND?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[]
    OR?: LectureScalarWhereWithAggregatesInput[]
    NOT?: LectureScalarWhereWithAggregatesInput | LectureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lecture"> | string
    ownerId?: StringWithAggregatesFilter<"Lecture"> | string
    folderId?: StringWithAggregatesFilter<"Lecture"> | string
    title?: StringWithAggregatesFilter<"Lecture"> | string
    description?: StringNullableWithAggregatesFilter<"Lecture"> | string | null
    language?: StringNullableWithAggregatesFilter<"Lecture"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lecture"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lecture"> | Date | string
  }

  export type LectureSourceWhereInput = {
    AND?: LectureSourceWhereInput | LectureSourceWhereInput[]
    OR?: LectureSourceWhereInput[]
    NOT?: LectureSourceWhereInput | LectureSourceWhereInput[]
    id?: StringFilter<"LectureSource"> | string
    lectureId?: StringFilter<"LectureSource"> | string
    kind?: EnumSourceTypeFilter<"LectureSource"> | $Enums.SourceType
    title?: StringNullableFilter<"LectureSource"> | string | null
    url?: StringNullableFilter<"LectureSource"> | string | null
    fileKey?: StringNullableFilter<"LectureSource"> | string | null
    textContent?: StringNullableFilter<"LectureSource"> | string | null
    transcript?: StringNullableFilter<"LectureSource"> | string | null
    language?: StringNullableFilter<"LectureSource"> | string | null
    durationSeconds?: IntNullableFilter<"LectureSource"> | number | null
    pageCount?: IntNullableFilter<"LectureSource"> | number | null
    checksum?: StringNullableFilter<"LectureSource"> | string | null
    status?: EnumProcessingStatusFilter<"LectureSource"> | $Enums.ProcessingStatus
    metadata?: JsonNullableFilter<"LectureSource">
    createdAt?: DateTimeFilter<"LectureSource"> | Date | string
    updatedAt?: DateTimeFilter<"LectureSource"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    artifacts?: ArtifactSourceListRelationFilter
  }

  export type LectureSourceOrderByWithRelationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    kind?: SortOrder
    title?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    fileKey?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    pageCount?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lecture?: LectureOrderByWithRelationInput
    artifacts?: ArtifactSourceOrderByRelationAggregateInput
  }

  export type LectureSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LectureSourceWhereInput | LectureSourceWhereInput[]
    OR?: LectureSourceWhereInput[]
    NOT?: LectureSourceWhereInput | LectureSourceWhereInput[]
    lectureId?: StringFilter<"LectureSource"> | string
    kind?: EnumSourceTypeFilter<"LectureSource"> | $Enums.SourceType
    title?: StringNullableFilter<"LectureSource"> | string | null
    url?: StringNullableFilter<"LectureSource"> | string | null
    fileKey?: StringNullableFilter<"LectureSource"> | string | null
    textContent?: StringNullableFilter<"LectureSource"> | string | null
    transcript?: StringNullableFilter<"LectureSource"> | string | null
    language?: StringNullableFilter<"LectureSource"> | string | null
    durationSeconds?: IntNullableFilter<"LectureSource"> | number | null
    pageCount?: IntNullableFilter<"LectureSource"> | number | null
    checksum?: StringNullableFilter<"LectureSource"> | string | null
    status?: EnumProcessingStatusFilter<"LectureSource"> | $Enums.ProcessingStatus
    metadata?: JsonNullableFilter<"LectureSource">
    createdAt?: DateTimeFilter<"LectureSource"> | Date | string
    updatedAt?: DateTimeFilter<"LectureSource"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    artifacts?: ArtifactSourceListRelationFilter
  }, "id">

  export type LectureSourceOrderByWithAggregationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    kind?: SortOrder
    title?: SortOrderInput | SortOrder
    url?: SortOrderInput | SortOrder
    fileKey?: SortOrderInput | SortOrder
    textContent?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    pageCount?: SortOrderInput | SortOrder
    checksum?: SortOrderInput | SortOrder
    status?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LectureSourceCountOrderByAggregateInput
    _avg?: LectureSourceAvgOrderByAggregateInput
    _max?: LectureSourceMaxOrderByAggregateInput
    _min?: LectureSourceMinOrderByAggregateInput
    _sum?: LectureSourceSumOrderByAggregateInput
  }

  export type LectureSourceScalarWhereWithAggregatesInput = {
    AND?: LectureSourceScalarWhereWithAggregatesInput | LectureSourceScalarWhereWithAggregatesInput[]
    OR?: LectureSourceScalarWhereWithAggregatesInput[]
    NOT?: LectureSourceScalarWhereWithAggregatesInput | LectureSourceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LectureSource"> | string
    lectureId?: StringWithAggregatesFilter<"LectureSource"> | string
    kind?: EnumSourceTypeWithAggregatesFilter<"LectureSource"> | $Enums.SourceType
    title?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    url?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    fileKey?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    textContent?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    language?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"LectureSource"> | number | null
    pageCount?: IntNullableWithAggregatesFilter<"LectureSource"> | number | null
    checksum?: StringNullableWithAggregatesFilter<"LectureSource"> | string | null
    status?: EnumProcessingStatusWithAggregatesFilter<"LectureSource"> | $Enums.ProcessingStatus
    metadata?: JsonNullableWithAggregatesFilter<"LectureSource">
    createdAt?: DateTimeWithAggregatesFilter<"LectureSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LectureSource"> | Date | string
  }

  export type ContentArtifactWhereInput = {
    AND?: ContentArtifactWhereInput | ContentArtifactWhereInput[]
    OR?: ContentArtifactWhereInput[]
    NOT?: ContentArtifactWhereInput | ContentArtifactWhereInput[]
    id?: StringFilter<"ContentArtifact"> | string
    lectureId?: StringFilter<"ContentArtifact"> | string
    ownerId?: StringFilter<"ContentArtifact"> | string
    type?: EnumArtifactTypeFilter<"ContentArtifact"> | $Enums.ArtifactType
    title?: StringFilter<"ContentArtifact"> | string
    description?: StringNullableFilter<"ContentArtifact"> | string | null
    language?: StringNullableFilter<"ContentArtifact"> | string | null
    status?: EnumProcessingStatusFilter<"ContentArtifact"> | $Enums.ProcessingStatus
    coverImageUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    fileUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    transcript?: StringNullableFilter<"ContentArtifact"> | string | null
    durationSeconds?: IntNullableFilter<"ContentArtifact"> | number | null
    metadata?: JsonNullableFilter<"ContentArtifact">
    createdAt?: DateTimeFilter<"ContentArtifact"> | Date | string
    updatedAt?: DateTimeFilter<"ContentArtifact"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    qaPairs?: QAPairListRelationFilter
    flashcards?: FlashcardListRelationFilter
    shares?: RoomShareListRelationFilter
    sources?: ArtifactSourceListRelationFilter
  }

  export type ContentArtifactOrderByWithRelationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    status?: SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lecture?: LectureOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    qaPairs?: QAPairOrderByRelationAggregateInput
    flashcards?: FlashcardOrderByRelationAggregateInput
    shares?: RoomShareOrderByRelationAggregateInput
    sources?: ArtifactSourceOrderByRelationAggregateInput
  }

  export type ContentArtifactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContentArtifactWhereInput | ContentArtifactWhereInput[]
    OR?: ContentArtifactWhereInput[]
    NOT?: ContentArtifactWhereInput | ContentArtifactWhereInput[]
    lectureId?: StringFilter<"ContentArtifact"> | string
    ownerId?: StringFilter<"ContentArtifact"> | string
    type?: EnumArtifactTypeFilter<"ContentArtifact"> | $Enums.ArtifactType
    title?: StringFilter<"ContentArtifact"> | string
    description?: StringNullableFilter<"ContentArtifact"> | string | null
    language?: StringNullableFilter<"ContentArtifact"> | string | null
    status?: EnumProcessingStatusFilter<"ContentArtifact"> | $Enums.ProcessingStatus
    coverImageUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    fileUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    transcript?: StringNullableFilter<"ContentArtifact"> | string | null
    durationSeconds?: IntNullableFilter<"ContentArtifact"> | number | null
    metadata?: JsonNullableFilter<"ContentArtifact">
    createdAt?: DateTimeFilter<"ContentArtifact"> | Date | string
    updatedAt?: DateTimeFilter<"ContentArtifact"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    qaPairs?: QAPairListRelationFilter
    flashcards?: FlashcardListRelationFilter
    shares?: RoomShareListRelationFilter
    sources?: ArtifactSourceListRelationFilter
  }, "id">

  export type ContentArtifactOrderByWithAggregationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    status?: SortOrder
    coverImageUrl?: SortOrderInput | SortOrder
    fileUrl?: SortOrderInput | SortOrder
    transcript?: SortOrderInput | SortOrder
    durationSeconds?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentArtifactCountOrderByAggregateInput
    _avg?: ContentArtifactAvgOrderByAggregateInput
    _max?: ContentArtifactMaxOrderByAggregateInput
    _min?: ContentArtifactMinOrderByAggregateInput
    _sum?: ContentArtifactSumOrderByAggregateInput
  }

  export type ContentArtifactScalarWhereWithAggregatesInput = {
    AND?: ContentArtifactScalarWhereWithAggregatesInput | ContentArtifactScalarWhereWithAggregatesInput[]
    OR?: ContentArtifactScalarWhereWithAggregatesInput[]
    NOT?: ContentArtifactScalarWhereWithAggregatesInput | ContentArtifactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentArtifact"> | string
    lectureId?: StringWithAggregatesFilter<"ContentArtifact"> | string
    ownerId?: StringWithAggregatesFilter<"ContentArtifact"> | string
    type?: EnumArtifactTypeWithAggregatesFilter<"ContentArtifact"> | $Enums.ArtifactType
    title?: StringWithAggregatesFilter<"ContentArtifact"> | string
    description?: StringNullableWithAggregatesFilter<"ContentArtifact"> | string | null
    language?: StringNullableWithAggregatesFilter<"ContentArtifact"> | string | null
    status?: EnumProcessingStatusWithAggregatesFilter<"ContentArtifact"> | $Enums.ProcessingStatus
    coverImageUrl?: StringNullableWithAggregatesFilter<"ContentArtifact"> | string | null
    fileUrl?: StringNullableWithAggregatesFilter<"ContentArtifact"> | string | null
    transcript?: StringNullableWithAggregatesFilter<"ContentArtifact"> | string | null
    durationSeconds?: IntNullableWithAggregatesFilter<"ContentArtifact"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"ContentArtifact">
    createdAt?: DateTimeWithAggregatesFilter<"ContentArtifact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentArtifact"> | Date | string
  }

  export type ArtifactSourceWhereInput = {
    AND?: ArtifactSourceWhereInput | ArtifactSourceWhereInput[]
    OR?: ArtifactSourceWhereInput[]
    NOT?: ArtifactSourceWhereInput | ArtifactSourceWhereInput[]
    artifactId?: StringFilter<"ArtifactSource"> | string
    sourceId?: StringFilter<"ArtifactSource"> | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
    source?: XOR<LectureSourceScalarRelationFilter, LectureSourceWhereInput>
  }

  export type ArtifactSourceOrderByWithRelationInput = {
    artifactId?: SortOrder
    sourceId?: SortOrder
    artifact?: ContentArtifactOrderByWithRelationInput
    source?: LectureSourceOrderByWithRelationInput
  }

  export type ArtifactSourceWhereUniqueInput = Prisma.AtLeast<{
    artifactId_sourceId?: ArtifactSourceArtifactIdSourceIdCompoundUniqueInput
    AND?: ArtifactSourceWhereInput | ArtifactSourceWhereInput[]
    OR?: ArtifactSourceWhereInput[]
    NOT?: ArtifactSourceWhereInput | ArtifactSourceWhereInput[]
    artifactId?: StringFilter<"ArtifactSource"> | string
    sourceId?: StringFilter<"ArtifactSource"> | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
    source?: XOR<LectureSourceScalarRelationFilter, LectureSourceWhereInput>
  }, "artifactId_sourceId">

  export type ArtifactSourceOrderByWithAggregationInput = {
    artifactId?: SortOrder
    sourceId?: SortOrder
    _count?: ArtifactSourceCountOrderByAggregateInput
    _max?: ArtifactSourceMaxOrderByAggregateInput
    _min?: ArtifactSourceMinOrderByAggregateInput
  }

  export type ArtifactSourceScalarWhereWithAggregatesInput = {
    AND?: ArtifactSourceScalarWhereWithAggregatesInput | ArtifactSourceScalarWhereWithAggregatesInput[]
    OR?: ArtifactSourceScalarWhereWithAggregatesInput[]
    NOT?: ArtifactSourceScalarWhereWithAggregatesInput | ArtifactSourceScalarWhereWithAggregatesInput[]
    artifactId?: StringWithAggregatesFilter<"ArtifactSource"> | string
    sourceId?: StringWithAggregatesFilter<"ArtifactSource"> | string
  }

  export type QAPairWhereInput = {
    AND?: QAPairWhereInput | QAPairWhereInput[]
    OR?: QAPairWhereInput[]
    NOT?: QAPairWhereInput | QAPairWhereInput[]
    id?: StringFilter<"QAPair"> | string
    artifactId?: StringFilter<"QAPair"> | string
    question?: StringFilter<"QAPair"> | string
    answer?: StringFilter<"QAPair"> | string
    choices?: JsonNullableFilter<"QAPair">
    correctKey?: StringNullableFilter<"QAPair"> | string | null
    difficulty?: IntNullableFilter<"QAPair"> | number | null
    tags?: StringNullableListFilter<"QAPair">
    metadata?: JsonNullableFilter<"QAPair">
    createdAt?: DateTimeFilter<"QAPair"> | Date | string
    updatedAt?: DateTimeFilter<"QAPair"> | Date | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
  }

  export type QAPairOrderByWithRelationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    choices?: SortOrderInput | SortOrder
    correctKey?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artifact?: ContentArtifactOrderByWithRelationInput
  }

  export type QAPairWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QAPairWhereInput | QAPairWhereInput[]
    OR?: QAPairWhereInput[]
    NOT?: QAPairWhereInput | QAPairWhereInput[]
    artifactId?: StringFilter<"QAPair"> | string
    question?: StringFilter<"QAPair"> | string
    answer?: StringFilter<"QAPair"> | string
    choices?: JsonNullableFilter<"QAPair">
    correctKey?: StringNullableFilter<"QAPair"> | string | null
    difficulty?: IntNullableFilter<"QAPair"> | number | null
    tags?: StringNullableListFilter<"QAPair">
    metadata?: JsonNullableFilter<"QAPair">
    createdAt?: DateTimeFilter<"QAPair"> | Date | string
    updatedAt?: DateTimeFilter<"QAPair"> | Date | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
  }, "id">

  export type QAPairOrderByWithAggregationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    choices?: SortOrderInput | SortOrder
    correctKey?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QAPairCountOrderByAggregateInput
    _avg?: QAPairAvgOrderByAggregateInput
    _max?: QAPairMaxOrderByAggregateInput
    _min?: QAPairMinOrderByAggregateInput
    _sum?: QAPairSumOrderByAggregateInput
  }

  export type QAPairScalarWhereWithAggregatesInput = {
    AND?: QAPairScalarWhereWithAggregatesInput | QAPairScalarWhereWithAggregatesInput[]
    OR?: QAPairScalarWhereWithAggregatesInput[]
    NOT?: QAPairScalarWhereWithAggregatesInput | QAPairScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QAPair"> | string
    artifactId?: StringWithAggregatesFilter<"QAPair"> | string
    question?: StringWithAggregatesFilter<"QAPair"> | string
    answer?: StringWithAggregatesFilter<"QAPair"> | string
    choices?: JsonNullableWithAggregatesFilter<"QAPair">
    correctKey?: StringNullableWithAggregatesFilter<"QAPair"> | string | null
    difficulty?: IntNullableWithAggregatesFilter<"QAPair"> | number | null
    tags?: StringNullableListFilter<"QAPair">
    metadata?: JsonNullableWithAggregatesFilter<"QAPair">
    createdAt?: DateTimeWithAggregatesFilter<"QAPair"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QAPair"> | Date | string
  }

  export type FlashcardWhereInput = {
    AND?: FlashcardWhereInput | FlashcardWhereInput[]
    OR?: FlashcardWhereInput[]
    NOT?: FlashcardWhereInput | FlashcardWhereInput[]
    id?: StringFilter<"Flashcard"> | string
    artifactId?: StringFilter<"Flashcard"> | string
    front?: StringFilter<"Flashcard"> | string
    back?: StringFilter<"Flashcard"> | string
    hint?: StringNullableFilter<"Flashcard"> | string | null
    tags?: StringNullableListFilter<"Flashcard">
    metadata?: JsonNullableFilter<"Flashcard">
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    updatedAt?: DateTimeFilter<"Flashcard"> | Date | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
  }

  export type FlashcardOrderByWithRelationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    hint?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    artifact?: ContentArtifactOrderByWithRelationInput
  }

  export type FlashcardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlashcardWhereInput | FlashcardWhereInput[]
    OR?: FlashcardWhereInput[]
    NOT?: FlashcardWhereInput | FlashcardWhereInput[]
    artifactId?: StringFilter<"Flashcard"> | string
    front?: StringFilter<"Flashcard"> | string
    back?: StringFilter<"Flashcard"> | string
    hint?: StringNullableFilter<"Flashcard"> | string | null
    tags?: StringNullableListFilter<"Flashcard">
    metadata?: JsonNullableFilter<"Flashcard">
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    updatedAt?: DateTimeFilter<"Flashcard"> | Date | string
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
  }, "id">

  export type FlashcardOrderByWithAggregationInput = {
    id?: SortOrder
    artifactId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    hint?: SortOrderInput | SortOrder
    tags?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlashcardCountOrderByAggregateInput
    _max?: FlashcardMaxOrderByAggregateInput
    _min?: FlashcardMinOrderByAggregateInput
  }

  export type FlashcardScalarWhereWithAggregatesInput = {
    AND?: FlashcardScalarWhereWithAggregatesInput | FlashcardScalarWhereWithAggregatesInput[]
    OR?: FlashcardScalarWhereWithAggregatesInput[]
    NOT?: FlashcardScalarWhereWithAggregatesInput | FlashcardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flashcard"> | string
    artifactId?: StringWithAggregatesFilter<"Flashcard"> | string
    front?: StringWithAggregatesFilter<"Flashcard"> | string
    back?: StringWithAggregatesFilter<"Flashcard"> | string
    hint?: StringNullableWithAggregatesFilter<"Flashcard"> | string | null
    tags?: StringNullableListFilter<"Flashcard">
    metadata?: JsonNullableWithAggregatesFilter<"Flashcard">
    createdAt?: DateTimeWithAggregatesFilter<"Flashcard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flashcard"> | Date | string
  }

  export type LectureAssistantWhereInput = {
    AND?: LectureAssistantWhereInput | LectureAssistantWhereInput[]
    OR?: LectureAssistantWhereInput[]
    NOT?: LectureAssistantWhereInput | LectureAssistantWhereInput[]
    id?: StringFilter<"LectureAssistant"> | string
    lectureId?: StringFilter<"LectureAssistant"> | string
    displayName?: StringNullableFilter<"LectureAssistant"> | string | null
    systemPrompt?: StringNullableFilter<"LectureAssistant"> | string | null
    model?: StringNullableFilter<"LectureAssistant"> | string | null
    metadata?: JsonNullableFilter<"LectureAssistant">
    createdAt?: DateTimeFilter<"LectureAssistant"> | Date | string
    updatedAt?: DateTimeFilter<"LectureAssistant"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type LectureAssistantOrderByWithRelationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lecture?: LectureOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type LectureAssistantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lectureId?: string
    AND?: LectureAssistantWhereInput | LectureAssistantWhereInput[]
    OR?: LectureAssistantWhereInput[]
    NOT?: LectureAssistantWhereInput | LectureAssistantWhereInput[]
    displayName?: StringNullableFilter<"LectureAssistant"> | string | null
    systemPrompt?: StringNullableFilter<"LectureAssistant"> | string | null
    model?: StringNullableFilter<"LectureAssistant"> | string | null
    metadata?: JsonNullableFilter<"LectureAssistant">
    createdAt?: DateTimeFilter<"LectureAssistant"> | Date | string
    updatedAt?: DateTimeFilter<"LectureAssistant"> | Date | string
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id" | "lectureId">

  export type LectureAssistantOrderByWithAggregationInput = {
    id?: SortOrder
    lectureId?: SortOrder
    displayName?: SortOrderInput | SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LectureAssistantCountOrderByAggregateInput
    _max?: LectureAssistantMaxOrderByAggregateInput
    _min?: LectureAssistantMinOrderByAggregateInput
  }

  export type LectureAssistantScalarWhereWithAggregatesInput = {
    AND?: LectureAssistantScalarWhereWithAggregatesInput | LectureAssistantScalarWhereWithAggregatesInput[]
    OR?: LectureAssistantScalarWhereWithAggregatesInput[]
    NOT?: LectureAssistantScalarWhereWithAggregatesInput | LectureAssistantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LectureAssistant"> | string
    lectureId?: StringWithAggregatesFilter<"LectureAssistant"> | string
    displayName?: StringNullableWithAggregatesFilter<"LectureAssistant"> | string | null
    systemPrompt?: StringNullableWithAggregatesFilter<"LectureAssistant"> | string | null
    model?: StringNullableWithAggregatesFilter<"LectureAssistant"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"LectureAssistant">
    createdAt?: DateTimeWithAggregatesFilter<"LectureAssistant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LectureAssistant"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    assistantId?: StringFilter<"ChatMessage"> | string
    role?: EnumChatRoleFilter<"ChatMessage"> | $Enums.ChatRole
    content?: StringFilter<"ChatMessage"> | string
    toolName?: StringNullableFilter<"ChatMessage"> | string | null
    model?: StringNullableFilter<"ChatMessage"> | string | null
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    assistant?: XOR<LectureAssistantScalarRelationFilter, LectureAssistantWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    assistantId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assistant?: LectureAssistantOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    assistantId?: StringFilter<"ChatMessage"> | string
    role?: EnumChatRoleFilter<"ChatMessage"> | $Enums.ChatRole
    content?: StringFilter<"ChatMessage"> | string
    toolName?: StringNullableFilter<"ChatMessage"> | string | null
    model?: StringNullableFilter<"ChatMessage"> | string | null
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
    assistant?: XOR<LectureAssistantScalarRelationFilter, LectureAssistantWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    assistantId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    assistantId?: StringWithAggregatesFilter<"ChatMessage"> | string
    role?: EnumChatRoleWithAggregatesFilter<"ChatMessage"> | $Enums.ChatRole
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    toolName?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    model?: StringNullableWithAggregatesFilter<"ChatMessage"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ChatMessage">
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type BookmarkWhereInput = {
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    lectureId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
  }

  export type BookmarkOrderByWithRelationInput = {
    userId?: SortOrder
    lectureId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    lecture?: LectureOrderByWithRelationInput
  }

  export type BookmarkWhereUniqueInput = Prisma.AtLeast<{
    userId_lectureId?: BookmarkUserIdLectureIdCompoundUniqueInput
    AND?: BookmarkWhereInput | BookmarkWhereInput[]
    OR?: BookmarkWhereInput[]
    NOT?: BookmarkWhereInput | BookmarkWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    lectureId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    lecture?: XOR<LectureScalarRelationFilter, LectureWhereInput>
  }, "userId_lectureId">

  export type BookmarkOrderByWithAggregationInput = {
    userId?: SortOrder
    lectureId?: SortOrder
    createdAt?: SortOrder
    _count?: BookmarkCountOrderByAggregateInput
    _max?: BookmarkMaxOrderByAggregateInput
    _min?: BookmarkMinOrderByAggregateInput
  }

  export type BookmarkScalarWhereWithAggregatesInput = {
    AND?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    OR?: BookmarkScalarWhereWithAggregatesInput[]
    NOT?: BookmarkScalarWhereWithAggregatesInput | BookmarkScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"Bookmark"> | string
    lectureId?: StringWithAggregatesFilter<"Bookmark"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Bookmark"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    description?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    isPrivate?: BoolNullableFilter<"Room"> | boolean | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    memberships?: RoomMembershipListRelationFilter
    shares?: RoomShareListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    isPrivate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    memberships?: RoomMembershipOrderByRelationAggregateInput
    shares?: RoomShareOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringFilter<"Room"> | string
    description?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    isPrivate?: BoolNullableFilter<"Room"> | boolean | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    memberships?: RoomMembershipListRelationFilter
    shares?: RoomShareListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    isPrivate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    description?: StringNullableWithAggregatesFilter<"Room"> | string | null
    ownerId?: StringWithAggregatesFilter<"Room"> | string
    isPrivate?: BoolNullableWithAggregatesFilter<"Room"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type RoomMembershipWhereInput = {
    AND?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    OR?: RoomMembershipWhereInput[]
    NOT?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    id?: StringFilter<"RoomMembership"> | string
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    invitedById?: StringNullableFilter<"RoomMembership"> | string | null
    role?: EnumMemberRoleFilter<"RoomMembership"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"RoomMembership"> | $Enums.MemberStatus
    joinedAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    invitedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RoomMembershipOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    invitedById?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invitedBy?: UserOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RoomMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_userId?: RoomMembershipRoomIdUserIdCompoundUniqueInput
    AND?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    OR?: RoomMembershipWhereInput[]
    NOT?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    invitedById?: StringNullableFilter<"RoomMembership"> | string | null
    role?: EnumMemberRoleFilter<"RoomMembership"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"RoomMembership"> | $Enums.MemberStatus
    joinedAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    invitedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "roomId_userId">

  export type RoomMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    invitedById?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomMembershipCountOrderByAggregateInput
    _max?: RoomMembershipMaxOrderByAggregateInput
    _min?: RoomMembershipMinOrderByAggregateInput
  }

  export type RoomMembershipScalarWhereWithAggregatesInput = {
    AND?: RoomMembershipScalarWhereWithAggregatesInput | RoomMembershipScalarWhereWithAggregatesInput[]
    OR?: RoomMembershipScalarWhereWithAggregatesInput[]
    NOT?: RoomMembershipScalarWhereWithAggregatesInput | RoomMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomMembership"> | string
    roomId?: StringWithAggregatesFilter<"RoomMembership"> | string
    userId?: StringWithAggregatesFilter<"RoomMembership"> | string
    invitedById?: StringNullableWithAggregatesFilter<"RoomMembership"> | string | null
    role?: EnumMemberRoleWithAggregatesFilter<"RoomMembership"> | $Enums.MemberRole
    status?: EnumMemberStatusWithAggregatesFilter<"RoomMembership"> | $Enums.MemberStatus
    joinedAt?: DateTimeNullableWithAggregatesFilter<"RoomMembership"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomMembership"> | Date | string
  }

  export type RoomShareWhereInput = {
    AND?: RoomShareWhereInput | RoomShareWhereInput[]
    OR?: RoomShareWhereInput[]
    NOT?: RoomShareWhereInput | RoomShareWhereInput[]
    id?: StringFilter<"RoomShare"> | string
    roomId?: StringFilter<"RoomShare"> | string
    artifactId?: StringFilter<"RoomShare"> | string
    sharedById?: StringFilter<"RoomShare"> | string
    caption?: StringNullableFilter<"RoomShare"> | string | null
    metadata?: JsonNullableFilter<"RoomShare">
    createdAt?: DateTimeFilter<"RoomShare"> | Date | string
    updatedAt?: DateTimeFilter<"RoomShare"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
    sharedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    notes?: RoomNoteListRelationFilter
  }

  export type RoomShareOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    artifactId?: SortOrder
    sharedById?: SortOrder
    caption?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
    artifact?: ContentArtifactOrderByWithRelationInput
    sharedBy?: UserOrderByWithRelationInput
    notes?: RoomNoteOrderByRelationAggregateInput
  }

  export type RoomShareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_artifactId_sharedById?: RoomShareRoomIdArtifactIdSharedByIdCompoundUniqueInput
    AND?: RoomShareWhereInput | RoomShareWhereInput[]
    OR?: RoomShareWhereInput[]
    NOT?: RoomShareWhereInput | RoomShareWhereInput[]
    roomId?: StringFilter<"RoomShare"> | string
    artifactId?: StringFilter<"RoomShare"> | string
    sharedById?: StringFilter<"RoomShare"> | string
    caption?: StringNullableFilter<"RoomShare"> | string | null
    metadata?: JsonNullableFilter<"RoomShare">
    createdAt?: DateTimeFilter<"RoomShare"> | Date | string
    updatedAt?: DateTimeFilter<"RoomShare"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
    artifact?: XOR<ContentArtifactScalarRelationFilter, ContentArtifactWhereInput>
    sharedBy?: XOR<UserScalarRelationFilter, UserWhereInput>
    notes?: RoomNoteListRelationFilter
  }, "id" | "roomId_artifactId_sharedById">

  export type RoomShareOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    artifactId?: SortOrder
    sharedById?: SortOrder
    caption?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomShareCountOrderByAggregateInput
    _max?: RoomShareMaxOrderByAggregateInput
    _min?: RoomShareMinOrderByAggregateInput
  }

  export type RoomShareScalarWhereWithAggregatesInput = {
    AND?: RoomShareScalarWhereWithAggregatesInput | RoomShareScalarWhereWithAggregatesInput[]
    OR?: RoomShareScalarWhereWithAggregatesInput[]
    NOT?: RoomShareScalarWhereWithAggregatesInput | RoomShareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomShare"> | string
    roomId?: StringWithAggregatesFilter<"RoomShare"> | string
    artifactId?: StringWithAggregatesFilter<"RoomShare"> | string
    sharedById?: StringWithAggregatesFilter<"RoomShare"> | string
    caption?: StringNullableWithAggregatesFilter<"RoomShare"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"RoomShare">
    createdAt?: DateTimeWithAggregatesFilter<"RoomShare"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomShare"> | Date | string
  }

  export type RoomNoteWhereInput = {
    AND?: RoomNoteWhereInput | RoomNoteWhereInput[]
    OR?: RoomNoteWhereInput[]
    NOT?: RoomNoteWhereInput | RoomNoteWhereInput[]
    id?: StringFilter<"RoomNote"> | string
    shareId?: StringFilter<"RoomNote"> | string
    authorId?: StringFilter<"RoomNote"> | string
    content?: StringFilter<"RoomNote"> | string
    metadata?: JsonNullableFilter<"RoomNote">
    createdAt?: DateTimeFilter<"RoomNote"> | Date | string
    updatedAt?: DateTimeFilter<"RoomNote"> | Date | string
    share?: XOR<RoomShareScalarRelationFilter, RoomShareWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type RoomNoteOrderByWithRelationInput = {
    id?: SortOrder
    shareId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    share?: RoomShareOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type RoomNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomNoteWhereInput | RoomNoteWhereInput[]
    OR?: RoomNoteWhereInput[]
    NOT?: RoomNoteWhereInput | RoomNoteWhereInput[]
    shareId?: StringFilter<"RoomNote"> | string
    authorId?: StringFilter<"RoomNote"> | string
    content?: StringFilter<"RoomNote"> | string
    metadata?: JsonNullableFilter<"RoomNote">
    createdAt?: DateTimeFilter<"RoomNote"> | Date | string
    updatedAt?: DateTimeFilter<"RoomNote"> | Date | string
    share?: XOR<RoomShareScalarRelationFilter, RoomShareWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type RoomNoteOrderByWithAggregationInput = {
    id?: SortOrder
    shareId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomNoteCountOrderByAggregateInput
    _max?: RoomNoteMaxOrderByAggregateInput
    _min?: RoomNoteMinOrderByAggregateInput
  }

  export type RoomNoteScalarWhereWithAggregatesInput = {
    AND?: RoomNoteScalarWhereWithAggregatesInput | RoomNoteScalarWhereWithAggregatesInput[]
    OR?: RoomNoteScalarWhereWithAggregatesInput[]
    NOT?: RoomNoteScalarWhereWithAggregatesInput | RoomNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomNote"> | string
    shareId?: StringWithAggregatesFilter<"RoomNote"> | string
    authorId?: StringWithAggregatesFilter<"RoomNote"> | string
    content?: StringWithAggregatesFilter<"RoomNote"> | string
    metadata?: JsonNullableWithAggregatesFilter<"RoomNote">
    createdAt?: DateTimeWithAggregatesFilter<"RoomNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomNote"> | Date | string
  }

  export type UserCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type SessionCreateManyInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    userId: string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyInput = {
    id: string
    accountId: string
    providerId: string
    userId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUncheckedCreateInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationCreateManyInput = {
    id: string
    identifier: string
    value: string
    expiresAt: Date | string
    createdAt?: Date | string | null
    updatedAt?: Date | string | null
  }

  export type VerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type VerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    identifier?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FolderCreateInput = {
    id: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutFoldersInput
    lectures?: LectureCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id: string
    ownerId: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFoldersNestedInput
    lectures?: LectureUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id: string
    ownerId: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureCreateInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    folder: FolderCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureCreateManyInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureSourceCreateInput = {
    id: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutSourcesInput
    artifacts?: ArtifactSourceCreateNestedManyWithoutSourceInput
  }

  export type LectureSourceUncheckedCreateInput = {
    id: string
    lectureId: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifacts?: ArtifactSourceUncheckedCreateNestedManyWithoutSourceInput
  }

  export type LectureSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutSourcesNestedInput
    artifacts?: ArtifactSourceUpdateManyWithoutSourceNestedInput
  }

  export type LectureSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactSourceUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type LectureSourceCreateManyInput = {
    id: string
    lectureId: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentArtifactCreateInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    owner: UserCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactCreateManyInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ContentArtifactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentArtifactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactSourceCreateInput = {
    artifact: ContentArtifactCreateNestedOneWithoutSourcesInput
    source: LectureSourceCreateNestedOneWithoutArtifactsInput
  }

  export type ArtifactSourceUncheckedCreateInput = {
    artifactId: string
    sourceId: string
  }

  export type ArtifactSourceUpdateInput = {
    artifact?: ContentArtifactUpdateOneRequiredWithoutSourcesNestedInput
    source?: LectureSourceUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type ArtifactSourceUncheckedUpdateInput = {
    artifactId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactSourceCreateManyInput = {
    artifactId: string
    sourceId: string
  }

  export type ArtifactSourceUpdateManyMutationInput = {

  }

  export type ArtifactSourceUncheckedUpdateManyInput = {
    artifactId?: StringFieldUpdateOperationsInput | string
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type QAPairCreateInput = {
    id: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifact: ContentArtifactCreateNestedOneWithoutQaPairsInput
  }

  export type QAPairUncheckedCreateInput = {
    id: string
    artifactId: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type QAPairUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifact?: ContentArtifactUpdateOneRequiredWithoutQaPairsNestedInput
  }

  export type QAPairUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairCreateManyInput = {
    id: string
    artifactId: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type QAPairUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCreateInput = {
    id: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifact: ContentArtifactCreateNestedOneWithoutFlashcardsInput
  }

  export type FlashcardUncheckedCreateInput = {
    id: string
    artifactId: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FlashcardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifact?: ContentArtifactUpdateOneRequiredWithoutFlashcardsNestedInput
  }

  export type FlashcardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardCreateManyInput = {
    id: string
    artifactId: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FlashcardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureAssistantCreateInput = {
    id: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutAssistantInput
    messages?: ChatMessageCreateNestedManyWithoutAssistantInput
  }

  export type LectureAssistantUncheckedCreateInput = {
    id: string
    lectureId: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type LectureAssistantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutAssistantNestedInput
    messages?: ChatMessageUpdateManyWithoutAssistantNestedInput
  }

  export type LectureAssistantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type LectureAssistantCreateManyInput = {
    id: string
    lectureId: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureAssistantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureAssistantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    assistant: LectureAssistantCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id: string
    assistantId: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assistant?: LectureAssistantUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id: string
    assistantId: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assistantId?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateInput = {
    createdAt: Date | string
    user: UserCreateNestedOneWithoutBookmarksInput
    lecture: LectureCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateInput = {
    userId: string
    lectureId: string
    createdAt: Date | string
  }

  export type BookmarkUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarksNestedInput
    lecture?: LectureUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkCreateManyInput = {
    userId: string
    lectureId: string
    createdAt: Date | string
  }

  export type BookmarkUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutOwnedRoomsInput
    memberships?: RoomMembershipCreateNestedManyWithoutRoomInput
    shares?: RoomShareCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id: string
    name: string
    description?: string | null
    ownerId: string
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    memberships?: RoomMembershipUncheckedCreateNestedManyWithoutRoomInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedRoomsNestedInput
    memberships?: RoomMembershipUpdateManyWithoutRoomNestedInput
    shares?: RoomShareUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id: string
    name: string
    description?: string | null
    ownerId: string
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipCreateInput = {
    id: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    invitedBy?: UserCreateNestedOneWithoutInvitationsSentInput
    room: RoomCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutRoomMembershipsInput
  }

  export type RoomMembershipUncheckedCreateInput = {
    id: string
    roomId: string
    userId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: UserUpdateOneWithoutInvitationsSentNestedInput
    room?: RoomUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutRoomMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipCreateManyInput = {
    id: string
    roomId: string
    userId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomShareCreateInput = {
    id: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    room: RoomCreateNestedOneWithoutSharesInput
    artifact: ContentArtifactCreateNestedOneWithoutSharesInput
    sharedBy: UserCreateNestedOneWithoutRoomSharesInput
    notes?: RoomNoteCreateNestedManyWithoutShareInput
  }

  export type RoomShareUncheckedCreateInput = {
    id: string
    roomId: string
    artifactId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    notes?: RoomNoteUncheckedCreateNestedManyWithoutShareInput
  }

  export type RoomShareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutSharesNestedInput
    artifact?: ContentArtifactUpdateOneRequiredWithoutSharesNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutRoomSharesNestedInput
    notes?: RoomNoteUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: RoomNoteUncheckedUpdateManyWithoutShareNestedInput
  }

  export type RoomShareCreateManyInput = {
    id: string
    roomId: string
    artifactId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomShareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomShareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteCreateInput = {
    id: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    share: RoomShareCreateNestedOneWithoutNotesInput
    author: UserCreateNestedOneWithoutRoomNotesInput
  }

  export type RoomNoteUncheckedCreateInput = {
    id: string
    shareId: string
    authorId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    share?: RoomShareUpdateOneRequiredWithoutNotesNestedInput
    author?: UserUpdateOneRequiredWithoutRoomNotesNestedInput
  }

  export type RoomNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteCreateManyInput = {
    id: string
    shareId: string
    authorId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type LectureListRelationFilter = {
    every?: LectureWhereInput
    some?: LectureWhereInput
    none?: LectureWhereInput
  }

  export type BookmarkListRelationFilter = {
    every?: BookmarkWhereInput
    some?: BookmarkWhereInput
    none?: BookmarkWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomMembershipListRelationFilter = {
    every?: RoomMembershipWhereInput
    some?: RoomMembershipWhereInput
    none?: RoomMembershipWhereInput
  }

  export type ContentArtifactListRelationFilter = {
    every?: ContentArtifactWhereInput
    some?: ContentArtifactWhereInput
    none?: ContentArtifactWhereInput
  }

  export type RoomShareListRelationFilter = {
    every?: RoomShareWhereInput
    some?: RoomShareWhereInput
    none?: RoomShareWhereInput
  }

  export type RoomNoteListRelationFilter = {
    every?: RoomNoteWhereInput
    some?: RoomNoteWhereInput
    none?: RoomNoteWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookmarkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentArtifactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomShareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    expiresAt?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    providerId?: SortOrder
    userId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    idToken?: SortOrder
    accessTokenExpiresAt?: SortOrder
    refreshTokenExpiresAt?: SortOrder
    scope?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type VerificationCountOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VerificationMinOrderByAggregateInput = {
    id?: SortOrder
    identifier?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderOwnerIdNameCompoundUniqueInput = {
    ownerId: string
    name: string
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    name?: SortOrder
    color?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderScalarRelationFilter = {
    is?: FolderWhereInput
    isNot?: FolderWhereInput
  }

  export type LectureSourceListRelationFilter = {
    every?: LectureSourceWhereInput
    some?: LectureSourceWhereInput
    none?: LectureSourceWhereInput
  }

  export type LectureAssistantNullableScalarRelationFilter = {
    is?: LectureAssistantWhereInput | null
    isNot?: LectureAssistantWhereInput | null
  }

  export type LectureSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    folderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    folderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    folderId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LectureScalarRelationFilter = {
    is?: LectureWhereInput
    isNot?: LectureWhereInput
  }

  export type ArtifactSourceListRelationFilter = {
    every?: ArtifactSourceWhereInput
    some?: ArtifactSourceWhereInput
    none?: ArtifactSourceWhereInput
  }

  export type ArtifactSourceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureSourceCountOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    url?: SortOrder
    fileKey?: SortOrder
    textContent?: SortOrder
    transcript?: SortOrder
    language?: SortOrder
    durationSeconds?: SortOrder
    pageCount?: SortOrder
    checksum?: SortOrder
    status?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureSourceAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
    pageCount?: SortOrder
  }

  export type LectureSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    url?: SortOrder
    fileKey?: SortOrder
    textContent?: SortOrder
    transcript?: SortOrder
    language?: SortOrder
    durationSeconds?: SortOrder
    pageCount?: SortOrder
    checksum?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureSourceMinOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    kind?: SortOrder
    title?: SortOrder
    url?: SortOrder
    fileKey?: SortOrder
    textContent?: SortOrder
    transcript?: SortOrder
    language?: SortOrder
    durationSeconds?: SortOrder
    pageCount?: SortOrder
    checksum?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureSourceSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
    pageCount?: SortOrder
  }

  export type EnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type QAPairListRelationFilter = {
    every?: QAPairWhereInput
    some?: QAPairWhereInput
    none?: QAPairWhereInput
  }

  export type FlashcardListRelationFilter = {
    every?: FlashcardWhereInput
    some?: FlashcardWhereInput
    none?: FlashcardWhereInput
  }

  export type QAPairOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlashcardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentArtifactCountOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    status?: SortOrder
    coverImageUrl?: SortOrder
    fileUrl?: SortOrder
    transcript?: SortOrder
    durationSeconds?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentArtifactAvgOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type ContentArtifactMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    status?: SortOrder
    coverImageUrl?: SortOrder
    fileUrl?: SortOrder
    transcript?: SortOrder
    durationSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentArtifactMinOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    ownerId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    description?: SortOrder
    language?: SortOrder
    status?: SortOrder
    coverImageUrl?: SortOrder
    fileUrl?: SortOrder
    transcript?: SortOrder
    durationSeconds?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentArtifactSumOrderByAggregateInput = {
    durationSeconds?: SortOrder
  }

  export type EnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type ContentArtifactScalarRelationFilter = {
    is?: ContentArtifactWhereInput
    isNot?: ContentArtifactWhereInput
  }

  export type LectureSourceScalarRelationFilter = {
    is?: LectureSourceWhereInput
    isNot?: LectureSourceWhereInput
  }

  export type ArtifactSourceArtifactIdSourceIdCompoundUniqueInput = {
    artifactId: string
    sourceId: string
  }

  export type ArtifactSourceCountOrderByAggregateInput = {
    artifactId?: SortOrder
    sourceId?: SortOrder
  }

  export type ArtifactSourceMaxOrderByAggregateInput = {
    artifactId?: SortOrder
    sourceId?: SortOrder
  }

  export type ArtifactSourceMinOrderByAggregateInput = {
    artifactId?: SortOrder
    sourceId?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type QAPairCountOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    choices?: SortOrder
    correctKey?: SortOrder
    difficulty?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QAPairAvgOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type QAPairMaxOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    correctKey?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QAPairMinOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    question?: SortOrder
    answer?: SortOrder
    correctKey?: SortOrder
    difficulty?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QAPairSumOrderByAggregateInput = {
    difficulty?: SortOrder
  }

  export type FlashcardCountOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    hint?: SortOrder
    tags?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlashcardMaxOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    hint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlashcardMinOrderByAggregateInput = {
    id?: SortOrder
    artifactId?: SortOrder
    front?: SortOrder
    back?: SortOrder
    hint?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LectureAssistantCountOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    displayName?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureAssistantMaxOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    displayName?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LectureAssistantMinOrderByAggregateInput = {
    id?: SortOrder
    lectureId?: SortOrder
    displayName?: SortOrder
    systemPrompt?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChatRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRole | EnumChatRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoleFilter<$PrismaModel> | $Enums.ChatRole
  }

  export type LectureAssistantScalarRelationFilter = {
    is?: LectureAssistantWhereInput
    isNot?: LectureAssistantWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    assistantId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    model?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    assistantId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    assistantId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    toolName?: SortOrder
    model?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChatRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRole | EnumChatRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoleWithAggregatesFilter<$PrismaModel> | $Enums.ChatRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoleFilter<$PrismaModel>
    _max?: NestedEnumChatRoleFilter<$PrismaModel>
  }

  export type BookmarkUserIdLectureIdCompoundUniqueInput = {
    userId: string
    lectureId: string
  }

  export type BookmarkCountOrderByAggregateInput = {
    userId?: SortOrder
    lectureId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMaxOrderByAggregateInput = {
    userId?: SortOrder
    lectureId?: SortOrder
    createdAt?: SortOrder
  }

  export type BookmarkMinOrderByAggregateInput = {
    userId?: SortOrder
    lectureId?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    isPrivate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type EnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomMembershipRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type RoomMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    invitedById?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    invitedById?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    invitedById?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type RoomShareRoomIdArtifactIdSharedByIdCompoundUniqueInput = {
    roomId: string
    artifactId: string
    sharedById: string
  }

  export type RoomShareCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    artifactId?: SortOrder
    sharedById?: SortOrder
    caption?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomShareMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    artifactId?: SortOrder
    sharedById?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomShareMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    artifactId?: SortOrder
    sharedById?: SortOrder
    caption?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomShareScalarRelationFilter = {
    is?: RoomShareWhereInput
    isNot?: RoomShareWhereInput
  }

  export type RoomNoteCountOrderByAggregateInput = {
    id?: SortOrder
    shareId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    shareId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomNoteMinOrderByAggregateInput = {
    id?: SortOrder
    shareId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type FolderCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput> | FolderCreateWithoutOwnerInput[] | FolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutOwnerInput | FolderCreateOrConnectWithoutOwnerInput[]
    createMany?: FolderCreateManyOwnerInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type LectureCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput> | LectureCreateWithoutOwnerInput[] | LectureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutOwnerInput | LectureCreateOrConnectWithoutOwnerInput[]
    createMany?: LectureCreateManyOwnerInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type BookmarkCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type RoomMembershipCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput> | RoomMembershipCreateWithoutInvitedByInput[] | RoomMembershipUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutInvitedByInput | RoomMembershipCreateOrConnectWithoutInvitedByInput[]
    createMany?: RoomMembershipCreateManyInvitedByInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type ContentArtifactCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput> | ContentArtifactCreateWithoutOwnerInput[] | ContentArtifactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutOwnerInput | ContentArtifactCreateOrConnectWithoutOwnerInput[]
    createMany?: ContentArtifactCreateManyOwnerInputEnvelope
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
  }

  export type RoomShareCreateNestedManyWithoutSharedByInput = {
    create?: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput> | RoomShareCreateWithoutSharedByInput[] | RoomShareUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutSharedByInput | RoomShareCreateOrConnectWithoutSharedByInput[]
    createMany?: RoomShareCreateManySharedByInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type RoomNoteCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput> | RoomNoteCreateWithoutAuthorInput[] | RoomNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutAuthorInput | RoomNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: RoomNoteCreateManyAuthorInputEnvelope
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput> | FolderCreateWithoutOwnerInput[] | FolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutOwnerInput | FolderCreateOrConnectWithoutOwnerInput[]
    createMany?: FolderCreateManyOwnerInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type LectureUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput> | LectureCreateWithoutOwnerInput[] | LectureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutOwnerInput | LectureCreateOrConnectWithoutOwnerInput[]
    createMany?: LectureCreateManyOwnerInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type BookmarkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput = {
    create?: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput> | RoomMembershipCreateWithoutInvitedByInput[] | RoomMembershipUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutInvitedByInput | RoomMembershipCreateOrConnectWithoutInvitedByInput[]
    createMany?: RoomMembershipCreateManyInvitedByInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput> | ContentArtifactCreateWithoutOwnerInput[] | ContentArtifactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutOwnerInput | ContentArtifactCreateOrConnectWithoutOwnerInput[]
    createMany?: ContentArtifactCreateManyOwnerInputEnvelope
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
  }

  export type RoomShareUncheckedCreateNestedManyWithoutSharedByInput = {
    create?: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput> | RoomShareCreateWithoutSharedByInput[] | RoomShareUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutSharedByInput | RoomShareCreateOrConnectWithoutSharedByInput[]
    createMany?: RoomShareCreateManySharedByInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type RoomNoteUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput> | RoomNoteCreateWithoutAuthorInput[] | RoomNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutAuthorInput | RoomNoteCreateOrConnectWithoutAuthorInput[]
    createMany?: RoomNoteCreateManyAuthorInputEnvelope
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type FolderUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput> | FolderCreateWithoutOwnerInput[] | FolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutOwnerInput | FolderCreateOrConnectWithoutOwnerInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutOwnerInput | FolderUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FolderCreateManyOwnerInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutOwnerInput | FolderUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutOwnerInput | FolderUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type LectureUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput> | LectureCreateWithoutOwnerInput[] | LectureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutOwnerInput | LectureCreateOrConnectWithoutOwnerInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutOwnerInput | LectureUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LectureCreateManyOwnerInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutOwnerInput | LectureUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutOwnerInput | LectureUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type BookmarkUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutUserInput | RoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutUserInput | RoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutUserInput | RoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomMembershipUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput> | RoomMembershipCreateWithoutInvitedByInput[] | RoomMembershipUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutInvitedByInput | RoomMembershipCreateOrConnectWithoutInvitedByInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutInvitedByInput | RoomMembershipUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: RoomMembershipCreateManyInvitedByInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutInvitedByInput | RoomMembershipUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutInvitedByInput | RoomMembershipUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type ContentArtifactUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput> | ContentArtifactCreateWithoutOwnerInput[] | ContentArtifactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutOwnerInput | ContentArtifactCreateOrConnectWithoutOwnerInput[]
    upsert?: ContentArtifactUpsertWithWhereUniqueWithoutOwnerInput | ContentArtifactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ContentArtifactCreateManyOwnerInputEnvelope
    set?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    disconnect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    delete?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    update?: ContentArtifactUpdateWithWhereUniqueWithoutOwnerInput | ContentArtifactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ContentArtifactUpdateManyWithWhereWithoutOwnerInput | ContentArtifactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
  }

  export type RoomShareUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput> | RoomShareCreateWithoutSharedByInput[] | RoomShareUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutSharedByInput | RoomShareCreateOrConnectWithoutSharedByInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutSharedByInput | RoomShareUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: RoomShareCreateManySharedByInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutSharedByInput | RoomShareUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutSharedByInput | RoomShareUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type RoomNoteUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput> | RoomNoteCreateWithoutAuthorInput[] | RoomNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutAuthorInput | RoomNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: RoomNoteUpsertWithWhereUniqueWithoutAuthorInput | RoomNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RoomNoteCreateManyAuthorInputEnvelope
    set?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    disconnect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    delete?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    update?: RoomNoteUpdateWithWhereUniqueWithoutAuthorInput | RoomNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RoomNoteUpdateManyWithWhereWithoutAuthorInput | RoomNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput> | FolderCreateWithoutOwnerInput[] | FolderUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutOwnerInput | FolderCreateOrConnectWithoutOwnerInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutOwnerInput | FolderUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FolderCreateManyOwnerInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutOwnerInput | FolderUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutOwnerInput | FolderUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type LectureUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput> | LectureCreateWithoutOwnerInput[] | LectureUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutOwnerInput | LectureCreateOrConnectWithoutOwnerInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutOwnerInput | LectureUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: LectureCreateManyOwnerInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutOwnerInput | LectureUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutOwnerInput | LectureUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type BookmarkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput> | BookmarkCreateWithoutUserInput[] | BookmarkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutUserInput | BookmarkCreateOrConnectWithoutUserInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutUserInput | BookmarkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BookmarkCreateManyUserInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutUserInput | BookmarkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutUserInput | BookmarkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutUserInput | RoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutUserInput | RoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutUserInput | RoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput> | RoomMembershipCreateWithoutInvitedByInput[] | RoomMembershipUncheckedCreateWithoutInvitedByInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutInvitedByInput | RoomMembershipCreateOrConnectWithoutInvitedByInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutInvitedByInput | RoomMembershipUpsertWithWhereUniqueWithoutInvitedByInput[]
    createMany?: RoomMembershipCreateManyInvitedByInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutInvitedByInput | RoomMembershipUpdateWithWhereUniqueWithoutInvitedByInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutInvitedByInput | RoomMembershipUpdateManyWithWhereWithoutInvitedByInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput> | ContentArtifactCreateWithoutOwnerInput[] | ContentArtifactUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutOwnerInput | ContentArtifactCreateOrConnectWithoutOwnerInput[]
    upsert?: ContentArtifactUpsertWithWhereUniqueWithoutOwnerInput | ContentArtifactUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ContentArtifactCreateManyOwnerInputEnvelope
    set?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    disconnect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    delete?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    update?: ContentArtifactUpdateWithWhereUniqueWithoutOwnerInput | ContentArtifactUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ContentArtifactUpdateManyWithWhereWithoutOwnerInput | ContentArtifactUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
  }

  export type RoomShareUncheckedUpdateManyWithoutSharedByNestedInput = {
    create?: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput> | RoomShareCreateWithoutSharedByInput[] | RoomShareUncheckedCreateWithoutSharedByInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutSharedByInput | RoomShareCreateOrConnectWithoutSharedByInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutSharedByInput | RoomShareUpsertWithWhereUniqueWithoutSharedByInput[]
    createMany?: RoomShareCreateManySharedByInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutSharedByInput | RoomShareUpdateWithWhereUniqueWithoutSharedByInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutSharedByInput | RoomShareUpdateManyWithWhereWithoutSharedByInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput> | RoomNoteCreateWithoutAuthorInput[] | RoomNoteUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutAuthorInput | RoomNoteCreateOrConnectWithoutAuthorInput[]
    upsert?: RoomNoteUpsertWithWhereUniqueWithoutAuthorInput | RoomNoteUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: RoomNoteCreateManyAuthorInputEnvelope
    set?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    disconnect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    delete?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    update?: RoomNoteUpdateWithWhereUniqueWithoutAuthorInput | RoomNoteUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: RoomNoteUpdateManyWithWhereWithoutAuthorInput | RoomNoteUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutFoldersInput = {
    create?: XOR<UserCreateWithoutFoldersInput, UserUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFoldersInput
    connect?: UserWhereUniqueInput
  }

  export type LectureCreateNestedManyWithoutFolderInput = {
    create?: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput> | LectureCreateWithoutFolderInput[] | LectureUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutFolderInput | LectureCreateOrConnectWithoutFolderInput[]
    createMany?: LectureCreateManyFolderInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type LectureUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput> | LectureCreateWithoutFolderInput[] | LectureUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutFolderInput | LectureCreateOrConnectWithoutFolderInput[]
    createMany?: LectureCreateManyFolderInputEnvelope
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<UserCreateWithoutFoldersInput, UserUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFoldersInput
    upsert?: UserUpsertWithoutFoldersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFoldersInput, UserUpdateWithoutFoldersInput>, UserUncheckedUpdateWithoutFoldersInput>
  }

  export type LectureUpdateManyWithoutFolderNestedInput = {
    create?: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput> | LectureCreateWithoutFolderInput[] | LectureUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutFolderInput | LectureCreateOrConnectWithoutFolderInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutFolderInput | LectureUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: LectureCreateManyFolderInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutFolderInput | LectureUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutFolderInput | LectureUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type LectureUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput> | LectureCreateWithoutFolderInput[] | LectureUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: LectureCreateOrConnectWithoutFolderInput | LectureCreateOrConnectWithoutFolderInput[]
    upsert?: LectureUpsertWithWhereUniqueWithoutFolderInput | LectureUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: LectureCreateManyFolderInputEnvelope
    set?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    disconnect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    delete?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    connect?: LectureWhereUniqueInput | LectureWhereUniqueInput[]
    update?: LectureUpdateWithWhereUniqueWithoutFolderInput | LectureUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: LectureUpdateManyWithWhereWithoutFolderInput | LectureUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: LectureScalarWhereInput | LectureScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLecturesInput = {
    create?: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturesInput
    connect?: UserWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutLecturesInput = {
    create?: XOR<FolderCreateWithoutLecturesInput, FolderUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutLecturesInput
    connect?: FolderWhereUniqueInput
  }

  export type LectureSourceCreateNestedManyWithoutLectureInput = {
    create?: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput> | LectureSourceCreateWithoutLectureInput[] | LectureSourceUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LectureSourceCreateOrConnectWithoutLectureInput | LectureSourceCreateOrConnectWithoutLectureInput[]
    createMany?: LectureSourceCreateManyLectureInputEnvelope
    connect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
  }

  export type ContentArtifactCreateNestedManyWithoutLectureInput = {
    create?: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput> | ContentArtifactCreateWithoutLectureInput[] | ContentArtifactUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutLectureInput | ContentArtifactCreateOrConnectWithoutLectureInput[]
    createMany?: ContentArtifactCreateManyLectureInputEnvelope
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
  }

  export type LectureAssistantCreateNestedOneWithoutLectureInput = {
    create?: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutLectureInput
    connect?: LectureAssistantWhereUniqueInput
  }

  export type BookmarkCreateNestedManyWithoutLectureInput = {
    create?: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput> | BookmarkCreateWithoutLectureInput[] | BookmarkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutLectureInput | BookmarkCreateOrConnectWithoutLectureInput[]
    createMany?: BookmarkCreateManyLectureInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type LectureSourceUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput> | LectureSourceCreateWithoutLectureInput[] | LectureSourceUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LectureSourceCreateOrConnectWithoutLectureInput | LectureSourceCreateOrConnectWithoutLectureInput[]
    createMany?: LectureSourceCreateManyLectureInputEnvelope
    connect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
  }

  export type ContentArtifactUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput> | ContentArtifactCreateWithoutLectureInput[] | ContentArtifactUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutLectureInput | ContentArtifactCreateOrConnectWithoutLectureInput[]
    createMany?: ContentArtifactCreateManyLectureInputEnvelope
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
  }

  export type LectureAssistantUncheckedCreateNestedOneWithoutLectureInput = {
    create?: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutLectureInput
    connect?: LectureAssistantWhereUniqueInput
  }

  export type BookmarkUncheckedCreateNestedManyWithoutLectureInput = {
    create?: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput> | BookmarkCreateWithoutLectureInput[] | BookmarkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutLectureInput | BookmarkCreateOrConnectWithoutLectureInput[]
    createMany?: BookmarkCreateManyLectureInputEnvelope
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutLecturesNestedInput = {
    create?: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLecturesInput
    upsert?: UserUpsertWithoutLecturesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLecturesInput, UserUpdateWithoutLecturesInput>, UserUncheckedUpdateWithoutLecturesInput>
  }

  export type FolderUpdateOneRequiredWithoutLecturesNestedInput = {
    create?: XOR<FolderCreateWithoutLecturesInput, FolderUncheckedCreateWithoutLecturesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutLecturesInput
    upsert?: FolderUpsertWithoutLecturesInput
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutLecturesInput, FolderUpdateWithoutLecturesInput>, FolderUncheckedUpdateWithoutLecturesInput>
  }

  export type LectureSourceUpdateManyWithoutLectureNestedInput = {
    create?: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput> | LectureSourceCreateWithoutLectureInput[] | LectureSourceUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LectureSourceCreateOrConnectWithoutLectureInput | LectureSourceCreateOrConnectWithoutLectureInput[]
    upsert?: LectureSourceUpsertWithWhereUniqueWithoutLectureInput | LectureSourceUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: LectureSourceCreateManyLectureInputEnvelope
    set?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    disconnect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    delete?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    connect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    update?: LectureSourceUpdateWithWhereUniqueWithoutLectureInput | LectureSourceUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: LectureSourceUpdateManyWithWhereWithoutLectureInput | LectureSourceUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: LectureSourceScalarWhereInput | LectureSourceScalarWhereInput[]
  }

  export type ContentArtifactUpdateManyWithoutLectureNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput> | ContentArtifactCreateWithoutLectureInput[] | ContentArtifactUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutLectureInput | ContentArtifactCreateOrConnectWithoutLectureInput[]
    upsert?: ContentArtifactUpsertWithWhereUniqueWithoutLectureInput | ContentArtifactUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: ContentArtifactCreateManyLectureInputEnvelope
    set?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    disconnect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    delete?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    update?: ContentArtifactUpdateWithWhereUniqueWithoutLectureInput | ContentArtifactUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: ContentArtifactUpdateManyWithWhereWithoutLectureInput | ContentArtifactUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
  }

  export type LectureAssistantUpdateOneWithoutLectureNestedInput = {
    create?: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutLectureInput
    upsert?: LectureAssistantUpsertWithoutLectureInput
    disconnect?: LectureAssistantWhereInput | boolean
    delete?: LectureAssistantWhereInput | boolean
    connect?: LectureAssistantWhereUniqueInput
    update?: XOR<XOR<LectureAssistantUpdateToOneWithWhereWithoutLectureInput, LectureAssistantUpdateWithoutLectureInput>, LectureAssistantUncheckedUpdateWithoutLectureInput>
  }

  export type BookmarkUpdateManyWithoutLectureNestedInput = {
    create?: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput> | BookmarkCreateWithoutLectureInput[] | BookmarkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutLectureInput | BookmarkCreateOrConnectWithoutLectureInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutLectureInput | BookmarkUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: BookmarkCreateManyLectureInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutLectureInput | BookmarkUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutLectureInput | BookmarkUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type LectureSourceUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput> | LectureSourceCreateWithoutLectureInput[] | LectureSourceUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: LectureSourceCreateOrConnectWithoutLectureInput | LectureSourceCreateOrConnectWithoutLectureInput[]
    upsert?: LectureSourceUpsertWithWhereUniqueWithoutLectureInput | LectureSourceUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: LectureSourceCreateManyLectureInputEnvelope
    set?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    disconnect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    delete?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    connect?: LectureSourceWhereUniqueInput | LectureSourceWhereUniqueInput[]
    update?: LectureSourceUpdateWithWhereUniqueWithoutLectureInput | LectureSourceUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: LectureSourceUpdateManyWithWhereWithoutLectureInput | LectureSourceUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: LectureSourceScalarWhereInput | LectureSourceScalarWhereInput[]
  }

  export type ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput> | ContentArtifactCreateWithoutLectureInput[] | ContentArtifactUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutLectureInput | ContentArtifactCreateOrConnectWithoutLectureInput[]
    upsert?: ContentArtifactUpsertWithWhereUniqueWithoutLectureInput | ContentArtifactUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: ContentArtifactCreateManyLectureInputEnvelope
    set?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    disconnect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    delete?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    connect?: ContentArtifactWhereUniqueInput | ContentArtifactWhereUniqueInput[]
    update?: ContentArtifactUpdateWithWhereUniqueWithoutLectureInput | ContentArtifactUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: ContentArtifactUpdateManyWithWhereWithoutLectureInput | ContentArtifactUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
  }

  export type LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput = {
    create?: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutLectureInput
    upsert?: LectureAssistantUpsertWithoutLectureInput
    disconnect?: LectureAssistantWhereInput | boolean
    delete?: LectureAssistantWhereInput | boolean
    connect?: LectureAssistantWhereUniqueInput
    update?: XOR<XOR<LectureAssistantUpdateToOneWithWhereWithoutLectureInput, LectureAssistantUpdateWithoutLectureInput>, LectureAssistantUncheckedUpdateWithoutLectureInput>
  }

  export type BookmarkUncheckedUpdateManyWithoutLectureNestedInput = {
    create?: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput> | BookmarkCreateWithoutLectureInput[] | BookmarkUncheckedCreateWithoutLectureInput[]
    connectOrCreate?: BookmarkCreateOrConnectWithoutLectureInput | BookmarkCreateOrConnectWithoutLectureInput[]
    upsert?: BookmarkUpsertWithWhereUniqueWithoutLectureInput | BookmarkUpsertWithWhereUniqueWithoutLectureInput[]
    createMany?: BookmarkCreateManyLectureInputEnvelope
    set?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    disconnect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    delete?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    connect?: BookmarkWhereUniqueInput | BookmarkWhereUniqueInput[]
    update?: BookmarkUpdateWithWhereUniqueWithoutLectureInput | BookmarkUpdateWithWhereUniqueWithoutLectureInput[]
    updateMany?: BookmarkUpdateManyWithWhereWithoutLectureInput | BookmarkUpdateManyWithWhereWithoutLectureInput[]
    deleteMany?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
  }

  export type LectureCreateNestedOneWithoutSourcesInput = {
    create?: XOR<LectureCreateWithoutSourcesInput, LectureUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutSourcesInput
    connect?: LectureWhereUniqueInput
  }

  export type ArtifactSourceCreateNestedManyWithoutSourceInput = {
    create?: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput> | ArtifactSourceCreateWithoutSourceInput[] | ArtifactSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutSourceInput | ArtifactSourceCreateOrConnectWithoutSourceInput[]
    createMany?: ArtifactSourceCreateManySourceInputEnvelope
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
  }

  export type ArtifactSourceUncheckedCreateNestedManyWithoutSourceInput = {
    create?: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput> | ArtifactSourceCreateWithoutSourceInput[] | ArtifactSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutSourceInput | ArtifactSourceCreateOrConnectWithoutSourceInput[]
    createMany?: ArtifactSourceCreateManySourceInputEnvelope
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
  }

  export type EnumSourceTypeFieldUpdateOperationsInput = {
    set?: $Enums.SourceType
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumProcessingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProcessingStatus
  }

  export type LectureUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<LectureCreateWithoutSourcesInput, LectureUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: LectureCreateOrConnectWithoutSourcesInput
    upsert?: LectureUpsertWithoutSourcesInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutSourcesInput, LectureUpdateWithoutSourcesInput>, LectureUncheckedUpdateWithoutSourcesInput>
  }

  export type ArtifactSourceUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput> | ArtifactSourceCreateWithoutSourceInput[] | ArtifactSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutSourceInput | ArtifactSourceCreateOrConnectWithoutSourceInput[]
    upsert?: ArtifactSourceUpsertWithWhereUniqueWithoutSourceInput | ArtifactSourceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ArtifactSourceCreateManySourceInputEnvelope
    set?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    disconnect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    delete?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    update?: ArtifactSourceUpdateWithWhereUniqueWithoutSourceInput | ArtifactSourceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ArtifactSourceUpdateManyWithWhereWithoutSourceInput | ArtifactSourceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
  }

  export type ArtifactSourceUncheckedUpdateManyWithoutSourceNestedInput = {
    create?: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput> | ArtifactSourceCreateWithoutSourceInput[] | ArtifactSourceUncheckedCreateWithoutSourceInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutSourceInput | ArtifactSourceCreateOrConnectWithoutSourceInput[]
    upsert?: ArtifactSourceUpsertWithWhereUniqueWithoutSourceInput | ArtifactSourceUpsertWithWhereUniqueWithoutSourceInput[]
    createMany?: ArtifactSourceCreateManySourceInputEnvelope
    set?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    disconnect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    delete?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    update?: ArtifactSourceUpdateWithWhereUniqueWithoutSourceInput | ArtifactSourceUpdateWithWhereUniqueWithoutSourceInput[]
    updateMany?: ArtifactSourceUpdateManyWithWhereWithoutSourceInput | ArtifactSourceUpdateManyWithWhereWithoutSourceInput[]
    deleteMany?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
  }

  export type LectureCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<LectureCreateWithoutArtifactsInput, LectureUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutArtifactsInput
    connect?: LectureWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<UserCreateWithoutArtifactsInput, UserUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtifactsInput
    connect?: UserWhereUniqueInput
  }

  export type QAPairCreateNestedManyWithoutArtifactInput = {
    create?: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput> | QAPairCreateWithoutArtifactInput[] | QAPairUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutArtifactInput | QAPairCreateOrConnectWithoutArtifactInput[]
    createMany?: QAPairCreateManyArtifactInputEnvelope
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type FlashcardCreateNestedManyWithoutArtifactInput = {
    create?: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput> | FlashcardCreateWithoutArtifactInput[] | FlashcardUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutArtifactInput | FlashcardCreateOrConnectWithoutArtifactInput[]
    createMany?: FlashcardCreateManyArtifactInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type RoomShareCreateNestedManyWithoutArtifactInput = {
    create?: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput> | RoomShareCreateWithoutArtifactInput[] | RoomShareUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutArtifactInput | RoomShareCreateOrConnectWithoutArtifactInput[]
    createMany?: RoomShareCreateManyArtifactInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type ArtifactSourceCreateNestedManyWithoutArtifactInput = {
    create?: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput> | ArtifactSourceCreateWithoutArtifactInput[] | ArtifactSourceUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutArtifactInput | ArtifactSourceCreateOrConnectWithoutArtifactInput[]
    createMany?: ArtifactSourceCreateManyArtifactInputEnvelope
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
  }

  export type QAPairUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput> | QAPairCreateWithoutArtifactInput[] | QAPairUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutArtifactInput | QAPairCreateOrConnectWithoutArtifactInput[]
    createMany?: QAPairCreateManyArtifactInputEnvelope
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
  }

  export type FlashcardUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput> | FlashcardCreateWithoutArtifactInput[] | FlashcardUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutArtifactInput | FlashcardCreateOrConnectWithoutArtifactInput[]
    createMany?: FlashcardCreateManyArtifactInputEnvelope
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
  }

  export type RoomShareUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput> | RoomShareCreateWithoutArtifactInput[] | RoomShareUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutArtifactInput | RoomShareCreateOrConnectWithoutArtifactInput[]
    createMany?: RoomShareCreateManyArtifactInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput = {
    create?: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput> | ArtifactSourceCreateWithoutArtifactInput[] | ArtifactSourceUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutArtifactInput | ArtifactSourceCreateOrConnectWithoutArtifactInput[]
    createMany?: ArtifactSourceCreateManyArtifactInputEnvelope
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
  }

  export type EnumArtifactTypeFieldUpdateOperationsInput = {
    set?: $Enums.ArtifactType
  }

  export type LectureUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<LectureCreateWithoutArtifactsInput, LectureUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LectureCreateOrConnectWithoutArtifactsInput
    upsert?: LectureUpsertWithoutArtifactsInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutArtifactsInput, LectureUpdateWithoutArtifactsInput>, LectureUncheckedUpdateWithoutArtifactsInput>
  }

  export type UserUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<UserCreateWithoutArtifactsInput, UserUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: UserCreateOrConnectWithoutArtifactsInput
    upsert?: UserUpsertWithoutArtifactsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArtifactsInput, UserUpdateWithoutArtifactsInput>, UserUncheckedUpdateWithoutArtifactsInput>
  }

  export type QAPairUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput> | QAPairCreateWithoutArtifactInput[] | QAPairUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutArtifactInput | QAPairCreateOrConnectWithoutArtifactInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutArtifactInput | QAPairUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: QAPairCreateManyArtifactInputEnvelope
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutArtifactInput | QAPairUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutArtifactInput | QAPairUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type FlashcardUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput> | FlashcardCreateWithoutArtifactInput[] | FlashcardUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutArtifactInput | FlashcardCreateOrConnectWithoutArtifactInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutArtifactInput | FlashcardUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: FlashcardCreateManyArtifactInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutArtifactInput | FlashcardUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutArtifactInput | FlashcardUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type RoomShareUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput> | RoomShareCreateWithoutArtifactInput[] | RoomShareUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutArtifactInput | RoomShareCreateOrConnectWithoutArtifactInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutArtifactInput | RoomShareUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: RoomShareCreateManyArtifactInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutArtifactInput | RoomShareUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutArtifactInput | RoomShareUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type ArtifactSourceUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput> | ArtifactSourceCreateWithoutArtifactInput[] | ArtifactSourceUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutArtifactInput | ArtifactSourceCreateOrConnectWithoutArtifactInput[]
    upsert?: ArtifactSourceUpsertWithWhereUniqueWithoutArtifactInput | ArtifactSourceUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: ArtifactSourceCreateManyArtifactInputEnvelope
    set?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    disconnect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    delete?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    update?: ArtifactSourceUpdateWithWhereUniqueWithoutArtifactInput | ArtifactSourceUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: ArtifactSourceUpdateManyWithWhereWithoutArtifactInput | ArtifactSourceUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
  }

  export type QAPairUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput> | QAPairCreateWithoutArtifactInput[] | QAPairUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: QAPairCreateOrConnectWithoutArtifactInput | QAPairCreateOrConnectWithoutArtifactInput[]
    upsert?: QAPairUpsertWithWhereUniqueWithoutArtifactInput | QAPairUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: QAPairCreateManyArtifactInputEnvelope
    set?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    disconnect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    delete?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    connect?: QAPairWhereUniqueInput | QAPairWhereUniqueInput[]
    update?: QAPairUpdateWithWhereUniqueWithoutArtifactInput | QAPairUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: QAPairUpdateManyWithWhereWithoutArtifactInput | QAPairUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
  }

  export type FlashcardUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput> | FlashcardCreateWithoutArtifactInput[] | FlashcardUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: FlashcardCreateOrConnectWithoutArtifactInput | FlashcardCreateOrConnectWithoutArtifactInput[]
    upsert?: FlashcardUpsertWithWhereUniqueWithoutArtifactInput | FlashcardUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: FlashcardCreateManyArtifactInputEnvelope
    set?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    disconnect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    delete?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    connect?: FlashcardWhereUniqueInput | FlashcardWhereUniqueInput[]
    update?: FlashcardUpdateWithWhereUniqueWithoutArtifactInput | FlashcardUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: FlashcardUpdateManyWithWhereWithoutArtifactInput | FlashcardUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
  }

  export type RoomShareUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput> | RoomShareCreateWithoutArtifactInput[] | RoomShareUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutArtifactInput | RoomShareCreateOrConnectWithoutArtifactInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutArtifactInput | RoomShareUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: RoomShareCreateManyArtifactInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutArtifactInput | RoomShareUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutArtifactInput | RoomShareUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput = {
    create?: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput> | ArtifactSourceCreateWithoutArtifactInput[] | ArtifactSourceUncheckedCreateWithoutArtifactInput[]
    connectOrCreate?: ArtifactSourceCreateOrConnectWithoutArtifactInput | ArtifactSourceCreateOrConnectWithoutArtifactInput[]
    upsert?: ArtifactSourceUpsertWithWhereUniqueWithoutArtifactInput | ArtifactSourceUpsertWithWhereUniqueWithoutArtifactInput[]
    createMany?: ArtifactSourceCreateManyArtifactInputEnvelope
    set?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    disconnect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    delete?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    connect?: ArtifactSourceWhereUniqueInput | ArtifactSourceWhereUniqueInput[]
    update?: ArtifactSourceUpdateWithWhereUniqueWithoutArtifactInput | ArtifactSourceUpdateWithWhereUniqueWithoutArtifactInput[]
    updateMany?: ArtifactSourceUpdateManyWithWhereWithoutArtifactInput | ArtifactSourceUpdateManyWithWhereWithoutArtifactInput[]
    deleteMany?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
  }

  export type ContentArtifactCreateNestedOneWithoutSourcesInput = {
    create?: XOR<ContentArtifactCreateWithoutSourcesInput, ContentArtifactUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutSourcesInput
    connect?: ContentArtifactWhereUniqueInput
  }

  export type LectureSourceCreateNestedOneWithoutArtifactsInput = {
    create?: XOR<LectureSourceCreateWithoutArtifactsInput, LectureSourceUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LectureSourceCreateOrConnectWithoutArtifactsInput
    connect?: LectureSourceWhereUniqueInput
  }

  export type ContentArtifactUpdateOneRequiredWithoutSourcesNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutSourcesInput, ContentArtifactUncheckedCreateWithoutSourcesInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutSourcesInput
    upsert?: ContentArtifactUpsertWithoutSourcesInput
    connect?: ContentArtifactWhereUniqueInput
    update?: XOR<XOR<ContentArtifactUpdateToOneWithWhereWithoutSourcesInput, ContentArtifactUpdateWithoutSourcesInput>, ContentArtifactUncheckedUpdateWithoutSourcesInput>
  }

  export type LectureSourceUpdateOneRequiredWithoutArtifactsNestedInput = {
    create?: XOR<LectureSourceCreateWithoutArtifactsInput, LectureSourceUncheckedCreateWithoutArtifactsInput>
    connectOrCreate?: LectureSourceCreateOrConnectWithoutArtifactsInput
    upsert?: LectureSourceUpsertWithoutArtifactsInput
    connect?: LectureSourceWhereUniqueInput
    update?: XOR<XOR<LectureSourceUpdateToOneWithWhereWithoutArtifactsInput, LectureSourceUpdateWithoutArtifactsInput>, LectureSourceUncheckedUpdateWithoutArtifactsInput>
  }

  export type QAPairCreatetagsInput = {
    set: string[]
  }

  export type ContentArtifactCreateNestedOneWithoutQaPairsInput = {
    create?: XOR<ContentArtifactCreateWithoutQaPairsInput, ContentArtifactUncheckedCreateWithoutQaPairsInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutQaPairsInput
    connect?: ContentArtifactWhereUniqueInput
  }

  export type QAPairUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentArtifactUpdateOneRequiredWithoutQaPairsNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutQaPairsInput, ContentArtifactUncheckedCreateWithoutQaPairsInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutQaPairsInput
    upsert?: ContentArtifactUpsertWithoutQaPairsInput
    connect?: ContentArtifactWhereUniqueInput
    update?: XOR<XOR<ContentArtifactUpdateToOneWithWhereWithoutQaPairsInput, ContentArtifactUpdateWithoutQaPairsInput>, ContentArtifactUncheckedUpdateWithoutQaPairsInput>
  }

  export type FlashcardCreatetagsInput = {
    set: string[]
  }

  export type ContentArtifactCreateNestedOneWithoutFlashcardsInput = {
    create?: XOR<ContentArtifactCreateWithoutFlashcardsInput, ContentArtifactUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutFlashcardsInput
    connect?: ContentArtifactWhereUniqueInput
  }

  export type FlashcardUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ContentArtifactUpdateOneRequiredWithoutFlashcardsNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutFlashcardsInput, ContentArtifactUncheckedCreateWithoutFlashcardsInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutFlashcardsInput
    upsert?: ContentArtifactUpsertWithoutFlashcardsInput
    connect?: ContentArtifactWhereUniqueInput
    update?: XOR<XOR<ContentArtifactUpdateToOneWithWhereWithoutFlashcardsInput, ContentArtifactUpdateWithoutFlashcardsInput>, ContentArtifactUncheckedUpdateWithoutFlashcardsInput>
  }

  export type LectureCreateNestedOneWithoutAssistantInput = {
    create?: XOR<LectureCreateWithoutAssistantInput, LectureUncheckedCreateWithoutAssistantInput>
    connectOrCreate?: LectureCreateOrConnectWithoutAssistantInput
    connect?: LectureWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutAssistantInput = {
    create?: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput> | ChatMessageCreateWithoutAssistantInput[] | ChatMessageUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutAssistantInput | ChatMessageCreateOrConnectWithoutAssistantInput[]
    createMany?: ChatMessageCreateManyAssistantInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutAssistantInput = {
    create?: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput> | ChatMessageCreateWithoutAssistantInput[] | ChatMessageUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutAssistantInput | ChatMessageCreateOrConnectWithoutAssistantInput[]
    createMany?: ChatMessageCreateManyAssistantInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type LectureUpdateOneRequiredWithoutAssistantNestedInput = {
    create?: XOR<LectureCreateWithoutAssistantInput, LectureUncheckedCreateWithoutAssistantInput>
    connectOrCreate?: LectureCreateOrConnectWithoutAssistantInput
    upsert?: LectureUpsertWithoutAssistantInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutAssistantInput, LectureUpdateWithoutAssistantInput>, LectureUncheckedUpdateWithoutAssistantInput>
  }

  export type ChatMessageUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput> | ChatMessageCreateWithoutAssistantInput[] | ChatMessageUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutAssistantInput | ChatMessageCreateOrConnectWithoutAssistantInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutAssistantInput | ChatMessageUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: ChatMessageCreateManyAssistantInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutAssistantInput | ChatMessageUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutAssistantInput | ChatMessageUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutAssistantNestedInput = {
    create?: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput> | ChatMessageCreateWithoutAssistantInput[] | ChatMessageUncheckedCreateWithoutAssistantInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutAssistantInput | ChatMessageCreateOrConnectWithoutAssistantInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutAssistantInput | ChatMessageUpsertWithWhereUniqueWithoutAssistantInput[]
    createMany?: ChatMessageCreateManyAssistantInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutAssistantInput | ChatMessageUpdateWithWhereUniqueWithoutAssistantInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutAssistantInput | ChatMessageUpdateManyWithWhereWithoutAssistantInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type LectureAssistantCreateNestedOneWithoutMessagesInput = {
    create?: XOR<LectureAssistantCreateWithoutMessagesInput, LectureAssistantUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutMessagesInput
    connect?: LectureAssistantWhereUniqueInput
  }

  export type EnumChatRoleFieldUpdateOperationsInput = {
    set?: $Enums.ChatRole
  }

  export type LectureAssistantUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<LectureAssistantCreateWithoutMessagesInput, LectureAssistantUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: LectureAssistantCreateOrConnectWithoutMessagesInput
    upsert?: LectureAssistantUpsertWithoutMessagesInput
    connect?: LectureAssistantWhereUniqueInput
    update?: XOR<XOR<LectureAssistantUpdateToOneWithWhereWithoutMessagesInput, LectureAssistantUpdateWithoutMessagesInput>, LectureAssistantUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    connect?: UserWhereUniqueInput
  }

  export type LectureCreateNestedOneWithoutBookmarksInput = {
    create?: XOR<LectureCreateWithoutBookmarksInput, LectureUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: LectureCreateOrConnectWithoutBookmarksInput
    connect?: LectureWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookmarksInput
    upsert?: UserUpsertWithoutBookmarksInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookmarksInput, UserUpdateWithoutBookmarksInput>, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type LectureUpdateOneRequiredWithoutBookmarksNestedInput = {
    create?: XOR<LectureCreateWithoutBookmarksInput, LectureUncheckedCreateWithoutBookmarksInput>
    connectOrCreate?: LectureCreateOrConnectWithoutBookmarksInput
    upsert?: LectureUpsertWithoutBookmarksInput
    connect?: LectureWhereUniqueInput
    update?: XOR<XOR<LectureUpdateToOneWithWhereWithoutBookmarksInput, LectureUpdateWithoutBookmarksInput>, LectureUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserCreateNestedOneWithoutOwnedRoomsInput = {
    create?: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedRoomsInput
    connect?: UserWhereUniqueInput
  }

  export type RoomMembershipCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type RoomShareCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput> | RoomShareCreateWithoutRoomInput[] | RoomShareUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutRoomInput | RoomShareCreateOrConnectWithoutRoomInput[]
    createMany?: RoomShareCreateManyRoomInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type RoomMembershipUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type RoomShareUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput> | RoomShareCreateWithoutRoomInput[] | RoomShareUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutRoomInput | RoomShareCreateOrConnectWithoutRoomInput[]
    createMany?: RoomShareCreateManyRoomInputEnvelope
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutOwnedRoomsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedRoomsInput
    upsert?: UserUpsertWithoutOwnedRoomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedRoomsInput, UserUpdateWithoutOwnedRoomsInput>, UserUncheckedUpdateWithoutOwnedRoomsInput>
  }

  export type RoomMembershipUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutRoomInput | RoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutRoomInput | RoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutRoomInput | RoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomShareUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput> | RoomShareCreateWithoutRoomInput[] | RoomShareUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutRoomInput | RoomShareCreateOrConnectWithoutRoomInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutRoomInput | RoomShareUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomShareCreateManyRoomInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutRoomInput | RoomShareUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutRoomInput | RoomShareUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutRoomInput | RoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutRoomInput | RoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutRoomInput | RoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomShareUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput> | RoomShareCreateWithoutRoomInput[] | RoomShareUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomShareCreateOrConnectWithoutRoomInput | RoomShareCreateOrConnectWithoutRoomInput[]
    upsert?: RoomShareUpsertWithWhereUniqueWithoutRoomInput | RoomShareUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomShareCreateManyRoomInputEnvelope
    set?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    disconnect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    delete?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    connect?: RoomShareWhereUniqueInput | RoomShareWhereUniqueInput[]
    update?: RoomShareUpdateWithWhereUniqueWithoutRoomInput | RoomShareUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomShareUpdateManyWithWhereWithoutRoomInput | RoomShareUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMembershipsInput
    connect?: RoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomMembershipsInput = {
    create?: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMemberRoleFieldUpdateOperationsInput = {
    set?: $Enums.MemberRole
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type UserUpdateOneWithoutInvitationsSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    upsert?: UserUpsertWithoutInvitationsSentInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsSentInput, UserUpdateWithoutInvitationsSentInput>, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type RoomUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMembershipsInput
    upsert?: RoomUpsertWithoutMembershipsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutMembershipsInput, RoomUpdateWithoutMembershipsInput>, RoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutRoomMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMembershipsInput
    upsert?: UserUpsertWithoutRoomMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomMembershipsInput, UserUpdateWithoutRoomMembershipsInput>, UserUncheckedUpdateWithoutRoomMembershipsInput>
  }

  export type RoomCreateNestedOneWithoutSharesInput = {
    create?: XOR<RoomCreateWithoutSharesInput, RoomUncheckedCreateWithoutSharesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutSharesInput
    connect?: RoomWhereUniqueInput
  }

  export type ContentArtifactCreateNestedOneWithoutSharesInput = {
    create?: XOR<ContentArtifactCreateWithoutSharesInput, ContentArtifactUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutSharesInput
    connect?: ContentArtifactWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomSharesInput = {
    create?: XOR<UserCreateWithoutRoomSharesInput, UserUncheckedCreateWithoutRoomSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomSharesInput
    connect?: UserWhereUniqueInput
  }

  export type RoomNoteCreateNestedManyWithoutShareInput = {
    create?: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput> | RoomNoteCreateWithoutShareInput[] | RoomNoteUncheckedCreateWithoutShareInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutShareInput | RoomNoteCreateOrConnectWithoutShareInput[]
    createMany?: RoomNoteCreateManyShareInputEnvelope
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
  }

  export type RoomNoteUncheckedCreateNestedManyWithoutShareInput = {
    create?: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput> | RoomNoteCreateWithoutShareInput[] | RoomNoteUncheckedCreateWithoutShareInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutShareInput | RoomNoteCreateOrConnectWithoutShareInput[]
    createMany?: RoomNoteCreateManyShareInputEnvelope
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
  }

  export type RoomUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<RoomCreateWithoutSharesInput, RoomUncheckedCreateWithoutSharesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutSharesInput
    upsert?: RoomUpsertWithoutSharesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutSharesInput, RoomUpdateWithoutSharesInput>, RoomUncheckedUpdateWithoutSharesInput>
  }

  export type ContentArtifactUpdateOneRequiredWithoutSharesNestedInput = {
    create?: XOR<ContentArtifactCreateWithoutSharesInput, ContentArtifactUncheckedCreateWithoutSharesInput>
    connectOrCreate?: ContentArtifactCreateOrConnectWithoutSharesInput
    upsert?: ContentArtifactUpsertWithoutSharesInput
    connect?: ContentArtifactWhereUniqueInput
    update?: XOR<XOR<ContentArtifactUpdateToOneWithWhereWithoutSharesInput, ContentArtifactUpdateWithoutSharesInput>, ContentArtifactUncheckedUpdateWithoutSharesInput>
  }

  export type UserUpdateOneRequiredWithoutRoomSharesNestedInput = {
    create?: XOR<UserCreateWithoutRoomSharesInput, UserUncheckedCreateWithoutRoomSharesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomSharesInput
    upsert?: UserUpsertWithoutRoomSharesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomSharesInput, UserUpdateWithoutRoomSharesInput>, UserUncheckedUpdateWithoutRoomSharesInput>
  }

  export type RoomNoteUpdateManyWithoutShareNestedInput = {
    create?: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput> | RoomNoteCreateWithoutShareInput[] | RoomNoteUncheckedCreateWithoutShareInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutShareInput | RoomNoteCreateOrConnectWithoutShareInput[]
    upsert?: RoomNoteUpsertWithWhereUniqueWithoutShareInput | RoomNoteUpsertWithWhereUniqueWithoutShareInput[]
    createMany?: RoomNoteCreateManyShareInputEnvelope
    set?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    disconnect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    delete?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    update?: RoomNoteUpdateWithWhereUniqueWithoutShareInput | RoomNoteUpdateWithWhereUniqueWithoutShareInput[]
    updateMany?: RoomNoteUpdateManyWithWhereWithoutShareInput | RoomNoteUpdateManyWithWhereWithoutShareInput[]
    deleteMany?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
  }

  export type RoomNoteUncheckedUpdateManyWithoutShareNestedInput = {
    create?: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput> | RoomNoteCreateWithoutShareInput[] | RoomNoteUncheckedCreateWithoutShareInput[]
    connectOrCreate?: RoomNoteCreateOrConnectWithoutShareInput | RoomNoteCreateOrConnectWithoutShareInput[]
    upsert?: RoomNoteUpsertWithWhereUniqueWithoutShareInput | RoomNoteUpsertWithWhereUniqueWithoutShareInput[]
    createMany?: RoomNoteCreateManyShareInputEnvelope
    set?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    disconnect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    delete?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    connect?: RoomNoteWhereUniqueInput | RoomNoteWhereUniqueInput[]
    update?: RoomNoteUpdateWithWhereUniqueWithoutShareInput | RoomNoteUpdateWithWhereUniqueWithoutShareInput[]
    updateMany?: RoomNoteUpdateManyWithWhereWithoutShareInput | RoomNoteUpdateManyWithWhereWithoutShareInput[]
    deleteMany?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
  }

  export type RoomShareCreateNestedOneWithoutNotesInput = {
    create?: XOR<RoomShareCreateWithoutNotesInput, RoomShareUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomShareCreateOrConnectWithoutNotesInput
    connect?: RoomShareWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomNotesInput = {
    create?: XOR<UserCreateWithoutRoomNotesInput, UserUncheckedCreateWithoutRoomNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomNotesInput
    connect?: UserWhereUniqueInput
  }

  export type RoomShareUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<RoomShareCreateWithoutNotesInput, RoomShareUncheckedCreateWithoutNotesInput>
    connectOrCreate?: RoomShareCreateOrConnectWithoutNotesInput
    upsert?: RoomShareUpsertWithoutNotesInput
    connect?: RoomShareWhereUniqueInput
    update?: XOR<XOR<RoomShareUpdateToOneWithWhereWithoutNotesInput, RoomShareUpdateWithoutNotesInput>, RoomShareUncheckedUpdateWithoutNotesInput>
  }

  export type UserUpdateOneRequiredWithoutRoomNotesNestedInput = {
    create?: XOR<UserCreateWithoutRoomNotesInput, UserUncheckedCreateWithoutRoomNotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomNotesInput
    upsert?: UserUpsertWithoutRoomNotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomNotesInput, UserUpdateWithoutRoomNotesInput>, UserUncheckedUpdateWithoutRoomNotesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumSourceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeFilter<$PrismaModel> | $Enums.SourceType
  }

  export type NestedEnumProcessingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusFilter<$PrismaModel> | $Enums.ProcessingStatus
  }

  export type NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SourceType | EnumSourceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SourceType[] | ListEnumSourceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSourceTypeWithAggregatesFilter<$PrismaModel> | $Enums.SourceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSourceTypeFilter<$PrismaModel>
    _max?: NestedEnumSourceTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProcessingStatus | EnumProcessingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProcessingStatus[] | ListEnumProcessingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProcessingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProcessingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProcessingStatusFilter<$PrismaModel>
    _max?: NestedEnumProcessingStatusFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumArtifactTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeFilter<$PrismaModel> | $Enums.ArtifactType
  }

  export type NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ArtifactType | EnumArtifactTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ArtifactType[] | ListEnumArtifactTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumArtifactTypeWithAggregatesFilter<$PrismaModel> | $Enums.ArtifactType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumArtifactTypeFilter<$PrismaModel>
    _max?: NestedEnumArtifactTypeFilter<$PrismaModel>
  }

  export type NestedEnumChatRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRole | EnumChatRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoleFilter<$PrismaModel> | $Enums.ChatRole
  }

  export type NestedEnumChatRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChatRole | EnumChatRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChatRole[] | ListEnumChatRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumChatRoleWithAggregatesFilter<$PrismaModel> | $Enums.ChatRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChatRoleFilter<$PrismaModel>
    _max?: NestedEnumChatRoleFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumMemberRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleFilter<$PrismaModel> | $Enums.MemberRole
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberRole | EnumMemberRoleFieldRefInput<$PrismaModel>
    in?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberRole[] | ListEnumMemberRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberRoleWithAggregatesFilter<$PrismaModel> | $Enums.MemberRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberRoleFilter<$PrismaModel>
    _max?: NestedEnumMemberRoleFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FolderCreateWithoutOwnerInput = {
    id: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    lectures?: LectureCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutOwnerInput = {
    id: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    lectures?: LectureUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutOwnerInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput>
  }

  export type FolderCreateManyOwnerInputEnvelope = {
    data: FolderCreateManyOwnerInput | FolderCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type LectureCreateWithoutOwnerInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    folder: FolderCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutOwnerInput = {
    id: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutOwnerInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput>
  }

  export type LectureCreateManyOwnerInputEnvelope = {
    data: LectureCreateManyOwnerInput | LectureCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type BookmarkCreateWithoutUserInput = {
    createdAt: Date | string
    lecture: LectureCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutUserInput = {
    lectureId: string
    createdAt: Date | string
  }

  export type BookmarkCreateOrConnectWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkCreateManyUserInputEnvelope = {
    data: BookmarkCreateManyUserInput | BookmarkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutOwnerInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    memberships?: RoomMembershipCreateNestedManyWithoutRoomInput
    shares?: RoomShareCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutOwnerInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    memberships?: RoomMembershipUncheckedCreateNestedManyWithoutRoomInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomCreateManyOwnerInputEnvelope = {
    data: RoomCreateManyOwnerInput | RoomCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type RoomMembershipCreateWithoutUserInput = {
    id: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    invitedBy?: UserCreateNestedOneWithoutInvitationsSentInput
    room: RoomCreateNestedOneWithoutMembershipsInput
  }

  export type RoomMembershipUncheckedCreateWithoutUserInput = {
    id: string
    roomId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipCreateOrConnectWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    create: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type RoomMembershipCreateManyUserInputEnvelope = {
    data: RoomMembershipCreateManyUserInput | RoomMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoomMembershipCreateWithoutInvitedByInput = {
    id: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    room: RoomCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutRoomMembershipsInput
  }

  export type RoomMembershipUncheckedCreateWithoutInvitedByInput = {
    id: string
    roomId: string
    userId: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipCreateOrConnectWithoutInvitedByInput = {
    where: RoomMembershipWhereUniqueInput
    create: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput>
  }

  export type RoomMembershipCreateManyInvitedByInputEnvelope = {
    data: RoomMembershipCreateManyInvitedByInput | RoomMembershipCreateManyInvitedByInput[]
    skipDuplicates?: boolean
  }

  export type ContentArtifactCreateWithoutOwnerInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutOwnerInput = {
    id: string
    lectureId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutOwnerInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput>
  }

  export type ContentArtifactCreateManyOwnerInputEnvelope = {
    data: ContentArtifactCreateManyOwnerInput | ContentArtifactCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type RoomShareCreateWithoutSharedByInput = {
    id: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    room: RoomCreateNestedOneWithoutSharesInput
    artifact: ContentArtifactCreateNestedOneWithoutSharesInput
    notes?: RoomNoteCreateNestedManyWithoutShareInput
  }

  export type RoomShareUncheckedCreateWithoutSharedByInput = {
    id: string
    roomId: string
    artifactId: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    notes?: RoomNoteUncheckedCreateNestedManyWithoutShareInput
  }

  export type RoomShareCreateOrConnectWithoutSharedByInput = {
    where: RoomShareWhereUniqueInput
    create: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput>
  }

  export type RoomShareCreateManySharedByInputEnvelope = {
    data: RoomShareCreateManySharedByInput | RoomShareCreateManySharedByInput[]
    skipDuplicates?: boolean
  }

  export type RoomNoteCreateWithoutAuthorInput = {
    id: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    share: RoomShareCreateNestedOneWithoutNotesInput
  }

  export type RoomNoteUncheckedCreateWithoutAuthorInput = {
    id: string
    shareId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteCreateOrConnectWithoutAuthorInput = {
    where: RoomNoteWhereUniqueInput
    create: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput>
  }

  export type RoomNoteCreateManyAuthorInputEnvelope = {
    data: RoomNoteCreateManyAuthorInput | RoomNoteCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    expiresAt?: DateTimeFilter<"Session"> | Date | string
    token?: StringFilter<"Session"> | string
    createdAt?: DateTimeFilter<"Session"> | Date | string
    updatedAt?: DateTimeFilter<"Session"> | Date | string
    ipAddress?: StringNullableFilter<"Session"> | string | null
    userAgent?: StringNullableFilter<"Session"> | string | null
    userId?: StringFilter<"Session"> | string
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    accountId?: StringFilter<"Account"> | string
    providerId?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    accessToken?: StringNullableFilter<"Account"> | string | null
    refreshToken?: StringNullableFilter<"Account"> | string | null
    idToken?: StringNullableFilter<"Account"> | string | null
    accessTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    refreshTokenExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    password?: StringNullableFilter<"Account"> | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
  }

  export type FolderUpsertWithWhereUniqueWithoutOwnerInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutOwnerInput, FolderUncheckedUpdateWithoutOwnerInput>
    create: XOR<FolderCreateWithoutOwnerInput, FolderUncheckedCreateWithoutOwnerInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutOwnerInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutOwnerInput, FolderUncheckedUpdateWithoutOwnerInput>
  }

  export type FolderUpdateManyWithWhereWithoutOwnerInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutOwnerInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    ownerId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    color?: StringNullableFilter<"Folder"> | string | null
    emoji?: StringNullableFilter<"Folder"> | string | null
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
  }

  export type LectureUpsertWithWhereUniqueWithoutOwnerInput = {
    where: LectureWhereUniqueInput
    update: XOR<LectureUpdateWithoutOwnerInput, LectureUncheckedUpdateWithoutOwnerInput>
    create: XOR<LectureCreateWithoutOwnerInput, LectureUncheckedCreateWithoutOwnerInput>
  }

  export type LectureUpdateWithWhereUniqueWithoutOwnerInput = {
    where: LectureWhereUniqueInput
    data: XOR<LectureUpdateWithoutOwnerInput, LectureUncheckedUpdateWithoutOwnerInput>
  }

  export type LectureUpdateManyWithWhereWithoutOwnerInput = {
    where: LectureScalarWhereInput
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutOwnerInput>
  }

  export type LectureScalarWhereInput = {
    AND?: LectureScalarWhereInput | LectureScalarWhereInput[]
    OR?: LectureScalarWhereInput[]
    NOT?: LectureScalarWhereInput | LectureScalarWhereInput[]
    id?: StringFilter<"Lecture"> | string
    ownerId?: StringFilter<"Lecture"> | string
    folderId?: StringFilter<"Lecture"> | string
    title?: StringFilter<"Lecture"> | string
    description?: StringNullableFilter<"Lecture"> | string | null
    language?: StringNullableFilter<"Lecture"> | string | null
    createdAt?: DateTimeFilter<"Lecture"> | Date | string
    updatedAt?: DateTimeFilter<"Lecture"> | Date | string
  }

  export type BookmarkUpsertWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
    create: XOR<BookmarkCreateWithoutUserInput, BookmarkUncheckedCreateWithoutUserInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutUserInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutUserInput, BookmarkUncheckedUpdateWithoutUserInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutUserInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutUserInput>
  }

  export type BookmarkScalarWhereInput = {
    AND?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    OR?: BookmarkScalarWhereInput[]
    NOT?: BookmarkScalarWhereInput | BookmarkScalarWhereInput[]
    userId?: StringFilter<"Bookmark"> | string
    lectureId?: StringFilter<"Bookmark"> | string
    createdAt?: DateTimeFilter<"Bookmark"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
  }

  export type RoomUpdateManyWithWhereWithoutOwnerInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    description?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    isPrivate?: BoolNullableFilter<"Room"> | boolean | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type RoomMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    update: XOR<RoomMembershipUpdateWithoutUserInput, RoomMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type RoomMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    data: XOR<RoomMembershipUpdateWithoutUserInput, RoomMembershipUncheckedUpdateWithoutUserInput>
  }

  export type RoomMembershipUpdateManyWithWhereWithoutUserInput = {
    where: RoomMembershipScalarWhereInput
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type RoomMembershipScalarWhereInput = {
    AND?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
    OR?: RoomMembershipScalarWhereInput[]
    NOT?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
    id?: StringFilter<"RoomMembership"> | string
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    invitedById?: StringNullableFilter<"RoomMembership"> | string | null
    role?: EnumMemberRoleFilter<"RoomMembership"> | $Enums.MemberRole
    status?: EnumMemberStatusFilter<"RoomMembership"> | $Enums.MemberStatus
    joinedAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
  }

  export type RoomMembershipUpsertWithWhereUniqueWithoutInvitedByInput = {
    where: RoomMembershipWhereUniqueInput
    update: XOR<RoomMembershipUpdateWithoutInvitedByInput, RoomMembershipUncheckedUpdateWithoutInvitedByInput>
    create: XOR<RoomMembershipCreateWithoutInvitedByInput, RoomMembershipUncheckedCreateWithoutInvitedByInput>
  }

  export type RoomMembershipUpdateWithWhereUniqueWithoutInvitedByInput = {
    where: RoomMembershipWhereUniqueInput
    data: XOR<RoomMembershipUpdateWithoutInvitedByInput, RoomMembershipUncheckedUpdateWithoutInvitedByInput>
  }

  export type RoomMembershipUpdateManyWithWhereWithoutInvitedByInput = {
    where: RoomMembershipScalarWhereInput
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyWithoutInvitedByInput>
  }

  export type ContentArtifactUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ContentArtifactWhereUniqueInput
    update: XOR<ContentArtifactUpdateWithoutOwnerInput, ContentArtifactUncheckedUpdateWithoutOwnerInput>
    create: XOR<ContentArtifactCreateWithoutOwnerInput, ContentArtifactUncheckedCreateWithoutOwnerInput>
  }

  export type ContentArtifactUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ContentArtifactWhereUniqueInput
    data: XOR<ContentArtifactUpdateWithoutOwnerInput, ContentArtifactUncheckedUpdateWithoutOwnerInput>
  }

  export type ContentArtifactUpdateManyWithWhereWithoutOwnerInput = {
    where: ContentArtifactScalarWhereInput
    data: XOR<ContentArtifactUpdateManyMutationInput, ContentArtifactUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ContentArtifactScalarWhereInput = {
    AND?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
    OR?: ContentArtifactScalarWhereInput[]
    NOT?: ContentArtifactScalarWhereInput | ContentArtifactScalarWhereInput[]
    id?: StringFilter<"ContentArtifact"> | string
    lectureId?: StringFilter<"ContentArtifact"> | string
    ownerId?: StringFilter<"ContentArtifact"> | string
    type?: EnumArtifactTypeFilter<"ContentArtifact"> | $Enums.ArtifactType
    title?: StringFilter<"ContentArtifact"> | string
    description?: StringNullableFilter<"ContentArtifact"> | string | null
    language?: StringNullableFilter<"ContentArtifact"> | string | null
    status?: EnumProcessingStatusFilter<"ContentArtifact"> | $Enums.ProcessingStatus
    coverImageUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    fileUrl?: StringNullableFilter<"ContentArtifact"> | string | null
    transcript?: StringNullableFilter<"ContentArtifact"> | string | null
    durationSeconds?: IntNullableFilter<"ContentArtifact"> | number | null
    metadata?: JsonNullableFilter<"ContentArtifact">
    createdAt?: DateTimeFilter<"ContentArtifact"> | Date | string
    updatedAt?: DateTimeFilter<"ContentArtifact"> | Date | string
  }

  export type RoomShareUpsertWithWhereUniqueWithoutSharedByInput = {
    where: RoomShareWhereUniqueInput
    update: XOR<RoomShareUpdateWithoutSharedByInput, RoomShareUncheckedUpdateWithoutSharedByInput>
    create: XOR<RoomShareCreateWithoutSharedByInput, RoomShareUncheckedCreateWithoutSharedByInput>
  }

  export type RoomShareUpdateWithWhereUniqueWithoutSharedByInput = {
    where: RoomShareWhereUniqueInput
    data: XOR<RoomShareUpdateWithoutSharedByInput, RoomShareUncheckedUpdateWithoutSharedByInput>
  }

  export type RoomShareUpdateManyWithWhereWithoutSharedByInput = {
    where: RoomShareScalarWhereInput
    data: XOR<RoomShareUpdateManyMutationInput, RoomShareUncheckedUpdateManyWithoutSharedByInput>
  }

  export type RoomShareScalarWhereInput = {
    AND?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
    OR?: RoomShareScalarWhereInput[]
    NOT?: RoomShareScalarWhereInput | RoomShareScalarWhereInput[]
    id?: StringFilter<"RoomShare"> | string
    roomId?: StringFilter<"RoomShare"> | string
    artifactId?: StringFilter<"RoomShare"> | string
    sharedById?: StringFilter<"RoomShare"> | string
    caption?: StringNullableFilter<"RoomShare"> | string | null
    metadata?: JsonNullableFilter<"RoomShare">
    createdAt?: DateTimeFilter<"RoomShare"> | Date | string
    updatedAt?: DateTimeFilter<"RoomShare"> | Date | string
  }

  export type RoomNoteUpsertWithWhereUniqueWithoutAuthorInput = {
    where: RoomNoteWhereUniqueInput
    update: XOR<RoomNoteUpdateWithoutAuthorInput, RoomNoteUncheckedUpdateWithoutAuthorInput>
    create: XOR<RoomNoteCreateWithoutAuthorInput, RoomNoteUncheckedCreateWithoutAuthorInput>
  }

  export type RoomNoteUpdateWithWhereUniqueWithoutAuthorInput = {
    where: RoomNoteWhereUniqueInput
    data: XOR<RoomNoteUpdateWithoutAuthorInput, RoomNoteUncheckedUpdateWithoutAuthorInput>
  }

  export type RoomNoteUpdateManyWithWhereWithoutAuthorInput = {
    where: RoomNoteScalarWhereInput
    data: XOR<RoomNoteUpdateManyMutationInput, RoomNoteUncheckedUpdateManyWithoutAuthorInput>
  }

  export type RoomNoteScalarWhereInput = {
    AND?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
    OR?: RoomNoteScalarWhereInput[]
    NOT?: RoomNoteScalarWhereInput | RoomNoteScalarWhereInput[]
    id?: StringFilter<"RoomNote"> | string
    shareId?: StringFilter<"RoomNote"> | string
    authorId?: StringFilter<"RoomNote"> | string
    content?: StringFilter<"RoomNote"> | string
    metadata?: JsonNullableFilter<"RoomNote">
    createdAt?: DateTimeFilter<"RoomNote"> | Date | string
    updatedAt?: DateTimeFilter<"RoomNote"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateWithoutFoldersInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutFoldersInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutFoldersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFoldersInput, UserUncheckedCreateWithoutFoldersInput>
  }

  export type LectureCreateWithoutFolderInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutFolderInput = {
    id: string
    ownerId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutFolderInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput>
  }

  export type LectureCreateManyFolderInputEnvelope = {
    data: LectureCreateManyFolderInput | LectureCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFoldersInput = {
    update: XOR<UserUpdateWithoutFoldersInput, UserUncheckedUpdateWithoutFoldersInput>
    create: XOR<UserCreateWithoutFoldersInput, UserUncheckedCreateWithoutFoldersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFoldersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFoldersInput, UserUncheckedUpdateWithoutFoldersInput>
  }

  export type UserUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type LectureUpsertWithWhereUniqueWithoutFolderInput = {
    where: LectureWhereUniqueInput
    update: XOR<LectureUpdateWithoutFolderInput, LectureUncheckedUpdateWithoutFolderInput>
    create: XOR<LectureCreateWithoutFolderInput, LectureUncheckedCreateWithoutFolderInput>
  }

  export type LectureUpdateWithWhereUniqueWithoutFolderInput = {
    where: LectureWhereUniqueInput
    data: XOR<LectureUpdateWithoutFolderInput, LectureUncheckedUpdateWithoutFolderInput>
  }

  export type LectureUpdateManyWithWhereWithoutFolderInput = {
    where: LectureScalarWhereInput
    data: XOR<LectureUpdateManyMutationInput, LectureUncheckedUpdateManyWithoutFolderInput>
  }

  export type UserCreateWithoutLecturesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutLecturesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutLecturesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
  }

  export type FolderCreateWithoutLecturesInput = {
    id: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutFoldersInput
  }

  export type FolderUncheckedCreateWithoutLecturesInput = {
    id: string
    ownerId: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FolderCreateOrConnectWithoutLecturesInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutLecturesInput, FolderUncheckedCreateWithoutLecturesInput>
  }

  export type LectureSourceCreateWithoutLectureInput = {
    id: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifacts?: ArtifactSourceCreateNestedManyWithoutSourceInput
  }

  export type LectureSourceUncheckedCreateWithoutLectureInput = {
    id: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifacts?: ArtifactSourceUncheckedCreateNestedManyWithoutSourceInput
  }

  export type LectureSourceCreateOrConnectWithoutLectureInput = {
    where: LectureSourceWhereUniqueInput
    create: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput>
  }

  export type LectureSourceCreateManyLectureInputEnvelope = {
    data: LectureSourceCreateManyLectureInput | LectureSourceCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type ContentArtifactCreateWithoutLectureInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutLectureInput = {
    id: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutLectureInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput>
  }

  export type ContentArtifactCreateManyLectureInputEnvelope = {
    data: ContentArtifactCreateManyLectureInput | ContentArtifactCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type LectureAssistantCreateWithoutLectureInput = {
    id: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    messages?: ChatMessageCreateNestedManyWithoutAssistantInput
  }

  export type LectureAssistantUncheckedCreateWithoutLectureInput = {
    id: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutAssistantInput
  }

  export type LectureAssistantCreateOrConnectWithoutLectureInput = {
    where: LectureAssistantWhereUniqueInput
    create: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
  }

  export type BookmarkCreateWithoutLectureInput = {
    createdAt: Date | string
    user: UserCreateNestedOneWithoutBookmarksInput
  }

  export type BookmarkUncheckedCreateWithoutLectureInput = {
    userId: string
    createdAt: Date | string
  }

  export type BookmarkCreateOrConnectWithoutLectureInput = {
    where: BookmarkWhereUniqueInput
    create: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput>
  }

  export type BookmarkCreateManyLectureInputEnvelope = {
    data: BookmarkCreateManyLectureInput | BookmarkCreateManyLectureInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLecturesInput = {
    update: XOR<UserUpdateWithoutLecturesInput, UserUncheckedUpdateWithoutLecturesInput>
    create: XOR<UserCreateWithoutLecturesInput, UserUncheckedCreateWithoutLecturesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLecturesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLecturesInput, UserUncheckedUpdateWithoutLecturesInput>
  }

  export type UserUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type FolderUpsertWithoutLecturesInput = {
    update: XOR<FolderUpdateWithoutLecturesInput, FolderUncheckedUpdateWithoutLecturesInput>
    create: XOR<FolderCreateWithoutLecturesInput, FolderUncheckedCreateWithoutLecturesInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutLecturesInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutLecturesInput, FolderUncheckedUpdateWithoutLecturesInput>
  }

  export type FolderUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFoldersNestedInput
  }

  export type FolderUncheckedUpdateWithoutLecturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureSourceUpsertWithWhereUniqueWithoutLectureInput = {
    where: LectureSourceWhereUniqueInput
    update: XOR<LectureSourceUpdateWithoutLectureInput, LectureSourceUncheckedUpdateWithoutLectureInput>
    create: XOR<LectureSourceCreateWithoutLectureInput, LectureSourceUncheckedCreateWithoutLectureInput>
  }

  export type LectureSourceUpdateWithWhereUniqueWithoutLectureInput = {
    where: LectureSourceWhereUniqueInput
    data: XOR<LectureSourceUpdateWithoutLectureInput, LectureSourceUncheckedUpdateWithoutLectureInput>
  }

  export type LectureSourceUpdateManyWithWhereWithoutLectureInput = {
    where: LectureSourceScalarWhereInput
    data: XOR<LectureSourceUpdateManyMutationInput, LectureSourceUncheckedUpdateManyWithoutLectureInput>
  }

  export type LectureSourceScalarWhereInput = {
    AND?: LectureSourceScalarWhereInput | LectureSourceScalarWhereInput[]
    OR?: LectureSourceScalarWhereInput[]
    NOT?: LectureSourceScalarWhereInput | LectureSourceScalarWhereInput[]
    id?: StringFilter<"LectureSource"> | string
    lectureId?: StringFilter<"LectureSource"> | string
    kind?: EnumSourceTypeFilter<"LectureSource"> | $Enums.SourceType
    title?: StringNullableFilter<"LectureSource"> | string | null
    url?: StringNullableFilter<"LectureSource"> | string | null
    fileKey?: StringNullableFilter<"LectureSource"> | string | null
    textContent?: StringNullableFilter<"LectureSource"> | string | null
    transcript?: StringNullableFilter<"LectureSource"> | string | null
    language?: StringNullableFilter<"LectureSource"> | string | null
    durationSeconds?: IntNullableFilter<"LectureSource"> | number | null
    pageCount?: IntNullableFilter<"LectureSource"> | number | null
    checksum?: StringNullableFilter<"LectureSource"> | string | null
    status?: EnumProcessingStatusFilter<"LectureSource"> | $Enums.ProcessingStatus
    metadata?: JsonNullableFilter<"LectureSource">
    createdAt?: DateTimeFilter<"LectureSource"> | Date | string
    updatedAt?: DateTimeFilter<"LectureSource"> | Date | string
  }

  export type ContentArtifactUpsertWithWhereUniqueWithoutLectureInput = {
    where: ContentArtifactWhereUniqueInput
    update: XOR<ContentArtifactUpdateWithoutLectureInput, ContentArtifactUncheckedUpdateWithoutLectureInput>
    create: XOR<ContentArtifactCreateWithoutLectureInput, ContentArtifactUncheckedCreateWithoutLectureInput>
  }

  export type ContentArtifactUpdateWithWhereUniqueWithoutLectureInput = {
    where: ContentArtifactWhereUniqueInput
    data: XOR<ContentArtifactUpdateWithoutLectureInput, ContentArtifactUncheckedUpdateWithoutLectureInput>
  }

  export type ContentArtifactUpdateManyWithWhereWithoutLectureInput = {
    where: ContentArtifactScalarWhereInput
    data: XOR<ContentArtifactUpdateManyMutationInput, ContentArtifactUncheckedUpdateManyWithoutLectureInput>
  }

  export type LectureAssistantUpsertWithoutLectureInput = {
    update: XOR<LectureAssistantUpdateWithoutLectureInput, LectureAssistantUncheckedUpdateWithoutLectureInput>
    create: XOR<LectureAssistantCreateWithoutLectureInput, LectureAssistantUncheckedCreateWithoutLectureInput>
    where?: LectureAssistantWhereInput
  }

  export type LectureAssistantUpdateToOneWithWhereWithoutLectureInput = {
    where?: LectureAssistantWhereInput
    data: XOR<LectureAssistantUpdateWithoutLectureInput, LectureAssistantUncheckedUpdateWithoutLectureInput>
  }

  export type LectureAssistantUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutAssistantNestedInput
  }

  export type LectureAssistantUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutAssistantNestedInput
  }

  export type BookmarkUpsertWithWhereUniqueWithoutLectureInput = {
    where: BookmarkWhereUniqueInput
    update: XOR<BookmarkUpdateWithoutLectureInput, BookmarkUncheckedUpdateWithoutLectureInput>
    create: XOR<BookmarkCreateWithoutLectureInput, BookmarkUncheckedCreateWithoutLectureInput>
  }

  export type BookmarkUpdateWithWhereUniqueWithoutLectureInput = {
    where: BookmarkWhereUniqueInput
    data: XOR<BookmarkUpdateWithoutLectureInput, BookmarkUncheckedUpdateWithoutLectureInput>
  }

  export type BookmarkUpdateManyWithWhereWithoutLectureInput = {
    where: BookmarkScalarWhereInput
    data: XOR<BookmarkUpdateManyMutationInput, BookmarkUncheckedUpdateManyWithoutLectureInput>
  }

  export type LectureCreateWithoutSourcesInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    folder: FolderCreateNestedOneWithoutLecturesInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutSourcesInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutSourcesInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutSourcesInput, LectureUncheckedCreateWithoutSourcesInput>
  }

  export type ArtifactSourceCreateWithoutSourceInput = {
    artifact: ContentArtifactCreateNestedOneWithoutSourcesInput
  }

  export type ArtifactSourceUncheckedCreateWithoutSourceInput = {
    artifactId: string
  }

  export type ArtifactSourceCreateOrConnectWithoutSourceInput = {
    where: ArtifactSourceWhereUniqueInput
    create: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput>
  }

  export type ArtifactSourceCreateManySourceInputEnvelope = {
    data: ArtifactSourceCreateManySourceInput | ArtifactSourceCreateManySourceInput[]
    skipDuplicates?: boolean
  }

  export type LectureUpsertWithoutSourcesInput = {
    update: XOR<LectureUpdateWithoutSourcesInput, LectureUncheckedUpdateWithoutSourcesInput>
    create: XOR<LectureCreateWithoutSourcesInput, LectureUncheckedCreateWithoutSourcesInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutSourcesInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutSourcesInput, LectureUncheckedUpdateWithoutSourcesInput>
  }

  export type LectureUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type ArtifactSourceUpsertWithWhereUniqueWithoutSourceInput = {
    where: ArtifactSourceWhereUniqueInput
    update: XOR<ArtifactSourceUpdateWithoutSourceInput, ArtifactSourceUncheckedUpdateWithoutSourceInput>
    create: XOR<ArtifactSourceCreateWithoutSourceInput, ArtifactSourceUncheckedCreateWithoutSourceInput>
  }

  export type ArtifactSourceUpdateWithWhereUniqueWithoutSourceInput = {
    where: ArtifactSourceWhereUniqueInput
    data: XOR<ArtifactSourceUpdateWithoutSourceInput, ArtifactSourceUncheckedUpdateWithoutSourceInput>
  }

  export type ArtifactSourceUpdateManyWithWhereWithoutSourceInput = {
    where: ArtifactSourceScalarWhereInput
    data: XOR<ArtifactSourceUpdateManyMutationInput, ArtifactSourceUncheckedUpdateManyWithoutSourceInput>
  }

  export type ArtifactSourceScalarWhereInput = {
    AND?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
    OR?: ArtifactSourceScalarWhereInput[]
    NOT?: ArtifactSourceScalarWhereInput | ArtifactSourceScalarWhereInput[]
    artifactId?: StringFilter<"ArtifactSource"> | string
    sourceId?: StringFilter<"ArtifactSource"> | string
  }

  export type LectureCreateWithoutArtifactsInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    folder: FolderCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutArtifactsInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutArtifactsInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutArtifactsInput, LectureUncheckedCreateWithoutArtifactsInput>
  }

  export type UserCreateWithoutArtifactsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutArtifactsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutArtifactsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArtifactsInput, UserUncheckedCreateWithoutArtifactsInput>
  }

  export type QAPairCreateWithoutArtifactInput = {
    id: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type QAPairUncheckedCreateWithoutArtifactInput = {
    id: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type QAPairCreateOrConnectWithoutArtifactInput = {
    where: QAPairWhereUniqueInput
    create: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput>
  }

  export type QAPairCreateManyArtifactInputEnvelope = {
    data: QAPairCreateManyArtifactInput | QAPairCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type FlashcardCreateWithoutArtifactInput = {
    id: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FlashcardUncheckedCreateWithoutArtifactInput = {
    id: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FlashcardCreateOrConnectWithoutArtifactInput = {
    where: FlashcardWhereUniqueInput
    create: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput>
  }

  export type FlashcardCreateManyArtifactInputEnvelope = {
    data: FlashcardCreateManyArtifactInput | FlashcardCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type RoomShareCreateWithoutArtifactInput = {
    id: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    room: RoomCreateNestedOneWithoutSharesInput
    sharedBy: UserCreateNestedOneWithoutRoomSharesInput
    notes?: RoomNoteCreateNestedManyWithoutShareInput
  }

  export type RoomShareUncheckedCreateWithoutArtifactInput = {
    id: string
    roomId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    notes?: RoomNoteUncheckedCreateNestedManyWithoutShareInput
  }

  export type RoomShareCreateOrConnectWithoutArtifactInput = {
    where: RoomShareWhereUniqueInput
    create: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput>
  }

  export type RoomShareCreateManyArtifactInputEnvelope = {
    data: RoomShareCreateManyArtifactInput | RoomShareCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type ArtifactSourceCreateWithoutArtifactInput = {
    source: LectureSourceCreateNestedOneWithoutArtifactsInput
  }

  export type ArtifactSourceUncheckedCreateWithoutArtifactInput = {
    sourceId: string
  }

  export type ArtifactSourceCreateOrConnectWithoutArtifactInput = {
    where: ArtifactSourceWhereUniqueInput
    create: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput>
  }

  export type ArtifactSourceCreateManyArtifactInputEnvelope = {
    data: ArtifactSourceCreateManyArtifactInput | ArtifactSourceCreateManyArtifactInput[]
    skipDuplicates?: boolean
  }

  export type LectureUpsertWithoutArtifactsInput = {
    update: XOR<LectureUpdateWithoutArtifactsInput, LectureUncheckedUpdateWithoutArtifactsInput>
    create: XOR<LectureCreateWithoutArtifactsInput, LectureUncheckedCreateWithoutArtifactsInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutArtifactsInput, LectureUncheckedUpdateWithoutArtifactsInput>
  }

  export type LectureUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type UserUpsertWithoutArtifactsInput = {
    update: XOR<UserUpdateWithoutArtifactsInput, UserUncheckedUpdateWithoutArtifactsInput>
    create: XOR<UserCreateWithoutArtifactsInput, UserUncheckedCreateWithoutArtifactsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArtifactsInput, UserUncheckedUpdateWithoutArtifactsInput>
  }

  export type UserUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type QAPairUpsertWithWhereUniqueWithoutArtifactInput = {
    where: QAPairWhereUniqueInput
    update: XOR<QAPairUpdateWithoutArtifactInput, QAPairUncheckedUpdateWithoutArtifactInput>
    create: XOR<QAPairCreateWithoutArtifactInput, QAPairUncheckedCreateWithoutArtifactInput>
  }

  export type QAPairUpdateWithWhereUniqueWithoutArtifactInput = {
    where: QAPairWhereUniqueInput
    data: XOR<QAPairUpdateWithoutArtifactInput, QAPairUncheckedUpdateWithoutArtifactInput>
  }

  export type QAPairUpdateManyWithWhereWithoutArtifactInput = {
    where: QAPairScalarWhereInput
    data: XOR<QAPairUpdateManyMutationInput, QAPairUncheckedUpdateManyWithoutArtifactInput>
  }

  export type QAPairScalarWhereInput = {
    AND?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
    OR?: QAPairScalarWhereInput[]
    NOT?: QAPairScalarWhereInput | QAPairScalarWhereInput[]
    id?: StringFilter<"QAPair"> | string
    artifactId?: StringFilter<"QAPair"> | string
    question?: StringFilter<"QAPair"> | string
    answer?: StringFilter<"QAPair"> | string
    choices?: JsonNullableFilter<"QAPair">
    correctKey?: StringNullableFilter<"QAPair"> | string | null
    difficulty?: IntNullableFilter<"QAPair"> | number | null
    tags?: StringNullableListFilter<"QAPair">
    metadata?: JsonNullableFilter<"QAPair">
    createdAt?: DateTimeFilter<"QAPair"> | Date | string
    updatedAt?: DateTimeFilter<"QAPair"> | Date | string
  }

  export type FlashcardUpsertWithWhereUniqueWithoutArtifactInput = {
    where: FlashcardWhereUniqueInput
    update: XOR<FlashcardUpdateWithoutArtifactInput, FlashcardUncheckedUpdateWithoutArtifactInput>
    create: XOR<FlashcardCreateWithoutArtifactInput, FlashcardUncheckedCreateWithoutArtifactInput>
  }

  export type FlashcardUpdateWithWhereUniqueWithoutArtifactInput = {
    where: FlashcardWhereUniqueInput
    data: XOR<FlashcardUpdateWithoutArtifactInput, FlashcardUncheckedUpdateWithoutArtifactInput>
  }

  export type FlashcardUpdateManyWithWhereWithoutArtifactInput = {
    where: FlashcardScalarWhereInput
    data: XOR<FlashcardUpdateManyMutationInput, FlashcardUncheckedUpdateManyWithoutArtifactInput>
  }

  export type FlashcardScalarWhereInput = {
    AND?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
    OR?: FlashcardScalarWhereInput[]
    NOT?: FlashcardScalarWhereInput | FlashcardScalarWhereInput[]
    id?: StringFilter<"Flashcard"> | string
    artifactId?: StringFilter<"Flashcard"> | string
    front?: StringFilter<"Flashcard"> | string
    back?: StringFilter<"Flashcard"> | string
    hint?: StringNullableFilter<"Flashcard"> | string | null
    tags?: StringNullableListFilter<"Flashcard">
    metadata?: JsonNullableFilter<"Flashcard">
    createdAt?: DateTimeFilter<"Flashcard"> | Date | string
    updatedAt?: DateTimeFilter<"Flashcard"> | Date | string
  }

  export type RoomShareUpsertWithWhereUniqueWithoutArtifactInput = {
    where: RoomShareWhereUniqueInput
    update: XOR<RoomShareUpdateWithoutArtifactInput, RoomShareUncheckedUpdateWithoutArtifactInput>
    create: XOR<RoomShareCreateWithoutArtifactInput, RoomShareUncheckedCreateWithoutArtifactInput>
  }

  export type RoomShareUpdateWithWhereUniqueWithoutArtifactInput = {
    where: RoomShareWhereUniqueInput
    data: XOR<RoomShareUpdateWithoutArtifactInput, RoomShareUncheckedUpdateWithoutArtifactInput>
  }

  export type RoomShareUpdateManyWithWhereWithoutArtifactInput = {
    where: RoomShareScalarWhereInput
    data: XOR<RoomShareUpdateManyMutationInput, RoomShareUncheckedUpdateManyWithoutArtifactInput>
  }

  export type ArtifactSourceUpsertWithWhereUniqueWithoutArtifactInput = {
    where: ArtifactSourceWhereUniqueInput
    update: XOR<ArtifactSourceUpdateWithoutArtifactInput, ArtifactSourceUncheckedUpdateWithoutArtifactInput>
    create: XOR<ArtifactSourceCreateWithoutArtifactInput, ArtifactSourceUncheckedCreateWithoutArtifactInput>
  }

  export type ArtifactSourceUpdateWithWhereUniqueWithoutArtifactInput = {
    where: ArtifactSourceWhereUniqueInput
    data: XOR<ArtifactSourceUpdateWithoutArtifactInput, ArtifactSourceUncheckedUpdateWithoutArtifactInput>
  }

  export type ArtifactSourceUpdateManyWithWhereWithoutArtifactInput = {
    where: ArtifactSourceScalarWhereInput
    data: XOR<ArtifactSourceUpdateManyMutationInput, ArtifactSourceUncheckedUpdateManyWithoutArtifactInput>
  }

  export type ContentArtifactCreateWithoutSourcesInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    owner: UserCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutSourcesInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutSourcesInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutSourcesInput, ContentArtifactUncheckedCreateWithoutSourcesInput>
  }

  export type LectureSourceCreateWithoutArtifactsInput = {
    id: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutSourcesInput
  }

  export type LectureSourceUncheckedCreateWithoutArtifactsInput = {
    id: string
    lectureId: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureSourceCreateOrConnectWithoutArtifactsInput = {
    where: LectureSourceWhereUniqueInput
    create: XOR<LectureSourceCreateWithoutArtifactsInput, LectureSourceUncheckedCreateWithoutArtifactsInput>
  }

  export type ContentArtifactUpsertWithoutSourcesInput = {
    update: XOR<ContentArtifactUpdateWithoutSourcesInput, ContentArtifactUncheckedUpdateWithoutSourcesInput>
    create: XOR<ContentArtifactCreateWithoutSourcesInput, ContentArtifactUncheckedCreateWithoutSourcesInput>
    where?: ContentArtifactWhereInput
  }

  export type ContentArtifactUpdateToOneWithWhereWithoutSourcesInput = {
    where?: ContentArtifactWhereInput
    data: XOR<ContentArtifactUpdateWithoutSourcesInput, ContentArtifactUncheckedUpdateWithoutSourcesInput>
  }

  export type ContentArtifactUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutSourcesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type LectureSourceUpsertWithoutArtifactsInput = {
    update: XOR<LectureSourceUpdateWithoutArtifactsInput, LectureSourceUncheckedUpdateWithoutArtifactsInput>
    create: XOR<LectureSourceCreateWithoutArtifactsInput, LectureSourceUncheckedCreateWithoutArtifactsInput>
    where?: LectureSourceWhereInput
  }

  export type LectureSourceUpdateToOneWithWhereWithoutArtifactsInput = {
    where?: LectureSourceWhereInput
    data: XOR<LectureSourceUpdateWithoutArtifactsInput, LectureSourceUncheckedUpdateWithoutArtifactsInput>
  }

  export type LectureSourceUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type LectureSourceUncheckedUpdateWithoutArtifactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentArtifactCreateWithoutQaPairsInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    owner: UserCreateNestedOneWithoutArtifactsInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutQaPairsInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutQaPairsInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutQaPairsInput, ContentArtifactUncheckedCreateWithoutQaPairsInput>
  }

  export type ContentArtifactUpsertWithoutQaPairsInput = {
    update: XOR<ContentArtifactUpdateWithoutQaPairsInput, ContentArtifactUncheckedUpdateWithoutQaPairsInput>
    create: XOR<ContentArtifactCreateWithoutQaPairsInput, ContentArtifactUncheckedCreateWithoutQaPairsInput>
    where?: ContentArtifactWhereInput
  }

  export type ContentArtifactUpdateToOneWithWhereWithoutQaPairsInput = {
    where?: ContentArtifactWhereInput
    data: XOR<ContentArtifactUpdateWithoutQaPairsInput, ContentArtifactUncheckedUpdateWithoutQaPairsInput>
  }

  export type ContentArtifactUpdateWithoutQaPairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutQaPairsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactCreateWithoutFlashcardsInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    owner: UserCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    shares?: RoomShareCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutFlashcardsInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    shares?: RoomShareUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutFlashcardsInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutFlashcardsInput, ContentArtifactUncheckedCreateWithoutFlashcardsInput>
  }

  export type ContentArtifactUpsertWithoutFlashcardsInput = {
    update: XOR<ContentArtifactUpdateWithoutFlashcardsInput, ContentArtifactUncheckedUpdateWithoutFlashcardsInput>
    create: XOR<ContentArtifactCreateWithoutFlashcardsInput, ContentArtifactUncheckedCreateWithoutFlashcardsInput>
    where?: ContentArtifactWhereInput
  }

  export type ContentArtifactUpdateToOneWithWhereWithoutFlashcardsInput = {
    where?: ContentArtifactWhereInput
    data: XOR<ContentArtifactUpdateWithoutFlashcardsInput, ContentArtifactUncheckedUpdateWithoutFlashcardsInput>
  }

  export type ContentArtifactUpdateWithoutFlashcardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutFlashcardsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type LectureCreateWithoutAssistantInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    folder: FolderCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    bookmarks?: BookmarkCreateNestedManyWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutAssistantInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutAssistantInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutAssistantInput, LectureUncheckedCreateWithoutAssistantInput>
  }

  export type ChatMessageCreateWithoutAssistantInput = {
    id: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutAssistantInput = {
    id: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutAssistantInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput>
  }

  export type ChatMessageCreateManyAssistantInputEnvelope = {
    data: ChatMessageCreateManyAssistantInput | ChatMessageCreateManyAssistantInput[]
    skipDuplicates?: boolean
  }

  export type LectureUpsertWithoutAssistantInput = {
    update: XOR<LectureUpdateWithoutAssistantInput, LectureUncheckedUpdateWithoutAssistantInput>
    create: XOR<LectureCreateWithoutAssistantInput, LectureUncheckedCreateWithoutAssistantInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutAssistantInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutAssistantInput, LectureUncheckedUpdateWithoutAssistantInput>
  }

  export type LectureUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutAssistantInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutAssistantInput, ChatMessageUncheckedUpdateWithoutAssistantInput>
    create: XOR<ChatMessageCreateWithoutAssistantInput, ChatMessageUncheckedCreateWithoutAssistantInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutAssistantInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutAssistantInput, ChatMessageUncheckedUpdateWithoutAssistantInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutAssistantInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutAssistantInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    assistantId?: StringFilter<"ChatMessage"> | string
    role?: EnumChatRoleFilter<"ChatMessage"> | $Enums.ChatRole
    content?: StringFilter<"ChatMessage"> | string
    toolName?: StringNullableFilter<"ChatMessage"> | string | null
    model?: StringNullableFilter<"ChatMessage"> | string | null
    metadata?: JsonNullableFilter<"ChatMessage">
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    updatedAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type LectureAssistantCreateWithoutMessagesInput = {
    id: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutAssistantInput
  }

  export type LectureAssistantUncheckedCreateWithoutMessagesInput = {
    id: string
    lectureId: string
    displayName?: string | null
    systemPrompt?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureAssistantCreateOrConnectWithoutMessagesInput = {
    where: LectureAssistantWhereUniqueInput
    create: XOR<LectureAssistantCreateWithoutMessagesInput, LectureAssistantUncheckedCreateWithoutMessagesInput>
  }

  export type LectureAssistantUpsertWithoutMessagesInput = {
    update: XOR<LectureAssistantUpdateWithoutMessagesInput, LectureAssistantUncheckedUpdateWithoutMessagesInput>
    create: XOR<LectureAssistantCreateWithoutMessagesInput, LectureAssistantUncheckedCreateWithoutMessagesInput>
    where?: LectureAssistantWhereInput
  }

  export type LectureAssistantUpdateToOneWithWhereWithoutMessagesInput = {
    where?: LectureAssistantWhereInput
    data: XOR<LectureAssistantUpdateWithoutMessagesInput, LectureAssistantUncheckedUpdateWithoutMessagesInput>
  }

  export type LectureAssistantUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutAssistantNestedInput
  }

  export type LectureAssistantUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutBookmarksInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutBookmarksInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutBookmarksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
  }

  export type LectureCreateWithoutBookmarksInput = {
    id: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutLecturesInput
    folder: FolderCreateNestedOneWithoutLecturesInput
    sources?: LectureSourceCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantCreateNestedOneWithoutLectureInput
  }

  export type LectureUncheckedCreateWithoutBookmarksInput = {
    id: string
    ownerId: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sources?: LectureSourceUncheckedCreateNestedManyWithoutLectureInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutLectureInput
    assistant?: LectureAssistantUncheckedCreateNestedOneWithoutLectureInput
  }

  export type LectureCreateOrConnectWithoutBookmarksInput = {
    where: LectureWhereUniqueInput
    create: XOR<LectureCreateWithoutBookmarksInput, LectureUncheckedCreateWithoutBookmarksInput>
  }

  export type UserUpsertWithoutBookmarksInput = {
    update: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
    create: XOR<UserCreateWithoutBookmarksInput, UserUncheckedCreateWithoutBookmarksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookmarksInput, UserUncheckedUpdateWithoutBookmarksInput>
  }

  export type UserUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type LectureUpsertWithoutBookmarksInput = {
    update: XOR<LectureUpdateWithoutBookmarksInput, LectureUncheckedUpdateWithoutBookmarksInput>
    create: XOR<LectureCreateWithoutBookmarksInput, LectureUncheckedCreateWithoutBookmarksInput>
    where?: LectureWhereInput
  }

  export type LectureUpdateToOneWithWhereWithoutBookmarksInput = {
    where?: LectureWhereInput
    data: XOR<LectureUpdateWithoutBookmarksInput, LectureUncheckedUpdateWithoutBookmarksInput>
  }

  export type LectureUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutBookmarksInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
  }

  export type UserCreateWithoutOwnedRoomsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutOwnedRoomsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutOwnedRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
  }

  export type RoomMembershipCreateWithoutRoomInput = {
    id: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
    invitedBy?: UserCreateNestedOneWithoutInvitationsSentInput
    user: UserCreateNestedOneWithoutRoomMembershipsInput
  }

  export type RoomMembershipUncheckedCreateWithoutRoomInput = {
    id: string
    userId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipCreateOrConnectWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    create: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type RoomMembershipCreateManyRoomInputEnvelope = {
    data: RoomMembershipCreateManyRoomInput | RoomMembershipCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type RoomShareCreateWithoutRoomInput = {
    id: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    artifact: ContentArtifactCreateNestedOneWithoutSharesInput
    sharedBy: UserCreateNestedOneWithoutRoomSharesInput
    notes?: RoomNoteCreateNestedManyWithoutShareInput
  }

  export type RoomShareUncheckedCreateWithoutRoomInput = {
    id: string
    artifactId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    notes?: RoomNoteUncheckedCreateNestedManyWithoutShareInput
  }

  export type RoomShareCreateOrConnectWithoutRoomInput = {
    where: RoomShareWhereUniqueInput
    create: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput>
  }

  export type RoomShareCreateManyRoomInputEnvelope = {
    data: RoomShareCreateManyRoomInput | RoomShareCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutOwnedRoomsInput = {
    update: XOR<UserUpdateWithoutOwnedRoomsInput, UserUncheckedUpdateWithoutOwnedRoomsInput>
    create: XOR<UserCreateWithoutOwnedRoomsInput, UserUncheckedCreateWithoutOwnedRoomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedRoomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedRoomsInput, UserUncheckedUpdateWithoutOwnedRoomsInput>
  }

  export type UserUpdateWithoutOwnedRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type RoomMembershipUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    update: XOR<RoomMembershipUpdateWithoutRoomInput, RoomMembershipUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type RoomMembershipUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    data: XOR<RoomMembershipUpdateWithoutRoomInput, RoomMembershipUncheckedUpdateWithoutRoomInput>
  }

  export type RoomMembershipUpdateManyWithWhereWithoutRoomInput = {
    where: RoomMembershipScalarWhereInput
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomShareUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomShareWhereUniqueInput
    update: XOR<RoomShareUpdateWithoutRoomInput, RoomShareUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomShareCreateWithoutRoomInput, RoomShareUncheckedCreateWithoutRoomInput>
  }

  export type RoomShareUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomShareWhereUniqueInput
    data: XOR<RoomShareUpdateWithoutRoomInput, RoomShareUncheckedUpdateWithoutRoomInput>
  }

  export type RoomShareUpdateManyWithWhereWithoutRoomInput = {
    where: RoomShareScalarWhereInput
    data: XOR<RoomShareUpdateManyMutationInput, RoomShareUncheckedUpdateManyWithoutRoomInput>
  }

  export type UserCreateWithoutInvitationsSentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
  }

  export type RoomCreateWithoutMembershipsInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutOwnedRoomsInput
    shares?: RoomShareCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutMembershipsInput = {
    id: string
    name: string
    description?: string | null
    ownerId: string
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    shares?: RoomShareUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutMembershipsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutRoomMembershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRoomMembershipsInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRoomMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
  }

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type RoomUpsertWithoutMembershipsInput = {
    update: XOR<RoomUpdateWithoutMembershipsInput, RoomUncheckedUpdateWithoutMembershipsInput>
    create: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutMembershipsInput, RoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type RoomUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedRoomsNestedInput
    shares?: RoomShareUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shares?: RoomShareUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UserUpsertWithoutRoomMembershipsInput = {
    update: XOR<UserUpdateWithoutRoomMembershipsInput, UserUncheckedUpdateWithoutRoomMembershipsInput>
    create: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomMembershipsInput, UserUncheckedUpdateWithoutRoomMembershipsInput>
  }

  export type UserUpdateWithoutRoomMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type RoomCreateWithoutSharesInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    owner: UserCreateNestedOneWithoutOwnedRoomsInput
    memberships?: RoomMembershipCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutSharesInput = {
    id: string
    name: string
    description?: string | null
    ownerId: string
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    memberships?: RoomMembershipUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutSharesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutSharesInput, RoomUncheckedCreateWithoutSharesInput>
  }

  export type ContentArtifactCreateWithoutSharesInput = {
    id: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    lecture: LectureCreateNestedOneWithoutArtifactsInput
    owner: UserCreateNestedOneWithoutArtifactsInput
    qaPairs?: QAPairCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactUncheckedCreateWithoutSharesInput = {
    id: string
    lectureId: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    qaPairs?: QAPairUncheckedCreateNestedManyWithoutArtifactInput
    flashcards?: FlashcardUncheckedCreateNestedManyWithoutArtifactInput
    sources?: ArtifactSourceUncheckedCreateNestedManyWithoutArtifactInput
  }

  export type ContentArtifactCreateOrConnectWithoutSharesInput = {
    where: ContentArtifactWhereUniqueInput
    create: XOR<ContentArtifactCreateWithoutSharesInput, ContentArtifactUncheckedCreateWithoutSharesInput>
  }

  export type UserCreateWithoutRoomSharesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomNotes?: RoomNoteCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutRoomSharesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomNotes?: RoomNoteUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutRoomSharesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomSharesInput, UserUncheckedCreateWithoutRoomSharesInput>
  }

  export type RoomNoteCreateWithoutShareInput = {
    id: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    author: UserCreateNestedOneWithoutRoomNotesInput
  }

  export type RoomNoteUncheckedCreateWithoutShareInput = {
    id: string
    authorId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteCreateOrConnectWithoutShareInput = {
    where: RoomNoteWhereUniqueInput
    create: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput>
  }

  export type RoomNoteCreateManyShareInputEnvelope = {
    data: RoomNoteCreateManyShareInput | RoomNoteCreateManyShareInput[]
    skipDuplicates?: boolean
  }

  export type RoomUpsertWithoutSharesInput = {
    update: XOR<RoomUpdateWithoutSharesInput, RoomUncheckedUpdateWithoutSharesInput>
    create: XOR<RoomCreateWithoutSharesInput, RoomUncheckedCreateWithoutSharesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutSharesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutSharesInput, RoomUncheckedUpdateWithoutSharesInput>
  }

  export type RoomUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutOwnedRoomsNestedInput
    memberships?: RoomMembershipUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type ContentArtifactUpsertWithoutSharesInput = {
    update: XOR<ContentArtifactUpdateWithoutSharesInput, ContentArtifactUncheckedUpdateWithoutSharesInput>
    create: XOR<ContentArtifactCreateWithoutSharesInput, ContentArtifactUncheckedCreateWithoutSharesInput>
    where?: ContentArtifactWhereInput
  }

  export type ContentArtifactUpdateToOneWithWhereWithoutSharesInput = {
    where?: ContentArtifactWhereInput
    data: XOR<ContentArtifactUpdateWithoutSharesInput, ContentArtifactUncheckedUpdateWithoutSharesInput>
  }

  export type ContentArtifactUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type UserUpsertWithoutRoomSharesInput = {
    update: XOR<UserUpdateWithoutRoomSharesInput, UserUncheckedUpdateWithoutRoomSharesInput>
    create: XOR<UserCreateWithoutRoomSharesInput, UserUncheckedCreateWithoutRoomSharesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomSharesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomSharesInput, UserUncheckedUpdateWithoutRoomSharesInput>
  }

  export type UserUpdateWithoutRoomSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomNotes?: RoomNoteUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomSharesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomNotes?: RoomNoteUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type RoomNoteUpsertWithWhereUniqueWithoutShareInput = {
    where: RoomNoteWhereUniqueInput
    update: XOR<RoomNoteUpdateWithoutShareInput, RoomNoteUncheckedUpdateWithoutShareInput>
    create: XOR<RoomNoteCreateWithoutShareInput, RoomNoteUncheckedCreateWithoutShareInput>
  }

  export type RoomNoteUpdateWithWhereUniqueWithoutShareInput = {
    where: RoomNoteWhereUniqueInput
    data: XOR<RoomNoteUpdateWithoutShareInput, RoomNoteUncheckedUpdateWithoutShareInput>
  }

  export type RoomNoteUpdateManyWithWhereWithoutShareInput = {
    where: RoomNoteScalarWhereInput
    data: XOR<RoomNoteUpdateManyMutationInput, RoomNoteUncheckedUpdateManyWithoutShareInput>
  }

  export type RoomShareCreateWithoutNotesInput = {
    id: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
    room: RoomCreateNestedOneWithoutSharesInput
    artifact: ContentArtifactCreateNestedOneWithoutSharesInput
    sharedBy: UserCreateNestedOneWithoutRoomSharesInput
  }

  export type RoomShareUncheckedCreateWithoutNotesInput = {
    id: string
    roomId: string
    artifactId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomShareCreateOrConnectWithoutNotesInput = {
    where: RoomShareWhereUniqueInput
    create: XOR<RoomShareCreateWithoutNotesInput, RoomShareUncheckedCreateWithoutNotesInput>
  }

  export type UserCreateWithoutRoomNotesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    folders?: FolderCreateNestedManyWithoutOwnerInput
    lectures?: LectureCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkCreateNestedManyWithoutUserInput
    ownedRooms?: RoomCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareCreateNestedManyWithoutSharedByInput
  }

  export type UserUncheckedCreateWithoutRoomNotesInput = {
    id: string
    name: string
    email: string
    emailVerified: boolean
    image?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    folders?: FolderUncheckedCreateNestedManyWithoutOwnerInput
    lectures?: LectureUncheckedCreateNestedManyWithoutOwnerInput
    bookmarks?: BookmarkUncheckedCreateNestedManyWithoutUserInput
    ownedRooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    invitationsSent?: RoomMembershipUncheckedCreateNestedManyWithoutInvitedByInput
    artifacts?: ContentArtifactUncheckedCreateNestedManyWithoutOwnerInput
    roomShares?: RoomShareUncheckedCreateNestedManyWithoutSharedByInput
  }

  export type UserCreateOrConnectWithoutRoomNotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomNotesInput, UserUncheckedCreateWithoutRoomNotesInput>
  }

  export type RoomShareUpsertWithoutNotesInput = {
    update: XOR<RoomShareUpdateWithoutNotesInput, RoomShareUncheckedUpdateWithoutNotesInput>
    create: XOR<RoomShareCreateWithoutNotesInput, RoomShareUncheckedCreateWithoutNotesInput>
    where?: RoomShareWhereInput
  }

  export type RoomShareUpdateToOneWithWhereWithoutNotesInput = {
    where?: RoomShareWhereInput
    data: XOR<RoomShareUpdateWithoutNotesInput, RoomShareUncheckedUpdateWithoutNotesInput>
  }

  export type RoomShareUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutSharesNestedInput
    artifact?: ContentArtifactUpdateOneRequiredWithoutSharesNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutRoomSharesNestedInput
  }

  export type RoomShareUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRoomNotesInput = {
    update: XOR<UserUpdateWithoutRoomNotesInput, UserUncheckedUpdateWithoutRoomNotesInput>
    create: XOR<UserCreateWithoutRoomNotesInput, UserUncheckedCreateWithoutRoomNotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomNotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomNotesInput, UserUncheckedUpdateWithoutRoomNotesInput>
  }

  export type UserUpdateWithoutRoomNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    folders?: FolderUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUpdateManyWithoutSharedByNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    image?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    folders?: FolderUncheckedUpdateManyWithoutOwnerNestedInput
    lectures?: LectureUncheckedUpdateManyWithoutOwnerNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutUserNestedInput
    ownedRooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    invitationsSent?: RoomMembershipUncheckedUpdateManyWithoutInvitedByNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutOwnerNestedInput
    roomShares?: RoomShareUncheckedUpdateManyWithoutSharedByNestedInput
  }

  export type SessionCreateManyUserInput = {
    id: string
    expiresAt: Date | string
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AccountCreateManyUserInput = {
    id: string
    accountId: string
    providerId: string
    accessToken?: string | null
    refreshToken?: string | null
    idToken?: string | null
    accessTokenExpiresAt?: Date | string | null
    refreshTokenExpiresAt?: Date | string | null
    scope?: string | null
    password?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FolderCreateManyOwnerInput = {
    id: string
    name: string
    color?: string | null
    emoji?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureCreateManyOwnerInput = {
    id: string
    folderId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BookmarkCreateManyUserInput = {
    lectureId: string
    createdAt: Date | string
  }

  export type RoomCreateManyOwnerInput = {
    id: string
    name: string
    description?: string | null
    isPrivate?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipCreateManyUserInput = {
    id: string
    roomId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipCreateManyInvitedByInput = {
    id: string
    roomId: string
    userId: string
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ContentArtifactCreateManyOwnerInput = {
    id: string
    lectureId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomShareCreateManySharedByInput = {
    id: string
    roomId: string
    artifactId: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteCreateManyAuthorInput = {
    id: string
    shareId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    idToken?: NullableStringFieldUpdateOperationsInput | string | null
    accessTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    refreshTokenExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lectures?: LectureUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutUserInput = {
    lectureId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUpdateManyWithoutRoomNestedInput
    shares?: RoomShareUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isPrivate?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: UserUpdateOneWithoutInvitationsSentNestedInput
    room?: RoomUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutRoomMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyWithoutInvitedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentArtifactUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lecture?: LectureUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    lectureId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomShareUpdateWithoutSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutSharesNestedInput
    artifact?: ContentArtifactUpdateOneRequiredWithoutSharesNestedInput
    notes?: RoomNoteUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateWithoutSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: RoomNoteUncheckedUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateManyWithoutSharedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    share?: RoomShareUpdateOneRequiredWithoutNotesNestedInput
  }

  export type RoomNoteUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    shareId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureCreateManyFolderInput = {
    id: string
    ownerId: string
    title: string
    description?: string | null
    language?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type LectureUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutLecturesNestedInput
    sources?: LectureSourceUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sources?: LectureSourceUncheckedUpdateManyWithoutLectureNestedInput
    artifacts?: ContentArtifactUncheckedUpdateManyWithoutLectureNestedInput
    assistant?: LectureAssistantUncheckedUpdateOneWithoutLectureNestedInput
    bookmarks?: BookmarkUncheckedUpdateManyWithoutLectureNestedInput
  }

  export type LectureUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LectureSourceCreateManyLectureInput = {
    id: string
    kind: $Enums.SourceType
    title?: string | null
    url?: string | null
    fileKey?: string | null
    textContent?: string | null
    transcript?: string | null
    language?: string | null
    durationSeconds?: number | null
    pageCount?: number | null
    checksum?: string | null
    status: $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ContentArtifactCreateManyLectureInput = {
    id: string
    ownerId: string
    type: $Enums.ArtifactType
    title: string
    description?: string | null
    language?: string | null
    status: $Enums.ProcessingStatus
    coverImageUrl?: string | null
    fileUrl?: string | null
    transcript?: string | null
    durationSeconds?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BookmarkCreateManyLectureInput = {
    userId: string
    createdAt: Date | string
  }

  export type LectureSourceUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactSourceUpdateManyWithoutSourceNestedInput
  }

  export type LectureSourceUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifacts?: ArtifactSourceUncheckedUpdateManyWithoutSourceNestedInput
  }

  export type LectureSourceUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    kind?: EnumSourceTypeFieldUpdateOperationsInput | $Enums.SourceType
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    fileKey?: NullableStringFieldUpdateOperationsInput | string | null
    textContent?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    checksum?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentArtifactUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutArtifactsNestedInput
    qaPairs?: QAPairUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    qaPairs?: QAPairUncheckedUpdateManyWithoutArtifactNestedInput
    flashcards?: FlashcardUncheckedUpdateManyWithoutArtifactNestedInput
    shares?: RoomShareUncheckedUpdateManyWithoutArtifactNestedInput
    sources?: ArtifactSourceUncheckedUpdateManyWithoutArtifactNestedInput
  }

  export type ContentArtifactUncheckedUpdateManyWithoutLectureInput = {
    id?: StringFieldUpdateOperationsInput | string
    ownerId?: StringFieldUpdateOperationsInput | string
    type?: EnumArtifactTypeFieldUpdateOperationsInput | $Enums.ArtifactType
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProcessingStatusFieldUpdateOperationsInput | $Enums.ProcessingStatus
    coverImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    transcript?: NullableStringFieldUpdateOperationsInput | string | null
    durationSeconds?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUpdateWithoutLectureInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBookmarksNestedInput
  }

  export type BookmarkUncheckedUpdateWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookmarkUncheckedUpdateManyWithoutLectureInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactSourceCreateManySourceInput = {
    artifactId: string
  }

  export type ArtifactSourceUpdateWithoutSourceInput = {
    artifact?: ContentArtifactUpdateOneRequiredWithoutSourcesNestedInput
  }

  export type ArtifactSourceUncheckedUpdateWithoutSourceInput = {
    artifactId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactSourceUncheckedUpdateManyWithoutSourceInput = {
    artifactId?: StringFieldUpdateOperationsInput | string
  }

  export type QAPairCreateManyArtifactInput = {
    id: string
    question: string
    answer: string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: string | null
    difficulty?: number | null
    tags?: QAPairCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type FlashcardCreateManyArtifactInput = {
    id: string
    front: string
    back: string
    hint?: string | null
    tags?: FlashcardCreatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomShareCreateManyArtifactInput = {
    id: string
    roomId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ArtifactSourceCreateManyArtifactInput = {
    sourceId: string
  }

  export type QAPairUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUncheckedUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QAPairUncheckedUpdateManyWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    question?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    choices?: NullableJsonNullValueInput | InputJsonValue
    correctKey?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: NullableIntFieldUpdateOperationsInput | number | null
    tags?: QAPairUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUncheckedUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlashcardUncheckedUpdateManyWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    front?: StringFieldUpdateOperationsInput | string
    back?: StringFieldUpdateOperationsInput | string
    hint?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: FlashcardUpdatetagsInput | string[]
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomShareUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutSharesNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutRoomSharesNestedInput
    notes?: RoomNoteUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: RoomNoteUncheckedUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateManyWithoutArtifactInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArtifactSourceUpdateWithoutArtifactInput = {
    source?: LectureSourceUpdateOneRequiredWithoutArtifactsNestedInput
  }

  export type ArtifactSourceUncheckedUpdateWithoutArtifactInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type ArtifactSourceUncheckedUpdateManyWithoutArtifactInput = {
    sourceId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatMessageCreateManyAssistantInput = {
    id: string
    role: $Enums.ChatRole
    content: string
    toolName?: string | null
    model?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type ChatMessageUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutAssistantInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumChatRoleFieldUpdateOperationsInput | $Enums.ChatRole
    content?: StringFieldUpdateOperationsInput | string
    toolName?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipCreateManyRoomInput = {
    id: string
    userId: string
    invitedById?: string | null
    role: $Enums.MemberRole
    status: $Enums.MemberStatus
    joinedAt?: Date | string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomShareCreateManyRoomInput = {
    id: string
    artifactId: string
    sharedById: string
    caption?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomMembershipUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedBy?: UserUpdateOneWithoutInvitationsSentNestedInput
    user?: UserUpdateOneRequiredWithoutRoomMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    invitedById?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumMemberRoleFieldUpdateOperationsInput | $Enums.MemberRole
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    joinedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomShareUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    artifact?: ContentArtifactUpdateOneRequiredWithoutSharesNestedInput
    sharedBy?: UserUpdateOneRequiredWithoutRoomSharesNestedInput
    notes?: RoomNoteUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: RoomNoteUncheckedUpdateManyWithoutShareNestedInput
  }

  export type RoomShareUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    artifactId?: StringFieldUpdateOperationsInput | string
    sharedById?: StringFieldUpdateOperationsInput | string
    caption?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteCreateManyShareInput = {
    id: string
    authorId: string
    content: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type RoomNoteUpdateWithoutShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutRoomNotesNestedInput
  }

  export type RoomNoteUncheckedUpdateWithoutShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomNoteUncheckedUpdateManyWithoutShareInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}