// ============================================================================
// Generator / Datasource (unchanged)
// ============================================================================

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
}

generator client {
  provider     = "prisma-client"
  output       = "../../src/generated/prisma"
  moduleFormat = "cjs"
}

// ============================================================================
// Existing Auth Models (kept as-is; only appended relations on User)
// ============================================================================

model User {
  id            String    @id @map("_id")
  name          String
  email         String
  emailVerified Boolean   @default(false)
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  role          String?
  banned        Boolean?  @default(false)
  banReason     String?
  banExpires    DateTime?
  sessions      Session[]
  accounts      Account[]

  // ----------------- New Relations -----------------
  folders         Folder[] // Folders owned by the user
  lectures        Lecture[]         @relation("LectureOwner")
  bookmarks       Bookmark[] // User ↔ Lecture bookmarks
  ownedRooms      Room[]            @relation("RoomOwner")
  roomMemberships RoomMembership[]  @relation("RoomMember")
  invitationsSent RoomMembership[]  @relation("MembershipInvitedBy")
  artifacts       ContentArtifact[] @relation("ArtifactOwner")
  roomShares      RoomShare[]       @relation("RoomShareSharedBy")
  roomNotes       RoomNote[]

  @@unique([email])
  @@map("user")
}

model Session {
  id        String   @id @map("_id")
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@index([userId])
  @@map("session")
}

model Account {
  id                    String    @id @map("_id")
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@index([userId])
  @@map("account")
}

model Verification {
  id         String    @id @map("_id")
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime? @default(now())
  updatedAt  DateTime? @updatedAt

  @@index([identifier])
  @@map("verification")
}

// ============================================================================
// Enums
// ============================================================================

enum SourceType {
  PDF
  MARKDOWN
  TEXT
  AUDIO
  YOUTUBE
}

enum ArtifactType {
  PODCAST // one generated audio episode
  VIDEO // one generated educational short/video
  QA_SET // a set (collection) of Q&A pairs
  FLASHCARD_SET // a set (collection) of flashcards
}

enum ProcessingStatus {
  PENDING
  PROCESSING
  READY
  FAILED
}

enum ChatRole {
  USER
  ASSISTANT
  SYSTEM
  TOOL
}

enum MemberRole {
  OWNER
  MEMBER
}

enum MemberStatus {
  INVITED
  ACCEPTED
  DECLINED
  REMOVED
}

// ============================================================================
// Core Content Models
// ============================================================================

/// A user-created folder that groups that user's lectures.
/// Requirement: "The user must create a Folder to save it's related Lectures"
model Folder {
  id      String @id @map("_id")
  ownerId String
  owner   User   @relation(fields: [ownerId], references: [id], onDelete: Cascade)

  name  String
  color String? // e.g., hex or token
  emoji String? // optional emoji marker

  lectures Lecture[]

  createdAt DateTime
  updatedAt DateTime

  // Prevent duplicate names per user for sanity; adjust if you want duplicates
  @@unique([ownerId, name])
  @@map("folder")
}

/// A lecture belongs to exactly one folder and one owner.
/// It aggregates many uploaded sources and many generated artifacts.
model Lecture {
  id String @id @map("_id")

  ownerId String
  owner   User   @relation("LectureOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  folderId String
  folder   Folder @relation(fields: [folderId], references: [id], onDelete: Cascade)

  title       String
  description String?
  language    String?

  // Uploads / inputs
  sources LectureSource[]

  // Outputs / generated content
  artifacts ContentArtifact[]

  // Per-lecture assistant (single assistant thread per lecture)
  assistant LectureAssistant?

  bookmarks Bookmark[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("lecture")
}

/// A single upload/input for a lecture. Supports multiple kinds.
/// Requirement: "Each Lecture can has a multiple uploaded sources"
model LectureSource {
  id        String  @id @map("_id")
  lectureId String
  lecture   Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  kind            SourceType
  title           String?
  url             String? // for remote resources (e.g., YouTube URL)
  fileKey         String? // storage key/path for uploaded files (PDF/audio/etc.)
  textContent     String?          @db.Text // for pasted text/markdown or extracted text
  transcript      String?          @db.Text // for audio/YouTube transcripts
  language        String?
  durationSeconds Int?
  pageCount       Int?
  checksum        String? // optional file integrity
  status          ProcessingStatus
  metadata        Json?

  artifacts ArtifactSource[] // backref via join

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lectureId])
  @@map("lecture_source")
}

/// A unified "generated artifact" record per lecture output.
/// Requirement: podcasts{many}, videos{many}, Q&A{many}, flash cards{many}
model ContentArtifact {
  id        String  @id @map("_id")
  lectureId String
  lecture   Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  // Who triggered/owns this generation
  ownerId String
  owner   User   @relation("ArtifactOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  type            ArtifactType
  title           String
  description     String?
  language        String?
  status          ProcessingStatus
  coverImageUrl   String?
  fileUrl         String? // for audio/video final media
  transcript      String?          @db.Text
  durationSeconds Int?
  metadata        Json?

  // Collections for QA sets / flashcard sets (only populated when type matches)
  qaPairs    QAPair[]
  flashcards Flashcard[]

  // Room sharing
  shares RoomShare[]

  // Provenance of inputs used for this artifact
  sources ArtifactSource[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lectureId, type])
  @@map("artifact")
}

/// Join table so a generated artifact can point back to the specific lecture sources it used.
model ArtifactSource {
  artifactId String
  sourceId   String

  artifact ContentArtifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)
  source   LectureSource   @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@id([artifactId, sourceId])
  @@map("artifact_source")
}

/// Individual question/answer entries for a QA_SET artifact.
model QAPair {
  id         String          @id @map("_id")
  artifactId String
  artifact   ContentArtifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  question   String   @db.Text
  answer     String   @db.Text
  choices    Json? // optional: MCQ options
  correctKey String? // optional key/index to the correct choice
  difficulty Int? // 1..5 or similar
  tags       String[] @default([]) // Postgres text[] via Prisma

  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([artifactId])
  @@map("qa_pair")
}

/// Individual flashcards belonging to a FLASHCARD_SET artifact.
model Flashcard {
  id         String          @id @map("_id")
  artifactId String
  artifact   ContentArtifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)

  front String   @db.Text
  back  String   @db.Text
  hint  String?
  tags  String[] @default([])

  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([artifactId])
  @@map("flashcard")
}

// ============================================================================
// Per-Lecture Assistant (Aref/Arifah)
// ============================================================================

/// One assistant "thread" per lecture.
/// Requirement: "Each Lecture has a chatbot assistant 'Aref/Arifah'"
model LectureAssistant {
  id String @id @map("_id")

  lectureId String  @unique
  lecture   Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  displayName  String? // e.g. "Aref" / "Arifah"
  systemPrompt String?
  model        String? // name of the model currently selected/routed
  metadata     Json?

  messages ChatMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("lecture_assistant")
}

/// Messages within the lecture assistant thread.
model ChatMessage {
  id          String           @id @map("_id")
  assistantId String
  assistant   LectureAssistant @relation(fields: [assistantId], references: [id], onDelete: Cascade)

  role     ChatRole
  content  String   @db.Text
  toolName String?
  model    String? // actual model used for this turn (if routed)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([assistantId, createdAt])
  @@map("chat_message")
}

// ============================================================================
// Bookmarks
// ============================================================================

/// Requirement: "The user can Bookmark a Lecture to be in the Bookmarks Folder"
/// Represented as a join; you can render this as a 'virtual Bookmarks folder' in UI.
model Bookmark {
  userId    String
  lectureId String

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  lecture Lecture @relation(fields: [lectureId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@id([userId, lectureId])
  @@map("bookmark")
}

// ============================================================================
// Rooms, Membership, Sharing & Notes
// ============================================================================

/// Requirement: "The user can create a Room"
model Room {
  id          String  @id @map("_id")
  name        String
  description String?

  ownerId String
  owner   User   @relation("RoomOwner", fields: [ownerId], references: [id], onDelete: Cascade)

  isPrivate Boolean?

  memberships RoomMembership[]
  shares      RoomShare[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("room")
}

/// Requirement: "The user who create the Room is the Owner ... invite another users ... Members"
model RoomMembership {
  id     String @id @map("_id")
  roomId String
  userId String

  // Two relations to User in the same model require names
  invitedById String?
  invitedBy   User?   @relation("MembershipInvitedBy", fields: [invitedById], references: [id], onDelete: SetNull)

  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user User @relation("RoomMember", fields: [userId], references: [id], onDelete: Cascade)

  role   MemberRole // OWNER or MEMBER (ensure there's exactly one OWNER via app logic)
  status MemberStatus // INVITED/ACCEPTED/...

  joinedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@unique([roomId, userId])
  @@map("room_membership")
}

/// Requirement: "Owner and Members can share their Multi‑format output content
/// generation ... in this Room"
model RoomShare {
  id         String @id @map("_id")
  roomId     String
  artifactId String
  sharedById String

  room     Room            @relation(fields: [roomId], references: [id], onDelete: Cascade)
  artifact ContentArtifact @relation(fields: [artifactId], references: [id], onDelete: Cascade)
  sharedBy User            @relation("RoomShareSharedBy", fields: [sharedById], references: [id], onDelete: Cascade)

  caption  String?
  metadata Json?

  notes RoomNote[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Prevent identical duplicate shares by the same person
  @@unique([roomId, artifactId, sharedById])
  @@index([roomId])
  @@map("room_share")
}

/// Requirement: "The Owner and Members can provide a note to the shared
/// Multi‑format output content generation"
model RoomNote {
  id       String @id @map("_id")
  shareId  String
  authorId String

  share  RoomShare @relation(fields: [shareId], references: [id], onDelete: Cascade)
  author User      @relation(fields: [authorId], references: [id], onDelete: Cascade)

  content  String @db.Text
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([shareId, createdAt])
  @@map("room_note")
}
